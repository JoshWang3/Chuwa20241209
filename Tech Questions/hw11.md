# Homework 11
## Spring IOC 

### 1. List all of the annotations you learned from class and homework to annotaitons.md (your own cheatsheet).
- see annotations.md

### 2. Compare Spring and Springboot? What are the benfits of Srpingboot?
- Spring Framework is a comprehensive and flexible framework for building Java applications, offering a wide range of tools for enterprise development, such as dependency injection (DI), aspect-oriented programming (AOP), and integration with various data access and messaging technologies. However, using Spring often requires significant setup and manual configuration, including XML-based or annotation-driven configurations.

- Spring Boot is built on top of the Spring Framework and aims to simplify the development process. It provides a set of conventions and preconfigured settings that enable developers to quickly create production-ready applications. By leveraging auto-configuration and opinionated defaults, Spring Boot eliminates much of the boilerplate code and manual configuration required in traditional Spring applications.

- Benefits of Spring Boot are: Reduced Configuration Effort, Embedded Servers, Simplified Dependency Management, Production-Ready Features, Microservices-Friendly, and easy Integration with Spring Ecosystem.

### 3. What is IOC and What is DI?
- Inversion of Control (IoC) is a design principle used in software development to decouple components and manage dependencies. It shifts the responsibility of creating and managing objects or components from the application code to a container or framework. In traditional programming, the developer is responsible for controlling the flow of the application and manually creating dependencies. With IoC, this control is inverted—the framework or container takes care of injecting the dependencies and managing the lifecycle of objects.

- Dependency Injection (DI) is a specific implementation of IoC. It refers to the process of providing an object’s required dependencies at runtime instead of the object creating them itself. DI is a design pattern that promotes loose coupling and easier testability of components. There are three primary types of DI: Constructor Injection, Setter Injection, and Field Injection.

### 4. What is @ComponentScan?
- `@ComponentScan` is an annotation in the Spring Framework that is used to specify the base packages where Spring should search for components, configurations, and services to register as beans in the application context. It is typically used alongside `@Configuration` or `@SpringBootApplication`. When Spring's IoC container starts, `@ComponentScan` tells it to scan the specified packages for classes annotated with component-scanning annotations such as `@Component`, `@Service`, `@Repository`, or `@Controller`. These annotated classes are then automatically registered as Spring-managed beans.

### 5. What is @SpringbootApplication?
- `@SpringBootApplication` is a key annotation in Spring Boot that serves as a convenience annotation combining several other Spring annotations commonly used for configuring a Spring Boot application. It simplifies application setup by bundling these annotations: `@SpringBootConfiguration`, `@EnableAutoConfiguration`, and `@ComponentScan`. The `@SpringBootApplication` annotation is placed on the main application class, which serves as the entry point for the Spring Boot application. It simplifies the configuration process by reducing boilerplate code and enabling essential Spring Boot features with minimal effort.

### 6. How many ways to define a bean? Provide code examples.
-In Spring, a bean is an object managed by the Spring IoC container. There are several ways to define and register a bean, depending on the context and the configuration style (XML, Java-based, or annotations).
| Method                         | Use Case                                                                                     |
|--------------------------------|----------------------------------------------------------------------------------------------|
| `@Component`, `@Service`       | For automatically discovered beans via component scanning.                                   |
| `@Bean` in `@Configuration`    | For explicitly defining beans and when more control over instantiation/configuration is needed. |
| XML Configuration              | For legacy applications or when XML-based configurations are a requirement.                 |
| Factory Methods                | When bean creation involves a factory pattern.                                              |
| Programmatically Registering   | For dynamically registering beans during runtime.                                           |
| `@Import`                      | For modularizing and reusing configuration classes.                                         |

### 7. What is default bean name for @Component and @Bean? Also compare @Component and @Bean.
- The default bean name for `@Component` is the **class name with the first letter in lowercase**.
- The default bean name for `@Bean` is the **name of the method where the `@Bean` annotation is applied**.

`@Component`: 
- Used to mark a class as a Spring-managed component
- Automatically detects and registers a bean during component scanning
- Dependencies are injected through constructors, setters, or fields
- Requires `@ComponentScan` for detection
- Use when the class is a straightforward component that can be automatically detected and registered

`@Bean`:
- Used to explicitly define a Spring-managed bean in a `@Configuration` class
- Manually defines a bean and its configuration when additional logic or customization is needed
- Can include dependencies directly in the method parameters
- Does not require scanning, as the bean is explicitly registered in the configuration class.
- Use when we need more control over the bean creation process, such as for third-party libraries, legacy code, or beans with custom initialization logic

### 8. Compare @component and @service, @repository, @controller?
- All these annotations are technically specializations of `@Component` and are functionally equivalent when it comes to registering beans.
Use @Component for generic, reusable components.
Use @Service for business logic to clearly indicate the service layer.
Use @Repository for data access to benefit from Spring’s exception translation.
Use @Controller for request handling in Spring MVC applications.

### 9. Explain @Autowired, @Qualifier, @Resource and @primary?
- `@Autowired` is a Spring-specific annotation that automatically injects a bean into a class. It is part of the Spring Framework and enables dependency injection by type.
- `@Qualifier` is used alongside `@Autowired` to resolve ambiguity when there are multiple beans of the same type. It specifies the exact bean to inject by name.
- `@Resource` is a JSR-250 annotation (from Java EE) that is supported by Spring. It performs injection by name first, and if no match is found, it falls back to type-based injection.
- `@Primary` is used to resolve ambiguity when multiple beans of the same type are candidates for injection. It marks one bean as the default bean to be injected.
```java
@Component("beanA")
public class DependencyA {}

@Component("beanB")
public class DependencyB {}

@Component
@Primary
public class DefaultDependency {}

@Component
public class Service {

    // Injects by type (DefaultDependency because of @Primary)
    @Autowired
    private DependencyA defaultDependency;

    // Injects by name (beanA)
    @Resource(name = "beanA")
    private DependencyA namedDependency;

    // Injects by specifying bean explicitly
    @Autowired
    @Qualifier("beanB")
    private DependencyB qualifiedDependency;
}
```

### 10. How many annotaitons we can use to inject a bean?
- Spring-Specific (`@Autowired`, `@Qualifier`, `@Primary`) are best suited for Spring applications, offering flexibility and additional features.
- JSR-250 (`@Resource`) are used when working on applications that may migrate to Java EE or when name-based injection is preferred.
- JSR-330 (`@Inject`, `@Named`) are used in contexts where CDI (Contexts and Dependency Injection) compatibility is required.

### 11. Explain and compare differnet types of dependency injection, their pros and cons, and use cases.
- Dependency Injection is a design pattern used to achieve Inversion of Control (IoC), where an object receives its dependencies from an external source rather than creating them itself. In Spring and general programming, DI can be implemented in three primary ways: Constructor Injection, Setter Injection, and Field Injection.

1. Constructor Injection: dependencies are passed to the object through its constructor at the time of creation. Spring automatically resolves and injects the required beans. It ensures the object is fully initialized during its creation, making it immutable if fields are `final`. It forces all required dependencies to be explicitly provided, preventing null values. Dependencies are clearly defined, allowing easy mocking or substitution during unit testing.

For classes with many dependencies, constructors can become lengthy and harder to read. In cases with optional dependencies, handling multiple constructors can complicate the design. It is best suited for classes with mandatory dependencies that are critical to its functionality, ideal for stateless beans or objects that should remain immutable.

2. Setter Injection: dependencies are provided via public setter methods after the object is created. Spring calls these methods to inject the dependencies. It supports optional dependencies since setters can be called selectively, allows dependencies to be modified or replaced after object creation, and avoids overly long constructors when a class has multiple dependencies.

Objects can be mutable since dependencies can change after construction.If required setters are not called, the object may enter an invalid state. The object might remain partially initialized until all setters are invoked. It is ideal for beans with optional dependencies or runtime-configurable properties, and suitable for classes where dependencies may need to change dynamically during the object's lifecycle.

3. Field Injection: dependencies are injected directly into fields using annotations like `@Autowired`, bypassing constructors and setters. It requires the least boilerplate code and is the easiest to set up, keeps the class uncluttered with constructor or setter methods, and best for simple scenarios where dependencies are straightforward.

It makes harder to understand an object's dependencies since they are not explicit. Unit testing is more difficult because private fields need reflection or additional tools to mock. Fields can be modified at any point, leading to potential issues. It is suitable for small applications or simple beans where testing and visibility are not priorities and useful for quickly setting up dependencies in less complex scenarios.

### 12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary, demo with code examples.
1. The `@Primary` annotation designates one bean as the default candidate for injection when multiple beans of the same type are available.
```java
@Configuration
public class AppConfig {
    
    @Bean
    public Animal dog() {
        return new Dog();
    }

    @Bean
    @Primary
    public Animal cat() {
        return new Cat();
    }
}
```
Injecting the Bean
```java
@Component
public class AnimalService {
    private final Animal animal;

    @Autowired
    public AnimalService(Animal animal) {
        this.animal = animal;
    }

    public void speak() {
        animal.makeSound();
    }
}
```
Since the `cat` bean is marked as `@Primary`, Spring will inject the `Cat` instance into `AnimalService`.

2. If multiple beans exist and none are marked as `@Primary`, or if you want to explicitly choose a bean, you can use the `@Qualifier` annotation.
```java
@Configuration
public class AppConfig {

    @Bean
    public Animal dog() {
        return new Dog();
    }

    @Bean
    public Animal cat() {
        return new Cat();
    }
}
```
Injecting a Specific Bean
```java
@Component
public class AnimalService {
    private final Animal animal;

    @Autowired
    public AnimalService(@Qualifier("dog") Animal animal) {
        this.animal = animal;
    }

    public void speak() {
        animal.makeSound();
    }
}
```
In this case, the `dog` bean is explicitly chosen because of the `@Qualifier("dog")`.

3. No `@Primary` and No `@Qualifier`

If multiple beans of the same type exist and neither `@Primary` nor `@Qualifier` is used, Spring will throw an `org.springframework.beans.factory.NoUniqueBeanDefinitionException`.

```java
@Configuration
public class AppConfig {

    @Bean
    public Animal dog() {
        return new Dog();
    }

    @Bean
    public Animal cat() {
        return new Cat();
    }
}

@Component
public class AnimalService {
    private final Animal animal;

    @Autowired
    public AnimalService(Animal animal) {
        this.animal = animal;
    }

    public void speak() {
        animal.makeSound();
    }
}
```
org.springframework.beans.factory.NoUniqueBeanDefinitionException:
No qualifying bean of type 'Animal' available: expected single matching bean but found 2: dog,cat

### 13. Compare BeanFactory and ApplicationContext in Spring framework?
- `BeanFactory`: is a fundamental and lightweight container that provides basic DI (Dependency Injection) functionality. It lazily loads and initializes beans only when they are requested, and is suitable for simple applications with minimal requirements. It saves memory and startup time for applications with many beans, while it is slower at runtime if beans are frequently requested.

- `ApplicationContext`: is a more advanced and feature-rich container that builds on `BeanFactory`. It eagerly loads and initializes all singleton beans during startup (by default). Designed for enterprise-level applications requiring additional functionality such as event propagation, declarative support, and internationalization. It ensures all dependencies are resolved at startup, catching configuration errors early, but it has higher startup time and memory consumption.

- Use `BeanFactory` when working on lightweight applications with limited functionality, and if lazy initialization is a strict requirement for performance reasons. `ApplicationContext` is used for most Spring applications, especially enterprise-level ones. If our application needs advanced features like event propagation, annotation processing, AOP, or internationalization.

### 14. Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.
- In Spring, the scope of a bean defines its lifecycle and visibility within the container. Bean scopes control how and when the Spring container creates new bean instances. By default, beans in Spring are singleton-scoped, but other scopes allow flexibility to suit different application requirements.

1. Singleton Scope (`singleton`): Only one instance of the bean is created and shared across the entire Spring container. This is the default scope in Spring, it is used for stateless beans or shared resources.

2. Prototype Scope (`prototype`): A new instance of the bean is created each time it is requested. It is used for stateful beans or when different instances are needed for each use.

3. Request Scope (`request`): It creates a new instance of the bean for each HTTP request. It is applicable in web applications and used for beans tied to an HTTP request lifecycle, such as request-specific data.

4. Session Scope (`session`): It creates a new bean instance for each HTTP session. It is applicable in web applications, and used for beans that need to maintain state across multiple requests in a session.

5. Application Scope (`application`): It creates a single instance of the bean for the entire lifecycle of a ServletContext (web application), and used for application-wide shared resources.

6. WebSocket Scope (`websocket`): It creates a new bean instance for the lifecycle of a WebSocket connection, and used in applications with WebSocket communication to manage connection-specific state.

### 15. Write a Spring application that registers and autowires beans,
#### - Demo different types of dependency injection
#### - Demo bean scopes.
#### - Demo dependency injection by type and by name, when there's ambiguity in bean definition.
#### - Demo bean registration by both @Component and @Bean
- see Projects

### 16. Explain builder pattern with code examples.
- The Builder Pattern is a creational design pattern used to construct complex objects step-by-step. It allows you to produce different types and representations of an object using the same construction process. This pattern is especially useful when creating objects with multiple optional or mandatory attributes.

```java
public class Computer {
    private String processor;
    private int ram;
    private String storage;
    private boolean graphicsCardEnabled;
    private boolean bluetoothEnabled;

    // Private constructor to enforce the use of the builder
    private Computer(ComputerBuilder builder) {
        this.processor = builder.processor;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.graphicsCardEnabled = builder.graphicsCardEnabled;
        this.bluetoothEnabled = builder.bluetoothEnabled;
    }

    @Override
    public String toString() {
        return "Computer [Processor=" + processor + ", RAM=" + ram + 
               "GB, Storage=" + storage + ", GraphicsCardEnabled=" + 
               graphicsCardEnabled + ", BluetoothEnabled=" + bluetoothEnabled + "]";
    }

    // Static inner Builder class
    public static class ComputerBuilder {
        private String processor;
        private int ram;
        private String storage;
        private boolean graphicsCardEnabled;
        private boolean bluetoothEnabled;

        public ComputerBuilder(String processor, int ram) {
            this.processor = processor;
            this.ram = ram;
        }

        public ComputerBuilder setStorage(String storage) {
            this.storage = storage;
            return this;
        }

        public ComputerBuilder setGraphicsCardEnabled(boolean graphicsCardEnabled) {
            this.graphicsCardEnabled = graphicsCardEnabled;
            return this;
        }

        public ComputerBuilder setBluetoothEnabled(boolean bluetoothEnabled) {
            this.bluetoothEnabled = bluetoothEnabled;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }
}

public class BuilderPatternDemo {
    public static void main(String[] args) {
        Computer computer = new Computer.ComputerBuilder("Intel i7", 16)
                                .setStorage("1TB SSD")
                                .setGraphicsCardEnabled(true)
                                .setBluetoothEnabled(false)
                                .build();

        System.out.println(computer);
    }
}

// Output:
// Computer [Processor=Intel i7, RAM=16GB, Storage=1TB SSD, GraphicsCardEnabled=true, BluetoothEnabled=false]
```

### 17. Clone https://github.com/CTYue/spring|OC, go through examples, make code in both main and main-loosecoupling work.