## 2. Compare Spring and Spring Boot? What are the benefits of Spring Boot?

**Spring**:
- Framework providing core features for building Java applications.
- Requires explicit configuration, including XML or annotations for bean definitions.
- Focuses on flexibility and modularity.

**Spring Boot**:
- Built on top of Spring; simplifies development by offering default configurations.
- Includes embedded servers (like Tomcat) for standalone applications.
- Reduces boilerplate code by using auto-configuration.
- Provides production-ready features (e.g., monitoring, metrics).

**Benefits of Spring Boot**:
- Faster development with less configuration.
- Easy integration with external libraries.
- Suitable for microservices architecture.
- Improved productivity with built-in tools.

---

## 3. What is IoC and What is DI?

- **Inversion of Control (IoC):** Design principle where control of object creation and lifecycle is given to a container or framework (Spring IoC Container).
- **Dependency Injection (DI):** A pattern within IoC where dependencies are injected into objects by the container rather than being created directly.

**Example:**
```java
@Component
class Service {
    private final Repository repository;

    @Autowired
    public Service(Repository repository) {
        this.repository = repository;
    }
}
```

---

## 4. What is @ComponentScan?

- Annotation to specify the packages Spring should scan for components, configurations, and services.

**Example:**
```java
@Configuration
@ComponentScan(basePackages = "com.example.project")
public class AppConfig {
}
```

---

## 5. What is @SpringBootApplication?

- Combines three annotations:
    - `@Configuration`: Defines configuration.
    - `@EnableAutoConfiguration`: Enables Spring Bootâ€™s auto-configuration.
    - `@ComponentScan`: Scans the base package for components.

**Example:**
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

---

## 6. How many ways to define a bean? Provide code examples.

1. **Using @Component:**
   ```java
   @Component
   public class MyBean {
   }
   ```

2. **Using @Bean:**
   ```java
   @Configuration
   public class Config {
       @Bean
       public MyBean myBean() {
           return new MyBean();
       }
   }
   ```

3. **XML Configuration:**
   ```xml
   <bean id="myBean" class="com.example.MyBean" />
   ```

---

## 7. What is the default bean name for @Component and @Bean? Also compare @Component and @Bean.

- **Default Bean Name:**
    - `@Component`: Class name starting with a lowercase letter.
    - `@Bean`: Method name.

- **Comparison:**
    - `@Component`: Class-level annotation; used for automatic scanning.
    - `@Bean`: Method-level annotation; explicitly declares a bean.

---

## 8. Compare @Component, @Service, @Repository, @Controller?

- **@Component:** Generic stereotype for any Spring component.
- **@Service:** Specialization of `@Component` for business logic.
- **@Repository:** Specialization for data access logic; supports exception translation.
- **@Controller:** Specialization for web controllers; handles HTTP requests.

---

## 9. Explain @Autowired, @Qualifier, @Resource, and @Primary?

- **@Autowired:** Autowires dependencies by type.
- **@Qualifier:** Specifies which bean to inject when multiple candidates exist.
- **@Resource:** Java annotation for dependency injection by name or type.
- **@Primary:** Marks a bean as the primary candidate.

**Example:**
```java
@Component
public class Service {

    @Autowired
    @Qualifier("specificBean")
    private MyBean myBean;
}
```

---

## 10. How many annotations can we use to inject a bean?

1. `@Autowired`
2. `@Resource`
3. `@Inject`

---

## 11. Explain and compare different types of dependency injection, their pros and cons, and use cases.

- **Constructor Injection:**
    - Dependencies are provided via constructor.
    - Pros: Immutable, better for testing.
    - Cons: Verbose.

- **Setter Injection:**
    - Dependencies are provided via setter methods.
    - Pros: Flexible, supports optional dependencies.
    - Cons: Requires mutable fields.

- **Field Injection:**
    - Dependencies are directly injected into fields.
    - Pros: Concise.
    - Cons: Harder to test.

**Example:**
```java
@Component
class Example {
    private final Dependency dependency;

    @Autowired
    public Example(Dependency dependency) {
        this.dependency = dependency;
    }
}
```

---

## 12. If we have multiple beans for one type, how to set one as primary? How does Spring IoC pick a bean if no primary? Demo with code examples.

- **Set Primary:**
  ```java
  @Component
  @Primary
  public class PrimaryBean {
  }
  ```

- **Without Primary:** Spring throws `NoUniqueBeanDefinitionException`.

**Example:**
```java
@Component
class Service {
    @Autowired
    private MyBean myBean;
}

@Component
class MyBean1 extends MyBean {
}

@Component
@Primary
class MyBean2 extends MyBean {
}
```

---

## 13. Compare BeanFactory and ApplicationContext in Spring Framework?

- **BeanFactory:**
    - Core IoC container.
    - Lazily initializes beans.
    - Lightweight, minimal functionality.

- **ApplicationContext:**
    - Built on BeanFactory.
    - Eagerly initializes beans.
    - Provides advanced features like event handling, AOP, etc.

---

## 14. Explain bean scope in Spring IoC? List bean scopes with explanations and code examples.

1. **Singleton:** Default; single instance per container.
2. **Prototype:** New instance for each request.
3. **Request:** Scoped to HTTP request (web apps).
4. **Session:** Scoped to HTTP session (web apps).
5. **Global Session:** Scoped to global HTTP session (portlets).

**Example:**
```java
@Component
@Scope("prototype")
class MyPrototypeBean {
}
```

---

## 15. Write a Spring application that registers and autowires beans.
---
## 16. Explain Builder Pattern with code examples.
