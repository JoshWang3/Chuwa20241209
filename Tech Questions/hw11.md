### 1. List all of the annotations you learned from class and homework to annotaitons.md (your own cheatsheet).

### 2. Compare Spring and Springboot? What are the benfits of Srpingboot?

- **Spring** is a comprehensive Java application framework providing a wide range of features for building enterprise-level applications.
- **Spring Boot** is an extension of Spring that simplifies development by offering auto-configuration, sensible defaults, and embedded servers.

---

### Key Difference:

Spring Boot is built on top of Spring to **reduce boilerplate and speed up development**, especially for microservices and standalone applications.

---

### Benefits of Spring Boot:

- Auto-configuration of Spring components
- Embedded servers (Tomcat, Jetty)
- Minimal setup and XML-free configuration
- Starter dependencies for easy setup
- Ideal for building REST APIs and microservices quickly

### Summary:

Spring = powerful but manual  
Spring Boot = fast, minimal, production-ready Spring

````

### 3. What is IOC and What is DI?

- **IoC (Inversion of Control)** is a design principle where the control of object creation and dependency management is transferred from the program to the framework (like Spring).
- **DI (Dependency Injection)** is a specific way to implement IoC by **injecting required objects (dependencies) into a class** instead of the class creating them itself.

### 4. What is @CompnonentScan ?

- `@ComponentScan` tells Spring **where to look for components**, such as classes annotated with `@Component`, `@Service`, `@Repository`, and `@Controller`.
- It enables Spring to automatically detect and register beans in the application context.

### 5. What is @SpringbootApplication ?

- `@SpringBootApplication` is a **convenience annotation** that combines three commonly used Spring annotations:

```java
@SpringBootApplication =
    @Configuration +
    @EnableAutoConfiguration +
    @ComponentScan
````

---

### Meaning:

- `@Configuration` → Marks the class as a source of bean definitions.
- `@EnableAutoConfiguration` → Enables Spring Boot’s auto-configuration based on classpath.
- `@ComponentScan` → Scans for components in the current package and sub-packages.

---

### 6. How many ways to define a bean? Provide code examples.

Spring provides **3 main ways** to define a bean:

---

### 1. Using `@Component` (or `@Service`, `@Repository`, `@Controller`)

- Automatically picked up by `@ComponentScan`

```java
@Component
public class MyBean {
    public void doSomething() {
        System.out.println("Component Bean");
    }
}
```

---

### 2. Using `@Bean` in a `@Configuration` class

- Manual bean definition with more control

```java
@Configuration
public class AppConfig {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

---

### 3. Using XML Configuration (Legacy style)

```xml
<!-- beans.xml -->
<beans>
    <bean id="myBean" class="com.example.MyBean" />
</beans>
```

```java
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
MyBean bean = context.getBean(MyBean.class);
```

---

### Summary:

- Annotation-based: `@Component`, `@Bean`
- XML-based (less common in Spring Boot)

```


### 7. What is default bean name for @Component and @Bean ? Also compare @Component and @Bean .

```

### 7. What Is the Default Bean Name for `@Component` and `@Bean`?

### Also Compare `@Component` and `@Bean`

---

### Default Bean Name:

- **@Component**: The default bean name is the **class name with the first letter in lowercase**.

```java
@Component
public class MyService {}  // Bean name = "myService"
```

- **@Bean**: The default bean name is the **method name**.

```java
@Bean
public MyService myService() {
    return new MyService(); // Bean name = "myService"
}
```

---

### Comparison: `@Component` vs `@Bean`

| Feature           | @Component                      | @Bean                                 |
| ----------------- | ------------------------------- | ------------------------------------- |
| Use Case          | Auto-detectable classes         | Manual, fine-grained control          |
| Default Bean Name | Class name with lowercase start | Method name                           |
| Defined In        | Directly on class               | Inside `@Configuration` class         |
| Flexibility       | Less flexible                   | More control (e.g., constructor args) |
| Scanning Required | Yes (`@ComponentScan`)          | No                                    |

---

### Summary:

- Use `@Component` for general-purpose, auto-discovered beans.
- Use `@Bean` when you need **explicit control** over bean creation.

```


### 8. Compare @component and @service , @repository , @controller ?

```

### 8. Compare `@Component`, `@Service`, `@Repository`, and `@Controller`

All are **stereotype annotations** used to define beans and enable component scanning, but they serve different roles in layered architecture.

---

### Common Behavior:

- All are detected by `@ComponentScan`
- All are registered as Spring beans

---

### Differences:

| Annotation    | Layer         | Purpose                                                  |
| ------------- | ------------- | -------------------------------------------------------- |
| `@Component`  | Generic       | Base annotation, used for any component                  |
| `@Service`    | Service Layer | Marks business logic classes                             |
| `@Repository` | DAO Layer     | Marks data access classes, enables exception translation |
| `@Controller` | Web Layer     | Marks web controllers that handle HTTP requests          |

---

### 9. Explain @Autowired , @Qualifier , @Resource and @Primary ?

| Annotation   | Injects by | Use Case                          |
| ------------ | ---------- | --------------------------------- |
| `@Autowired` | Type       | Default injection                 |
| `@Qualifier` | Name       | Disambiguate multiple beans       |
| `@Resource`  | Name/Type  | Standard Java alternative         |
| `@Primary`   | Type       | Sets a default bean for injection |

````

### 10. How many annotaitons we can use to inject a bean?

---

### 1. `@Autowired` (Spring-specific)
- Injects a bean by type.
- Can be used on fields, constructors, and setters.

---

### 2. `@Qualifier` (Used with `@Autowired`)
- Helps specify the exact bean by name when multiple beans of the same type exist.

---

### 3. `@Resource` (JSR-250 standard)
- Injects by name first, then type.
- Not Spring-specific; comes from Java EE.

---

### 4. `@Inject` (JSR-330 standard, optional)
- Works like `@Autowired`, but without Spring-specific features.
- Less commonly used in Spring projects.

---

### 11. Explain and compare differnet types of denpendency injection, their pros and cons, and use cases.



Spring supports **three main types** of Dependency Injection (DI):

---

### 1. Constructor Injection

```java
@Component
public class UserService {
    private final UserRepository repo;

    @Autowired
    public UserService(UserRepository repo) {
        this.repo = repo;
    }
}
````

**Pros:**

- Recommended by Spring
- Immutable dependencies (final fields)
- Easier for unit testing
- Null-safe (enforced at object creation)

**Cons:**

- More code if many dependencies

**Use Case:** Required dependencies that must not change

---

### 2. Setter Injection

```java
@Component
public class UserService {
    private UserRepository repo;

    @Autowired
    public void setRepo(UserRepository repo) {
        this.repo = repo;
    }
}
```

**Pros:**

- Optional dependencies
- Clear method to update dependency if needed

**Cons:**

- Allows nulls (not safe for required dependencies)
- Dependencies can change after object creation

**Use Case:** Optional or configurable dependencies

---

### 3. Field Injection

```java
@Component
public class UserService {
    @Autowired
    private UserRepository repo;
}
```

**Pros:**

- Short and simple code

**Cons:**

- Hard to test (requires reflection or Spring context)
- Breaks immutability and encapsulation
- Not recommended for production code

**Use Case:** Quick setup or prototypes

---

### 12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary, demo with code examples.

### How Does Spring IoC Pick One Bean to Inject If No Primary? (With Code Examples)

---

### 1. Marking a Bean as Primary

Use `@Primary` to mark the default bean when multiple beans of the same type exist.

```java
@Configuration
public class AppConfig {

    @Bean
    @Primary
    public Animal dog() {
        return new Dog();
    }

    @Bean
    public Animal cat() {
        return new Cat();
    }
}
```

```java
@Component
public class ZooService {

    @Autowired
    private Animal animal; // Will inject Dog (the @Primary bean)
}
```

---

### 2. Without @Primary — Use @Qualifier to Choose

If no bean is marked `@Primary`, and multiple beans exist, Spring will throw an error unless you use `@Qualifier`:

```java
@Component
public class ZooService {

    @Autowired
    @Qualifier("cat")
    private Animal animal; // Injects the Cat bean
}
```

---

### 13. Compare BeanFactory and ApplicationContext in Spring framework?

| Feature              | BeanFactory           | ApplicationContext                |
| -------------------- | --------------------- | --------------------------------- |
| Basic Functionality  | Yes (Core container)  | Yes (Built on BeanFactory)        |
| Eager Initialization | No (lazy by default)  | Yes (eager by default)            |
| AOP Support          | No                    | Yes                               |
| Event Support        | No                    | Yes                               |
| Internationalization | No                    | Yes                               |
| Recommended For      | Lightweight use cases | Full-featured Spring applications |

### Summary:

- `BeanFactory`: Lightweight, basic container.
- `ApplicationContext`: Full-featured, commonly used in Spring Boot.

### 14. Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.

Bean scope defines **how many instances** of a bean Spring creates and **how long it lives**.

---

### Common Bean Scopes in Spring:

1. **singleton** (default)

- Only one instance per Spring container.

```java
@Scope("singleton")
@Component
public class MyBean {}
```

2. **prototype**

- A new instance is created every time the bean is requested.

```java
@Scope("prototype")
@Component
public class MyBean {}
```

3. **request** (Web only)

- One instance per HTTP request.

```java
@Scope("request")
@Component
public class MyController {}
```

4. **session** (Web only)

- One instance per HTTP session.

```java
@Scope("session")
@Component
public class MySessionBean {}
```

5. **application** (Web only)

- One instance per ServletContext (web app).

```java
@Scope("application")
@Component
public class MyAppBean {}
```

---

### 15. Write a Spring application that registers and autowires beans,

#### - Demo different types of dependency injection

#### - Demo bean scopes.

#### - Demo dependency injection by type and by name, when there's ambiguity in bean definition.

#### - Demo bean registration by both @Component and @Bean

### 16. Explain builder pattern with code examples.

The **Builder Pattern** is a creational design pattern used to construct complex objects **step-by-step**, especially when an object has many optional parameters.

---

### When to Use:

- When constructors have too many parameters.
- When you want immutability with readable object creation.

---

### Example: Without Builder Pattern (Ugly)

```java
User user = new User("Alice", 25, "NY", "Engineer", "alice@example.com");
```

---

### Example: With Builder Pattern

#### Step 1: Create the class with a static `Builder`

```java
public class User {
    private final String name;
    private final int age;
    private final String city;
    private final String job;
    private final String email;

    private User(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.city = builder.city;
        this.job = builder.job;
        this.email = builder.email;
    }

    public static class Builder {
        private String name;
        private int age;
        private String city;
        private String job;
        private String email;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder city(String city) {
            this.city = city;
            return this;
        }

        public Builder job(String job) {
            this.job = job;
            return this;
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

#### Step 2: Use the Builder

```java
User user = new User.Builder()
                .name("Alice")
                .age(25)
                .city("NY")
                .job("Engineer")
                .email("alice@example.com")
                .build();
```

---

### 17. Clone https://github.com/CTYue/springIOC, go through examples, make code in both main and main-loosecoupling work.

```

```

```

```
