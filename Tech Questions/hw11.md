# hw11

---

### 1. Compare Spring and Springboot? What are the benfits of Srpingboot?
#### Comparison of Spring and Spring Boot

| Aspect                   | Spring Framework                | Spring Boot                                       |
|--------------------------|---------------------------------|---------------------------------------------------|
| **Setup**                | Requires manual configuration   | Provides auto-configuration                       |
| **Complexity**           | More complex, needs boilerplate | Simplifies development with defaults              |
| **Dependencies**         | Manual dependency management    | Built-in dependency management                    |
| **Configuration**        | XML or Java-based               | Annotation and convention-based                   |
| **Embedded Server**      | External servers required       | Comes with embedded servers (Tomcat, Jetty, etc.) |
| **Microservices**        | Needs additional setup          | Designed for microservices out-of-the-box         |
| **Production Readiness** | Requires manual setup           | Provides built-in monitoring and metrics          |

#### Benefits of Spring Boot
1. **Simplified Development:** Reduces boilerplate code with defaults and auto-configuration.
2. **Embedded Servers:** Comes with built-in support for Tomcat, Jetty, etc., making deployment easier.
3. **Dependency Management:** Handles dependencies via `spring-boot-starter` modules.
4. **Microservice Friendly:** Ideal for creating stand-alone, production-ready microservices.
5. **Production-Ready Features:** Includes health checks, metrics, and logging support out-of-the-box.
6. **Faster Development:** Rapid application development using opinionated defaults.
7. **Spring Ecosystem Compatibility:** Fully compatible with existing Spring projects.

In summary, **Spring Boot** builds on top of **Spring**, offering faster development with less configuration and better support for modern microservices architecture.


### 2. What is IOC and What is DI?
#### What is IoC (Inversion of Control)?
- **Definition:** IoC is a design principle in which the control of object creation, dependency management, and lifecycle management is transferred from the application code to a container or framework.
- **Purpose:** Helps to achieve better modularity and testability by decoupling code dependencies.
- **Example:** In Spring, the IoC container manages bean creation and dependencies.

#### What is DI (Dependency Injection)?
- **Definition:** DI is a design pattern that implements IoC by injecting dependencies into a class from an external source rather than creating them internally.
- **Types of DI:**
    1. **Constructor Injection** – Dependencies are provided via the constructor.
    2. **Setter Injection** – Dependencies are provided via setter methods.
    3. **Field Injection** – Dependencies are injected directly into fields (using annotations like `@Autowired` in Spring).
- **Benefits:**
    - Reduces tight coupling between components.
    - Enhances code maintainability and testability.
    - Simplifies object management by delegating it to the framework.

### Relationship between IoC and DI
- **IoC** is the broader concept where the framework takes control, and **DI** is a specific way to achieve IoC by providing required dependencies to components.


### 3. What is `@CompnonentScan`?
#### What is `@ComponentScan`?
- **Definition:** `@ComponentScan` is a Spring annotation used to specify the base packages where Spring should look for components (e.g., `@Component`, `@Service`, `@Repository`, `@Controller`) to automatically register them as beans in the application context.
- **Usage:** It helps in auto-detecting and managing beans without explicitly defining them in configuration files.

#### Example:
```java
@Configuration
@ComponentScan(basePackages = "com.example.project")
public class AppConfig {
}
```


### 4. What is `@SpringbootApplication`?
- **Definition:** `@SpringBootApplication` is a convenience annotation in Spring Boot that combines three commonly used annotations:
    - `@Configuration` – Marks the class as a source of bean definitions.
    - `@EnableAutoConfiguration` – Enables Spring Boot’s auto-configuration feature to automatically configure beans based on classpath dependencies.
    - `@ComponentScan` – Scans the package where the application is located for Spring components.

### Usage:
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```


### 5. How many ways to define a bean? Provide code examples.
# Ways to Define a Bean in Spring

There are multiple ways to define a bean in Spring. Here are four common approaches:

---

#### 1. Using Java Configuration with `@Bean`

```java
@Configuration
public class AppConfig {

    @Bean
    public MyBean myBean() {
        return new MyBean(); // Your custom bean object
    }
}
```
- Create a class annotated with `@Configuration`.
- Use `@Bean` to indicate methods that return beans.

#### 2. Using XML Configuration

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="myBean" class="com.example.MyBean" />
</beans>

```
- Define beans in an XML file using the `<bean>` tag.
- Specify the fully qualified class name and bean ID.

#### 3. Using Stereotype Annotations (e.g., @Component)

```java
@Component
public class MyBean {
    // Bean logic here
}
```

```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    // Scans for @Component (and similar) beans in the specified package
}
```
- Mark your class with `@Component`, `@Service`, or `@Repository`.
- Use `@ComponentScan` in a configuration class to detect and register these beans automatically.

#### 4. Using a `FactoryBean`

```java
public class MyFactoryBean implements FactoryBean<MyBean> {

    @Override
    public MyBean getObject() throws Exception {
        // Custom instantiation logic
        return new MyBean();
    }

    @Override
    public Class<?> getObjectType() {
        return MyBean.class;
    }
}
```

```xml
<bean id="myFactoryBean" class="com.example.MyFactoryBean" />
```
- Implement `FactoryBean` to control instantiation logic in detail.
- Spring treats the returned object as the actual bean.


### 6. What is default bean name for `@Component` and `@Bean` ? Also compare `@Component` and `@Bean`.

#### 1. `@Component` Default Bean Name
- By default, the bean name is the **class name with the first letter in lowercase.**
- **Example:**
  ```java
  @Component
  public class MyService {
      public void execute() { }
  }
  ```
The bean name will be `myService`.

#### 2. `@Bean` Default Bean Name
- By default, the bean name is the method name that declares the bean.
- **Example:**
    ```java
    @Configuration
    public class AppConfig {
        @Bean
        public MyService myServiceBean() {
            return new MyService();
        }
    }
    
    ```
The bean name will be `myServiceBean`.

#### Comparison of `@Component` vs. `@Bean`

| Aspect                   | `@Component`                                        | `@Bean`                                                              |
|--------------------------|-----------------------------------------------------|----------------------------------------------------------------------|
| **Definition**           | Declares a bean at the class level.                 | Declares a bean at the method level inside a `@Configuration` class. |
| **Usage**                | Used for services, repositories, controllers, etc.  | Used for complex bean creation logic.                                |
| **Default Bean Name**    | Class name with the first letter lowercase.         | Method name.                                                         |
| **Customization**        | Use `@Component("customName")` to customize name.   | Use `@Bean("customName")` to customize name.                         |
| **Scanning**             | Detected via component scanning (`@ComponentScan`). | Declared explicitly in configuration class.                          |
| **Scope**                | Default singleton, can change via `@Scope`.         | Default singleton, can change via `@Scope`.                          |
| **Dependency Injection** | Automatically resolved by Spring.                   | Manually wired with method logic.                                    |


### 7. What is default bean name for `@Component` and `@Bean` ? Also compare `@Component` and `@Bean`.

In Spring, `@Component`, `@Service`, `@Repository`, and `@Controller` are all stereotypes used to define Spring-managed beans. They have similar functionalities but are intended for different layers of an application.

---

| Annotation    | Purpose                                            | Typical Use Case                               | Additional Features                             |
|---------------|----------------------------------------------------|------------------------------------------------|-------------------------------------------------|
| `@Component`  | Generic stereotype for any Spring bean.            | Used for general-purpose components.           | Provides no additional functionality.           |
| `@Service`    | Specialization of `@Component` for business logic. | Used for service-layer beans (business logic). | Indicates intent to hold business logic.        |
| `@Repository` | Specialization of `@Component` for data access.    | Used for DAO (Data Access Object) classes.     | Provides exception translation.                 |
| `@Controller` | Specialization of `@Component` for web layers.     | Used for handling HTTP requests (Spring MVC).  | Works with `@RequestMapping` and returns views. |

---

### Key Differences

1. **Functionality:**
    - `@Component` is a generic stereotype, whereas the others provide specific intent and additional functionalities.
    - `@Repository` adds automatic exception translation for database-related exceptions.
    - `@Controller` is used specifically in web applications to handle HTTP requests.

2. **Use Case Intent:**
    - `@Service` implies the class contains business logic.
    - `@Repository` suggests interaction with the database.
    - `@Controller` is meant for handling web requests.

3. **Scanning Mechanism:**
    - All these annotations are detected by `@ComponentScan` and registered as beans in the Spring context.

---

### Example Usage

**`@Component` Example:**
```java
@Component
public class MyComponent {
    public void performTask() {
        System.out.println("Task performed");
    }
}
```

**`@Service` Example:**
```java
@Service
public class MyService {
    public String process() {
        return "Service processing";
    }
}
```

**`@Repository` Example:**
```java
@Repository
public class MyRepository {
    public String getData() {
        return "Data retrieved";
    }
}
```

**`@Controller` Example:**
```java
@Controller
public class MyController {
    @GetMapping("/hello")
    public String sayHello() {
        return "hello";
    }
}
```
**Conclusion**
- Use @Component for generic beans.
- Use @Service for business logic processing.
- Use @Repository for data access and exception translation.
- Use @Controller for web controllers handling HTTP requests.


### 8. Explain `@Autowired` , `@Qualifier` , `@Resource` and `@Primary`?
Spring provides several annotations to manage dependency injection efficiently. These annotations help specify how beans are injected and resolved.

---

#### 1. `@Autowired`
- **Purpose:** Automatically injects dependencies by type.
- **Usage:** Can be applied to constructors, fields, or setter methods.
- **Behavior:** If multiple beans of the same type exist, ambiguity must be resolved using `@Qualifier` or `@Primary`.
- **Example:**
  ```java
  @Component
  public class MyService {
      @Autowired
      private MyRepository myRepository;
  }
  ```

#### 2. `@Qualifier`
- **Purpose:** Resolves conflicts by specifying the exact bean to be injected when multiple beans of the same type exist.
- **Usage:** Works alongside @Autowired.
- **Example:**
    ```java
    @Component("customRepository")
    public class CustomRepository implements MyRepository { }
    
    @Component
    public class MyService {
        @Autowired
        @Qualifier("customRepository")
        private MyRepository myRepository;
    }
    
    ```

#### 3. `@Resource`
- **Purpose:** Injects dependencies by name (default) and falls back to type if no matching name is found.
- **Usage:** Part of JSR-250 (Java EE), providing compatibility with non-Spring environments.
- **Example:**
```java
@Component
public class MyService {
    @Resource(name = "myRepository")
    private MyRepository repository;
}
```

#### 4. `@Primary`
- **Purpose:** Marks a bean as the primary candidate for injection when multiple beans of the same type exist.
- **Usage:** Used to provide a default bean without requiring `@Qualifier`.
- **Example:**
    ```java
    @Primary
    @Component
    public class DefaultRepository implements MyRepository { }
    
    @Component
    public class MyService {
        @Autowired
        private MyRepository myRepository;  // DefaultRepository will be injected
    }
    
    ```

#### Comparison Table

| Annotation   | Injection Type             | Resolution Order | Use Case                                     |
|--------------|----------------------------|------------------|----------------------------------------------|
| `@Autowired` | By type                    | Type-based       | General dependency injection.                |
| `@Qualifier` | By name (with type)        | Name-based       | Resolve conflicts when multiple beans exist. |
| `@Resource`  | By name (default), by type | Name > Type      | JSR-250 integration, name-based injection.   |
| `@Primary`   | By type                    | Type-based       | Set a default bean among multiple options.   |

**Conclusion**
- Use `@Autowired` for automatic dependency injection.
- Use `@Qualifier` to resolve ambiguity when multiple beans exist.
- Use `@Resource` for name-based injection and compatibility with Java EE.
- Use `@Primary` to set a default bean when multiple options are available.


### 9. How many annotations we can use to inject a bean?
Spring supports three main annotations for injecting a bean into your components:

1. **`@Autowired`**
    - Spring-specific annotation used for automatic dependency injection.

2. **`@Inject`**
    - Part of the Java Dependency Injection (JSR-330) standard.

3. **`@Resource`**
    - Part of JSR-250, can also be used for dependency injection with Spring.


### 10. Explain and compare differnet types of dependency injection, their pros and cons, and use cases.

Dependency Injection (DI) is a design pattern used to achieve Inversion of Control (IoC) by supplying dependencies from an external source rather than creating them within a class. There are three main types of dependency injection:

### 1. Constructor Injection
#### Explanation:
Dependencies are provided through the class constructor at the time of object creation.

#### Pros and Cons:
| Pros                        | Cons                                                                |
|-----------------------------|---------------------------------------------------------------------|
| Encourages immutability     | Can lead to too many parameters in constructors (constructor bloat) |
| Makes dependencies explicit | Difficult to manage when dependency graph is complex                |
| Easier unit testing         |                                                                     |

#### Use Cases:
- When dependencies are required for the object's entire lifecycle.
- Commonly used in frameworks like Spring and Angular.

---

### 2. Setter Injection
#### Explanation:
Dependencies are provided via setter methods after object creation.

#### Pros and Cons:
| Pros                                 | Cons                                                                          |
|--------------------------------------|-------------------------------------------------------------------------------|
| Allows optional dependencies         | Potential for objects to be in an inconsistent state before dependency is set |
| Improves readability and flexibility | Increases the risk of runtime errors due to uninitialized dependencies        |
| Supports reusability                 | More prone to changes, making testing harder                                  |

#### Use Cases:
- When dependencies are optional or can change over time.
- Used in UI components and configurations.

---

### 3. Interface Injection
#### Explanation:
A dependency is injected via an interface method, requiring the dependent class to implement the interface.

#### Pros and Cons:
| Pros                                                     | Cons                                                          |
|----------------------------------------------------------|---------------------------------------------------------------|
| Decouples implementation and injection logic             | Forces implementation of the interface, increasing complexity |
| Useful when a component needs to be injected dynamically | Less commonly supported by DI frameworks                      |

#### Use Cases:
- When designing reusable components that must adhere to a contract.
- Often used in plugin-based architectures.

---

### Comparison Table

| Feature               | Constructor Injection | Setter Injection | Interface Injection |
|-----------------------|-----------------------|------------------|---------------------|
| Dependency visibility | High                  | Moderate         | Moderate            |
| Immutability          | Encourages            | No               | No                  |
| Complexity            | Moderate to high      | Low to moderate  | High                |
| Testability           | High                  | Moderate         | Moderate            |
| Flexibility           | Low                   | High             | Moderate            |

---

### Conclusion
- **Constructor Injection** is best for required, immutable dependencies.
- **Setter Injection** is ideal for optional or changeable dependencies.
- **Interface Injection** suits modular and dynamically pluggable components.

Each type has its strengths and trade-offs, and the choice depends on the specific use case and design goals.


### 11. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary, demo with code examples.

When there are multiple beans of the same type in the Spring IoC (Inversion of Control) container, Spring provides several ways to determine which bean should be injected:

### 1. Using `@Primary` Annotation
Spring allows you to mark one bean as the primary candidate for injection using the `@Primary` annotation. If no other qualifiers are specified, Spring will automatically inject the primary bean.

#### Example:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

interface PaymentService {
    void processPayment();
}

class CreditCardPaymentService implements PaymentService {
    @Override
    public void processPayment() {
        System.out.println("Processing credit card payment");
    }
}

class PaypalPaymentService implements PaymentService {
    @Override
    public void processPayment() {
        System.out.println("Processing PayPal payment");
    }
}

@Configuration
class AppConfig {
    
    @Bean
    @Primary
    public PaymentService creditCardPaymentService() {
        return new CreditCardPaymentService();
    }

    @Bean
    public PaymentService paypalPaymentService() {
        return new PaypalPaymentService();
    }
}

class PaymentProcessor {
    private final PaymentService paymentService;

    public PaymentProcessor(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    public void makePayment() {
        paymentService.processPayment();
    }
}
```
**Explanation**:
- The @Primary annotation is used on creditCardPaymentService(), making it the default choice.
- When PaymentProcessor is instantiated, it will receive CreditCardPaymentService by default.

### 2. Using `@Qualifier` Annotation
If you have multiple beans and want to specify a particular one, use the @Qualifier annotation to disambiguate.

#### Example:

```java
@Component
class PaymentProcessor {

    private final PaymentService paymentService;

    public PaymentProcessor(@Qualifier("paypalPaymentService") PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    public void makePayment() {
        paymentService.processPayment();
    }
}

```
**Explanation**:
- The @Qualifier("paypalPaymentService") ensures that the PayPal bean is injected, overriding the default @Primary behavior.

### 3. If No `@Primary` and No `@Qualifier` is Provided
If there are multiple beans of the same type and neither `@Primary` nor `@Qualifier` is used, Spring will throw an exception due to ambiguity.


**Resolution**:
You must resolve this by:

- Adding @Primary to one bean.
- Using @Qualifier to specify the required bean.

### 4. Selecting Beans Dynamically at Runtime
Spring also allows selecting beans dynamically using ApplicationContext or programmatic bean injection.

#### Example:

```java
@Autowired
private ApplicationContext context;

public void processPayment(String type) {
    PaymentService paymentService = (PaymentService) context.getBean(type);
    paymentService.processPayment();
}
```

## Summary

| Approach      | Usage Scenario                                          | Example Usage                                |
|---------------|---------------------------------------------------------|----------------------------------------------|
| `@Primary`    | Default bean selection when no qualifier is provided    | `@Primary` on one bean                       |
| `@Qualifier`  | When you need to explicitly select a specific bean      | `@Qualifier("beanName")` in injection        |
| Manual Lookup | Dynamically selecting beans based on runtime conditions | Using `ApplicationContext` to retrieve beans |

Using `@Primary` and `@Qualifier` wisely ensures better maintainability and flexibility in your Spring applications.


### 12. Compare BeanFactory and ApplicationContext in Spring framework?
In the Spring framework, both `BeanFactory` and `ApplicationContext` are interfaces responsible for managing beans and providing dependency injection. However, they serve different purposes and have key differences in functionality and use cases.

---

### 1. Overview

| Feature              | `BeanFactory`                      | `ApplicationContext`                        |
|----------------------|------------------------------------|---------------------------------------------|
| Definition           | Basic container for managing beans | More advanced container with extra features |
| Initialization       | Lazy initialization (on-demand)    | Eager initialization (on startup)           |
| Functionality        | Basic DI support                   | Full-fledged enterprise features            |
| Event Handling       | Not supported                      | Supports event propagation                  |
| Internationalization | Not supported                      | Supports i18n (message source handling)     |
| AOP Integration      | Requires manual setup              | Integrated support                          |
| Application Layer    | Lower-level, minimal features      | Higher-level, rich features                 |

---

### 2. Key Differences

#### 2.1 Bean Instantiation

- **`BeanFactory` (Lazy Loading)**:  
  Beans are created only when they are requested. This saves memory but might cause a slight delay when the bean is accessed for the first time.

- **`ApplicationContext` (Eager Loading)**:  
  Beans are created during the container startup, making the application ready for use but consuming more memory initially.

---

#### 2.2 Event Handling

- **BeanFactory**: Does not provide an event mechanism to publish and listen to events.

- **ApplicationContext**: Supports built-in event publishing and handling mechanisms, such as `ApplicationListener` for handling events like `ContextRefreshedEvent`.

---

#### 2.3 Internationalization (i18n)

- **BeanFactory**: Lacks support for message sources and internationalization.

- **ApplicationContext**: Provides built-in support for message sources to manage localized messages and internationalization.

---

#### 2.4 AOP and Annotation Support

- **BeanFactory**: Requires manual setup to integrate AOP (Aspect-Oriented Programming) features.

- **ApplicationContext**: Provides seamless integration with AOP and annotation-based features such as `@Autowired`, `@Component`, etc.

---

#### 2.5 Resource Handling

- **BeanFactory**: Limited capabilities to load external resources.

- **ApplicationContext**: Supports resource loading via `ResourceLoader` to read files, URLs, and streams.

---

### 3. Use Cases

| Use Case                                           | Recommended Choice   |
|----------------------------------------------------|----------------------|
| Lightweight applications                           | `BeanFactory`        |
| Large-scale enterprise applications                | `ApplicationContext` |
| Simple dependency injection                        | `BeanFactory`        |
| Event-driven applications                          | `ApplicationContext` |
| AOP and declarative transactions                   | `ApplicationContext` |
| Advanced configurations (Profiles, PropertySource) | `ApplicationContext` |

---

### 4. Code Examples

### Example using `BeanFactory`:

```java
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.ClassPathResource;

BeanFactory factory = new XmlBeanFactory(new ClassPathResource("beans.xml"));
MyBean bean = (MyBean) factory.getBean("myBean");
```

### Example using `ApplicationContext`:

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
MyBean bean = (MyBean) context.getBean("myBean");

```

### 5. Summary
- Use BeanFactory for lightweight applications where minimal functionality is required.
- Use ApplicationContext for full-featured applications with advanced features like event handling, internationalization, and AOP.


### 13. Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.

In Spring, **bean scope** determines how a bean is created, shared, and managed within the IoC container.

### Types of Bean Scopes

| Scope         | Description                                         | Use Case                       |
|---------------|-----------------------------------------------------|--------------------------------|
| `singleton`   | A single shared instance across the application     | Shared services                |
| `prototype`   | A new instance every time it's requested            | Stateless, independent objects |
| `request`     | A new instance per HTTP request (web apps)          | Per-request data handling      |
| `session`     | A new instance per HTTP session (web apps)          | User session-specific data     |
| `application` | A new instance per application lifecycle (web apps) | Shared application resources   |
| `websocket`   | A new instance per WebSocket session (web apps)     | WebSocket communication        |

---

### 1. Singleton Scope (Default)
- **Description:** A single instance shared across the entire application context.
- **Example:**
  ```java
  @Component
  @Scope("singleton")
  public class SingletonBean {
      public SingletonBean() {
          System.out.println("Singleton instance created");
      }
  }
  ```
- Use Case: Shared services like logging, caching.

### 2. Prototype Scope
- **Description:** A new instance created for each request.
- **Example:**
    ```java
    @Component
    @Scope("prototype")
    public class PrototypeBean {
        public PrototypeBean() {
            System.out.println("Prototype instance created");
        }
    }
    ```
- Use Case: Independent, stateless objects.

### 3. Request Scope (Web)
- **Description:** A new instance per HTTP request.
- **Example:**
    ```java
    @Component
    @Scope("request")
    public class RequestBean {
        public RequestBean() {
            System.out.println("Request instance created");
        }
    }
    
    ```
- Use Case: Request-level data handling.

### 4. Session Scope (Web)
- **Description:** A new instance per HTTP session.
- **Example:**
    ```java
    @Component
    @Scope("session")
    public class SessionBean {
        public SessionBean() {
            System.out.println("Session instance created");
        }
    }
    ```
- Use Case: Storing user session data.

### 5. Application Scope (Web)
- **Description:** A single instance for the entire web application.
- **Example:**
    ```java
    @Component
    @Scope("application")
    public class ApplicationBean {
        public ApplicationBean() {
            System.out.println("Application instance created");
        }
    }
    ```
- Use Case: Global configuration or shared resources.

### 6. WebSocket Scope (Web)
- **Description:** A new instance per WebSocket session.
- **Example:**
    ```java
    @Component
    @Scope("websocket")
    public class WebSocketBean {
        public WebSocketBean() {
            System.out.println("WebSocket instance created");
        }
    }
    ```
- Use Case: Managing WebSocket session-specific data.

**Summary**
- Use singleton for shared, immutable objects.
- Use prototype for independent objects.
- Use request/session/application/websocket in web applications for specific needs.


### 14. Explain builder pattern with code examples.

The **Builder Pattern** is a creational design pattern that provides a step-by-step approach to construct complex objects. It helps to create immutable objects with multiple optional parameters while maintaining code readability.

### Benefits of the Builder Pattern
- Improves **readability** by using method chaining.
- Makes objects **immutable** by avoiding setter methods.
- Helps in handling objects with **numerous optional parameters**.

---

### Example Without Builder Pattern (Telescoping Constructor Problem)

```java
public class Car {
    private String engine;
    private int wheels;
    private boolean airConditioning;

    public Car(String engine, int wheels, boolean airConditioning) {
        this.engine = engine;
        this.wheels = wheels;
        this.airConditioning = airConditioning;
    }
}
```
- Problem: If the object has many optional parameters, constructors become hard to manage.

### Solution: Using Builder Pattern

```java
public class Car {
    private final String engine;
    private final int wheels;
    private final boolean airConditioning;

    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.wheels = builder.wheels;
        this.airConditioning = builder.airConditioning;
    }

    public static class CarBuilder {
        private String engine;
        private int wheels;
        private boolean airConditioning;

        public CarBuilder setEngine(String engine) {
            this.engine = engine;
            return this;
        }

        public CarBuilder setWheels(int wheels) {
            this.wheels = wheels;
            return this;
        }

        public CarBuilder setAirConditioning(boolean airConditioning) {
            this.airConditioning = airConditioning;
            return this;
        }

        public Car build() {
            return new Car(this);
        }
    }
}
```

**When to Use**
- When a class has too many parameters.
- When object creation involves complex configuration.
- When immutability is required for thread safety.
