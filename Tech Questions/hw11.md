# HW11
____
### 2. Compare Spring and Springboot? What are the benefits of Springboot?

- **Spring**:
  - Spring is a comprehensive framework that provides support for various enterprise applications.
  - It requires a lot of configuration and setup to get started.
  - It provides a wide range of modules for different functionalities like Spring Core, Spring MVC, Spring Security, etc.
  - It is highly flexible and allows developers to choose the modules they need for their application.

- **Spring Boot**:
    - Spring Boot is an opinionated framework that simplifies the setup and configuration of Spring applications.
    - It reduces the amount of boilerplate code required to set up a Spring application.
    - It provides autoconfiguration, which automatically configures the application based on the dependencies present in the classpath.
    - It includes embedded servers like Tomcat, Jetty, or Undertow, making it easy to deploy standalone applications.

**Benefits of Spring Boot**:
- **Rapid Development**: Spring Boot simplifies the development process by providing defaults for common configurations, reducing the need for manual setup.
- **Microservices**: Spring Boot is well-suited for building microservices due to its lightweight nature and embedded server support.
- **Autoconfiguration**: Spring Boot's autoconfiguration feature automatically configures the application based on the dependencies present in the classpath, reducing the need for manual configuration.
- **Embedded Servers**: Spring Boot includes embedded servers like Tomcat, Jetty, or Undertow, making it easy to deploy standalone applications without the need for external servers.

### 3. What is IOC and What is DI?

- **Inversion of Control (IoC)**:
  - Inversion of Control is a design principle where the control of object creation and lifecycle is inverted from the application code to an external framework or container.
  - In IoC, the framework manages the creation and lifecycle of objects, allowing the application code to focus on business logic.
  - IoC promotes loose coupling between components, making the application more modular and easier to maintain.
- **Dependency Injection (DI)**:
  - Dependency Injection is a design pattern used to implement IoC, where the dependencies of an object are injected into it by an external entity.
  - DI helps in achieving loose coupling between components by removing the responsibility of creating dependencies from the object itself.
  - DI can be implemented using constructor injection, setter injection, or field injection.

### 4. What is @ComponentScan?

@ComponentScan is an annotation used in Spring to specify the packages that should be scanned for components, configurations and services.

### 5. What is @SpringbootApplication?

@SpringBootApplication is a convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan annotations, providing a shortcut to configure a Spring Boot application.

### 6. How many ways to define a bean? Provide code examples.

- @Bean annotation:
```java
@Configurationn
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

- Stereotype annotations:
Like @Component, @Service, @Repository, @Controller to define beans
```java
@Component
public class MyComponent {
    // bean definition
}
```

- XML configuration:
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myService" class="com.example.MyService" />
</beans>
```

- Java-based configuration with @ComponentScan: Using @ComponentScan to scan packages for bean definitions
```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    // bean definitions
}
```

- Factory Methods: Using factory methods to create beans
```java
@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return MyService().createInstance();
    }
}
```

- @Import annotation: Import bean definitions from another configuration class
```java
@Configuration
@Import(AppConfig2.class)
public class AppConfig1 {
    // bean definitions
}
```

### 7. What is default bean name for @Component and @Bean? Also compare @Component and @Bean.

- The default bean name for @Component is the uncapitalized class name, e.g., "myComponent".
- The default bean name for @Bean is the method name, e.g., "myBean".

- **@Component**:
  - @Component is a generic stereotype annotation used to mark a class as a Spring
  - Applied to classes
  - Requires @ComponentScan to detect and register beans
  - Works with other stereotype annotations like @Service, @Repository, @Controller

- **@Bean**:
  - @Bean is a method-level annotation used to define a bean in a configuration class
  - Applied to methods
  - Does not require @ComponentScan, as beans are defined explicitly in the configuration class
  - Independent of stereotypes

### 8. Compare @component and @service, @repository, @controller?

These annotations are specializations of @Component and are functionally equivalent when it comes to registering beans.
- @Component for generic, reusable components
- @Service for services or business logic
- @Repository for data access objects
- @Controller for web controllers and request handling

### 9. Explain @Autowired, @Qualifier, @Resource and @primary?

- @Autowired is a Spring-specific annotation used to automatically wire beans by type.
- @Qualifier is used to specify the bean name when multiple beans of the same type are present.
- @Resource is a Java EE annotation used to inject beans by name.
- @Primary is used to specify the primary bean when multiple beans of the same type are present.

### 10. How many annotations we can use to inject a bean?

- Spring-Specific (@Autowired, @Qualifier, @Primary) are best suited for Spring applications, offering flexibility and additional features.
- JSR-250 Annotations (@Resource) are part of the Java EE specification and can be used in Spring applications for dependency injection.
- JSR-330 Annotations (@Inject, @Named) are part of the Java EE specification and can be used in Spring applications for dependency injection.

### 11. Explain and compare different types of dependency injection, their pros and cons, and use cases.

- **Constructor Injection**:
  - Dependencies are injected through the constructor.
  - Pros: Ensures that all required dependencies are provided at object creation time, making the object immutable.
  - Cons: Can lead to long constructor parameter lists, making the code less readable.
  - Use Case: Best suited for mandatory dependencies that are required for the object to function.
```java
public class MyClass {
    private final Dependency dependency;
    @Autowired
    public MyClass(Dependency dependency) {
        this.dependency = dependency;
    }
}
```

- **Setter Injection**: 
  - Dependencies are injected through setter methods.
  - Pros: Provides flexibility in setting dependencies after object creation, allowing for optional dependencies.
  - Cons: Can lead to objects being in an inconsistent state if not all dependencies are set.
  - Use Case: Suitable for optional dependencies or when the object can function without certain dependencies.
```java
public class MyClass {
    private Dependency dependency;
    @Autowired
    public void setDependency(Dependency dependency) {
        this.dependency = dependency;
    }
}
```

- **Field Injection**: 
  - Dependencies are injected directly into fields.
  - Pros: Simplifies code by reducing the need for boilerplate code.
  - Cons: Violates encapsulation and makes testing more difficult.
  - Use Case: Not recommended due to its drawbacks, but can be used for quick prototyping or in frameworks like Spring where it is supported.
```java
public class MyClass {
    @Autowired
    private Dependency dependency;
}
```

### 12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary, demo with code examples.

- Mark a bean as @Primary: The @Primary annotation tells Spring that a particular bean should be the default when 
multiple beans of the same type are present.
```java
@Component
public class EmailNotification implements NotificationService {
  @Override
  public void notify(String message) {
    System.out.println("Email Notification: " + message);
  }
}

@Component
@Primary
public class SMSNotification implements NotificationService {
  @Override
  public void notify(String message) {
    System.out.println("SMS Notification: " + message);
  }
}

@Component
public class NotificationClient {
  private final NotificationService notificationService;

  @Autowired
  public NotificationClient(NotificationService notificationService) {
    this.notificationService = notificationService;
  }

  public void sendNotification(String message) {
    notificationService.notify(message);
  }
}

// Main Class
@SpringBootApplication
public class Application {
  public static void main(String[] args) {
    ApplicationContext context = SpringApplication.run(Application.class, args);

    NotificationClient client = context.getBean(NotificationClient.class);
    client.sendNotification("Hello, Spring!");
  }
}

// Output: SMS Notification: Hello, Spring!
```

- Use @Qualifier annotation: When there are multiple beans of the same type, you can use the @Qualifier annotation to explicitly 
specify which bean to use
```java
@Component
public class EmailNotification implements NotificationService {
    @Override
    public void notify(String message) {
        System.out.println("Email Notification: " + message);
    }
}

@Component
public class SMSNotification implements NotificationService {
    @Override
    public void notify(String message) {
        System.out.println("SMS Notification: " + message);
    }
}

@Component
public class NotificationClient {
    private final NotificationService notificationService;

    @Autowired
    public NotificationClient(@Qualifier("emailNotification") NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void sendNotification(String message) {
        notificationService.notify(message);
    }
}

// Main Class
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Application.class, args);

        NotificationClient client = context.getBean(NotificationClient.class);
        client.sendNotification("Hello, Spring!");
    }
}

// Output: Email Notification: Hello, Spring!
```

- If no primary or qualifier is specified, Spring will throw an exception when trying to autowire the bean.
```java
@Component
public class EmailNotification implements NotificationService {
    @Override
    public void notify(String message) {
        System.out.println("Email Notification: " + message);
    }
}

@Component
public class SMSNotification implements NotificationService {
    @Override
    public void notify(String message) {
        System.out.println("SMS Notification: " + message);
    }
}

@Component
public class NotificationClient {
    private final NotificationService notificationService;

    @Autowired
    public NotificationClient(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void sendNotification(String message) {
        notificationService.notify(message);
    }
}

// Main Class
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Application.class, args);

        NotificationClient client = context.getBean(NotificationClient.class);
        client.sendNotification("Hello, Spring!");
    }
}

// output: org.springframework.beans.factory.NoUniqueBeanDefinitionException:
//        No qualifying bean of type 'NotificationService' available: expected single matching bean but found 2: emailNotification,smsNotification

```


### 13. Compare BeanFactory and ApplicationContext in Spring framework?

- **BeanFactory**:
  - The basic container interface in Spring that provides the fundamental features of the Spring IoC container.
  - Lazy initialization of beans, meaning beans are created only when requested.
  - Supports different scopes like singleton, prototype, request, session, etc.
  - Provides basic dependency injection features.

- **ApplicationContext**: 
  - Extends the BeanFactory interface and provides additional features.
  - Eager initialization of beans, meaning beans are created at application startup.
  - Supports internationalization, event propagation, resource loading, and more.
  - Provides advanced dependency injection features like autowiring, aspect-oriented programming, etc.

### 14. Explain bean scope in Spring IOC? List bean scopes with explanations and code examples.

- **Singleton**: 
  - Default scope in Spring, where a single instance of the bean is created per container.
  - Example:
```java
@Component
@Scope("singleton")
public class SingletonBean  {
    // bean definition
    public SingletonBean() {
        System.out.println("SingletonBean instance created.");
    }
}

SingletonBean bean1 = context.getBean(SingletonBean.class);
SingletonBean bean2 = context.getBean(SingletonBean.class);
System.out.println(bean1 == bean2); // true (same instance)

```

- **Prototype**: 
  - A new instance of the bean is created every time it is requested.
  - Example:
```java
@Component
@Scope("prototype")
public class PrototypeBean {
  public PrototypeBean() {
    System.out.println("PrototypeBean instance created.");
  }
}

PrototypeBean bean1 = context.getBean(PrototypeBean.class);
PrototypeBean bean2 = context.getBean(PrototypeBean.class);
System.out.println(bean1 == bean2); // false (different instances)

```

- **Request**: A new instance of the bean is created for each HTTP request.
- **Session**: A new instance of the bean is created for each HTTP session.
- **Application**: A single instance of the bean is created for the entire application context.
- **Websocket**: A new instance of the bean is created for each WebSocket session.

### 16. Explain builder pattern with code examples. 

- **Builder Pattern**:
  - A creational design pattern that separates the construction of a complex object from its representation.
  - Allows the creation of an object step by step, providing flexibility and control over the object's construction.
  - Typically used when an object has many optional parameters or when the object's creation process is complex.

```java
public class User {
    private final String firstName;
    private final String lastName;
    private final int age;
    private final String email;

    private User(UserBuilder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.email = builder.email;
    }

    public static class UserBuilder {
        private final String firstName;
        private final String lastName;
        private int age;
        private String email;

        public UserBuilder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder email(String email) {
            this.email = email;
            return this;
        }

        public User build() {
            return new User(this);
        }
    } 
}
```



















