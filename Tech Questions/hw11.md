### hw11 -  spring IOC

#### 1. List all of the annotations you learned from class and homework to annotaitons.md (your own cheatsheet).

#### 2. Compare Spring and Springboot? What are the benfits of Srpingboot?

```
Spring is a framework for building enterprise-grade applications. 
It provides support for various aspects of development, including dependency injection (DI), aspect-oriented programming (AOP), transaction management, and more. 
It is highly flexible and can be used for different types of applications, such as web or batch jobs to messaging systems.

Spring Boot is a module of the Spring framework designed to simplify the setup and configuration process. 
It can reduce the complexity of Spring applications by providing a ready-to-use setup, which includes embedded web servers, auto-configuration, and default setups. 
Spring Boot provides production-ready features, such as metrics, health checks, and externalized configuration.

The benefits of Springboot are:
Auto-Configuration:
Embedded Web Server:
Production-Ready Features:
Quick Setup:
Minimal Configuration:
Opinionated Defaults:
Spring Boot command-line interface (CLI):
Externalized Configuration:
Integration with Cloud Platforms:
Microservices Support:
```

#### 3. What is IOC and What is DI?

```
Inversion of Control (IoC) is a design principle where the control flow of a program is inverted or "inverted" compared to traditional programming. 
Instead of the application code controlling the creation and management of objects, the framework or the container calls the application code.
The Spring IoC container manages the creation, configuration, and lifecycle of objects (beans).
Spring uses configuration (XML, annotations, or Java code) to determine how to inject dependencies.

Dependency Injection (DI)  is a specific technique or pattern used to implement IoC. It is the primary mechanism used by Spring to achieve IoC.
It provides an object with its dependencies.
This is typically done through Constructor injection, Setter injection, and Method injection.
It allows for loose coupling between components.
Dependencies are passed into an object through constructors, setters, or service lookups.
It improves testability by allowing easy substitution of dependencies with mock objects.
It enhances maintainability as changes in dependencies don't require changes in the consumer classes.
```

#### 4. What is @CompnonentScan ?

```
@ComponentScan is an annotation used to scan packages for Spring-managed beans and automatically register them into the Spring IoC container.
What @CompnonentScan does it Automatic Bean Discovery and Bean Registration.
It tells Spring where to search for Spring-managed beans.
It helps Spring detect and manage the beans without explicitly specifying them in a configuration file.
It is used to scan a specified package (or multiple packages) for classes that are marked as Spring beans and register them with the Spring IoC container.
Once a class is found, Spring automatically registers it as a bean in the ApplicationContext. 
```

#### 5. What is @SpringbootApplication ?

```
@SpringBootApplication is a used to define the main class of a Spring Boot application.
It combines @Configuration, @EnableAutoConfiguration, and @ComponentScan into one annotation.
It simplifies the configuration of the Spring context, auto-configures beans based on dependencies, and scans the package for components.
 it serves as the entry point and enables auto-configuration, component scanning, and additional configuration capabilities.
 
```
12am
#### 6. How many ways to define a bean? Provide code examples.

```
There are three main ways to define a Spring bean:

1, XML-based configuration:

<bean id="myBean" class="com.example.MyClass">
    <property name="someProperty" value="someValue"/>
</bean>

2, Java-based configuration using @Bean annotation:

@Configuration
public class AppConfig {
    @Bean
    public MyClass myBean() {
        MyClass bean = new MyClass();
        bean.setSomeProperty("someValue");
        return bean;
    }
}

3, Component scanning with @Component annotation:

@Component
public class MyClass {
    @Value("someValue")
    private String someProperty;
}

 XML configuration is more traditional.
 Java-based configuration offering type safety.
 Component scanning providing automatic detection of beans.

```

#### 7. What is default bean name for @Component  and @Bean ? Also compare @Component  and @Bean .


```
Default bean naming conventions:
For @Component: Takes the class name and converts the first character to lowercase.
Example: A class named "MyService" annotated with @Component will have a default bean name of "myService"14.

For @Bean: Uses the name of the @Bean method as the default bean name5.
Example: A method named "helper()" annotated with @Bean will create a bean named "helper"

@Component is for simple automatic registration of beans, while @Bean provides more control over bean creation

Comparison of @Component and @Bean:

1, Purpose:
@Component is class-level annotation for auto-detecting and auto-configuring beans.
@Bean is method-level annotation for explicitly declaring individual beans.

2, Usage:
@Component is used on classes.
@Bean is used on methods, usually in @Configuration classes.

3, Scope:
@Component is automatically scanned and registered by Spring. 
It can use @Scope, @PostConstruct, @PreDestroy.

@Bean requires manual bean definition but offers more control over instantiation.
It can define scope and lifecycle within the @Bean method

4, Flexibility:
@Component is Simpler to use for straightforward scenarios.
@Bean is well-suited for complex dependencies and conditional bean creation.

5, Control:
@Component provides less explicit control, suitable for default configurations.
@Bean offers fine-grained control over bean instantiation and configuration.
 
6, Typical use cases:
@Component is used for application-specific classes.
@Bean is ideal for integrating third-party classes or when more configuration is needed.
```

#### 8. Compare @component  and @service , @repository , @controller ?

```
1, @Component:
	Generic annotation for any Spring-managed component
	Parent annotation for @Service, @Repository, and @Controller
	Used when a class doesn't fit into a more specific stereotype

2, @Service:
	Indicates that a class belongs to the service layer
	Used for classes that contain business logic
	Functionally equivalent to @Component, but provides better semantics

3, @Repository:
	Used for classes that interact with the database (DAO layer)
	Provides additional benefits like exception translation from persistence-specific exceptions to Spring's DataAccessException hierarchy

4, @Controller:
	Indicates that a class serves as a web controller in Spring MVC.
	Typically used in combination with @RequestMapping for handling web requests.

Their key differences are:
	Functionality: 
		While these annotations can be used interchangeably for component scanning and dependency injection, 
		they provide semantic differences and, in some cases, additional functionality.
		
	Purpose: 
		Each specialized annotation (@Service, @Repository, @Controller) indicates a specific role or layer in the application architecture.
	
	Exception Handling: 
		@Repository provides automatic persistence exception translation.
	
	Framework Integration: 
		@Controller is specifically recognized by Spring MVC for web request handling.
```

#### 9. Explain @Autowired , @Qualifier  , @Resource  and @Primary ?

```
They all are annotations used in Spring for dependency injection and bean management.

@Autowired:
	Used for automatic dependency injection in Spring.
	Can be applied to constructors, methods, and fields.
	Injects dependencies by type.
	If multiple beans of the same type exist, it may cause ambiguity.

@Qualifier:
	Used in conjunction with @Autowired to specify which exact bean should be wired when there are multiple beans of the same type
	Helps resolve ambiguity in autowiring

@Resource:
	A Java EE annotation, also supported by Spring
	Can be used on fields or setter methods
	Performs injection by name first, then by type if name is not found
	Has a 'name' attribute to specify the bean name explicitly

@Primary:
	Used to give higher preference to a bean when multiple beans of the same type are present
	Useful when you want a specific implementation to be the default choice for autowiring

The key differences are:
	@Autowired is Spring-specific, while @Resource is part of Java EE.
	@Autowired injects by type, @Resource injects by name then type.
	@Primary is used to designate a preferred bean among multiple candidates.
	@Qualifier is used with @Autowired to specify which bean to inject when there are multiple options.

```

#### 10. How many annotaitons we can use to inject a bean?

```
There are three main annotations that can be used to inject a bean in Spring:

	@Autowired:
		A Spring-specific annotation used for automatic dependency injection by type.
	
	@Inject: 
		A Java EE standard annotation (JSR-330) that functions similarly to @Autowired.
	
	@Resource: 
		Another Java EE annotation that performs injection primarily by name, then by type if a name is not found.

```

#### 11. Explain and compare differnet types of denpendency injection, their pros and cons, and use cases.

```
There are three main types of dependency injection:
1,Constructor Injection:
		Dependencies are provided through the class constructor
	Pros:
		Ensures dependencies are available immediately after object creation
		Supports immutability
	Cons:
		Can lead to complex constructors with many parameters
	Use cases: 
		When dependencies are required and shouldn't change during the object's lifetime

2, Setter (Property) Injection:
	Dependencies are set through public setter methods
	Pros:
		Allows for more flexibility in changing dependencies
		Easier to add optional dependencies
	Cons:
		Doesn't guarantee all dependencies are set before the object is used
	Use cases: 
		When dependencies are optional or may change during runtime

3, Method Injection:
	Dependencies are provided through method parameters
	Pros:
		Useful for dependencies that are only needed for specific operations
	Cons:
		Can make method signatures more complex
	Use cases: 
		When a dependency is only required for a specific method's execution
```

#### 12. If we have multiple beans for one type, how to set one is primary? and how Spring IOC picks one bean to inject if no primary, demo with code examples.

```
1, On a @Bean method in a @Configuration class:

@Configuration
public class AppConfig {
    @Bean
    @Primary
    public MyService primaryService() {
        return new MyServiceImpl1();
    }

    @Bean
    public MyService secondaryService() {
        return new MyServiceImpl2();
    }
}


2, Directly on a @Component class:

@Primary
@Component
public class PrimaryServiceImpl implements MyService {
    // Implementation
}

@Component
public class SecondaryServiceImpl implements MyService {
    // Implementation
}




```

#### 13. Compare BeanFactory and ApplicationContext in Spring framework?

```
BeanFactory and ApplicationContext are both core container interfaces in the Spring framework, 
but ApplicationContext is more feature-rich and commonly used. 

Here's a comparison:

1, Functionality:
	BeanFactory: Provides basic IoC and DI features
	ApplicationContext: Offers advanced features in addition to BeanFactory capabilities

2, Bean Initialization:
	BeanFactory: Lazy loading - creates beans on-demand
	ApplicationContext: Eager loading - creates singleton beans at startup

3, Annotation Support:
	BeanFactory: Does not support annotation-based configuration
	ApplicationContext: Supports annotations for bean configuration
4, Additional Features:
	BeanFactory: Limited to core container functionality
	ApplicationContext: Supports internationalization, event publishing, and AOP features
5, Bean Scopes:
	BeanFactory: Supports only singleton and prototype scopes
	ApplicationContext: Supports all bean scopes, including request and session
6, Post-Processor Registration:
	BeanFactory: Requires manual registration of BeanPostProcessors
	ApplicationContext: Automatically registers BeanPostProcessors
7, Usage:
	BeanFactory: Suitable for resource-constrained environments
	ApplicationContext: Recommended for most applications, especially enterprise-level
8, Interface Hierarchy:
	BeanFactory: Root interface for accessing the Spring container
	ApplicationContext: Extends BeanFactory, providing a superset of its functionality

Usually, ApplicationContext is preferred due to its richer feature set and more declarative approach for complex, enterprise-level applications

```

#### 14. Explain bean scope in Spring IOC? List bean scopes with explainations and code examples if possible.

```
Spring Framework supports six bean scopes:
1, Singleton (Default):	
	Only one instance of the bean is created per Spring IoC container.
	Used for stateless beans.
	
	@Bean
	@Scope("singleton")
	public MyBean singletonBean() {
		return new MyBean();
	}

	
2, Prototype:

	A new instance is created each time the bean is requested.
	Suitable for stateful beans.
	
	@Bean
	@Scope("prototype")
	public MyBean prototypeBean() {
		return new MyBean();
	}

3,  Request:
	A single instance per HTTP request.
	Only valid in web-aware Spring ApplicationContext.
	
	@Bean
	@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
	public MyBean requestBean() {
		return new MyBean();
	}

4, Session:
	A single instance per HTTP session.
	Only valid in web-aware Spring ApplicationContext.
	
	@Bean
	@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
	public MyBean sessionBean() {
		return new MyBean();
	}

5, Application:
	A single instance per ServletContext lifecycle.
	Only valid in web-aware Spring ApplicationContext.
	
	@Bean
	@Scope(WebApplicationContext.SCOPE_APPLICATION)
	public MyBean applicationBean() {
		return new MyBean();
	}

6, Websocket:
	A single instance per WebSocket session.
	Only valid in web-aware Spring ApplicationContext.
	
	@Bean
	@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
	public MyBean websocketBean() {
		return new MyBean();
	}

These scopes allow us to control the lifecycle and visibility of beans, 
optimizing resource usage and ensuring proper state management in different application contexts
```

#### ``` 15. Write a Spring application that registers and autowires beans,	
	- Demo different types of dependency injection	
	- Demo bean scopes.	
	- Demo dependency injection by type and by name, when there's ambiguity in bean definition.	
	- Demo bean registration by both @Component and @Bean
```
See See Coding/hw11/hw11Q15demo/src/main/java/com/example/hw11Q15demo/

1, Demo different types of dependency injection	
It demonstrates three types of dependency injection:
Constructor Injection
Setter Injection
Field Injection

2, Demo bean scopes.	
Make sure this is dependency in pom.xml:
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>

See Coding/hw11/hw11Q15demo/src/main/java/com/example/hw11Q15demo/beanscopes

Singleton scope (default): The same instance is used across the entire application.
Prototype scope: A new instance is created each time the bean is requested.
Request scope: A new instance is created for each HTTP request.
Session scope: A new instance is created for each HTTP session.

3, Demo dependency injection by type and by name, when there's ambiguity in bean definition.

ambiguousGreeting will cause an ambiguity error because there are two beans of type Greeting.
formalGreeting resolves the ambiguity by name
qualifiedGreeting resolves the ambiguity using the @Qualifier annotation.

4, Demo bean registration by both @Component and @Bean
	ComponentService is automatically detected and registered as a bean by Spring's component scanning,
	because it's annotated with @Component.
	BeanService is manually registered as a bean in the HelloWorldApplication class using the @Bean annotation.
	Both services are injected into the BeanRegistrationDemoController using constructor injection.
	
	There are two common ways of registering beans in a Spring application:
	(1)Using @Component, or @Service, @Repository, etc. for automatic detection and registration.
	(2)Using @Bean in @Configuration classes for manual, more controlled bean registration, when more complex instantiation logic is needed.
```

#### 16. Explain builder pattern with code examples.

```
The Builder pattern is a creational design pattern that separates the construction of an object from its representation.

Key components of the Builder pattern:
	Builder: 
		An interface defining steps to build parts of the product.
	ConcreteBuilder: 
		Implements the Builder interface to construct and assemble parts of the product.
	Director: 
		Controls the building process using the Builder interface.
	Product: 
		The complex object being built.

// Product
class Computer {
    private String cpu;
    private String ram;
    private String storage;

    public void setSpecs(String cpu, String ram, String storage) {
        this.cpu = cpu;
        this.ram = ram;
        this.storage = storage;
    }

    public void displayInfo() {
        System.out.println("Computer Specs: CPU - " + cpu + ", RAM - " + ram + ", Storage - " + storage);
    }
}

// Builder interface
interface ComputerBuilder {
    void buildCPU();
    void buildRAM();
    void buildStorage();
    Computer getResult();
}

// ConcreteBuilder
class GamingComputerBuilder implements ComputerBuilder {
    private Computer computer = new Computer();

    public void buildCPU() {
        computer.setSpecs("Gaming CPU", null, null);
    }

    public void buildRAM() {
        computer.setSpecs(null, "16GB DDR4", null);
    }

    public void buildStorage() {
        computer.setSpecs(null, null, "1TB SSD");
    }

    public Computer getResult() {
        return computer;
    }
}

// Director
class ComputerDirector {
    public void construct(ComputerBuilder builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
    }
}

// Client usage
public class BuilderExample {
    public static void main(String[] args) {
        ComputerBuilder gamingBuilder = new GamingComputerBuilder();
        ComputerDirector director = new ComputerDirector();

        director.construct(gamingBuilder);
        Computer gamingComputer = gamingBuilder.getResult();
        gamingComputer.displayInfo();
    }
}

The Builder pattern is particularly useful when:
	Creating objects with many optional components or configurations.
	Constructing objects step-by-step, allowing different configurations at different stages.
	Avoiding constructors with multiple parameters, which can be error-prone.
	Providing a common interface for constructing different representations of an object.
```

#### 17. Clone https://github.com/CTYue/springIOC, go through examples, make code in both main and main-loosecoupling work.

```
 1, @Primary is duplicated in HibernateChuwa.java or BeanConfig.java.
	Keep one only.
 2, resource/bean.xml and resource/bean2.xml have duplicate bean id. 
```