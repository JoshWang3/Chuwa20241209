# Homework 18

# 3. Compare let vs var , explain variable hosting with your own code examples.
## **`let`**
- Block-scoped.
- Not initialized until declaration (Temporal Dead Zone).
- No redeclaration in same scope.

## **`var`**
- Function-scoped.
- Hoisted and initialized as `undefined`.
- Allows redeclaration.

---

## Hoisting Examples

```javascript
// var: hoisted with 'undefined'
console.log(x); // undefined
var x = 10;

// let: hoisted but not initialized
console.log(y); // ReferenceError
let y = 20;
```

## Scope Examples
```javascript
// var leaks outside blocks
if (true) {
  var a = 5;
}
console.log(a); // 5

// let is block-scoped
if (true) {
  let b = 5;
}
console.log(b); // ReferenceError
```


# 4. Explain closure with code example
A function that remembers its lexical scope even when executed outside it.

```javascript
function outer() {
  const secret = "🕵️";
  
  return function inner() {
    console.log(secret); // Accesses outer scope's variable
  };
}

const reveal = outer();
reveal(); // "🕵️" (still remembers 'secret')
```

# 5. Explain Callback Hell with code example
Nested callbacks making code hard to read/maintain:

```javascript
getData(function(a) {
  processA(a, function(b) {
    processB(b, function(c) {
      processC(c, function(d) {
        // ...deeper nesting
      });
    });
  });
});
```
Problems:

   - Hard to follow flow

   - Error handling becomes messy

   - Tight coupling

# 6. Explain Promise , Async , Await with code examples.
## **Promise**
Handles async operations with states (`pending`, `fulfilled`, `rejected`):

```javascript
const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => resolve("🍕"), 1000);
});

fetchData
  .then(data => console.log(data)) // "🍕" after 1s
  .catch(err => console.error(err));
```


## Async/Await (Syntactic sugar for Promises)
```javascript
async function getData() {
  try {
    const result = await fetchData; // Wait for Promise
    console.log(result); // "🍕"
  } catch (err) {
    console.error(err);
  }
}
```
Key benefits:
   - Flatter code vs callback hell

   - Error handling with try/catch

   - async functions always return Promises


# 9. Explain how Javascript implement asynchronous non-blocking feature
1. Particularly: Event Loop, Macrotask, and Microtask with code samples.
**Event Loop**: Manages async operations with:
- **Call Stack**: Executes synchronous code
- **Task Queues**: Holds async callbacks

## **Macrotasks** (lower priority)
- `setTimeout`, `setInterval`, I/O
- Rendered in *separate queue*

## **Microtasks** (higher priority)
- `Promise.then`, `queueMicrotask`, `MutationObserver`
- Processed *immediately after current task*

---

## Execution Order Demo
```javascript
console.log("Start"); // 1. Sync

setTimeout(() => console.log("Timeout (Macro)"), 0); // 4. Macro

Promise.resolve()
  .then(() => console.log("Promise (Micro)")); // 3. Micro

console.log("End"); // 2. Sync
```

Flow:

1. Execute all sync code (macrotask)

2. Drain entire microtask queue

3. Run one macrotask from queue

4. Repeat
















