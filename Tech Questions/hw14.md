\3. What is the Aspect Oriented Programming, explain it with detailed use cases?  

```
programming paradigm that allows separation of concerns;
provides a way to apply additional behavior to methods without modifying their actual code;
modularizes concerns like logging, security, and transaction management.

Logging: Automatically log method calls and parameters.
Transaction Management: Apply transactions to business methods without modifying the method code.
Security: Enforce security checks before executing methods.
```

\4. What are the advantages and disadvantages of Spring AOP?  

```
Advantages:
1. separating cross-cutting concerns like logging, security to allow cleaner code
2. improve code reusability and maintainability
3. non-intrusive ways to apply behaviors to classes or methods.
Disadvantages:
Adds complexity, a slight performance penalty due to proxying and additional logic.
```

\5. Explain following concept , include code snippet   

```java
//1. Aspect encapsulates cross-cutting concerns, like logging, security, or transaction management.
@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.*.*(..))")
    public void logMethodCall(JoinPoint joinPoint) {
        System.out.println("Method called: " + joinPoint.getSignature().getName());
    }
}

//2. PointCut defines the criteria for where advice should be applied (e.g., which methods to intercept).
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {}

//3. JoinPoint - a specific point during the execution of a program, such as method invocation. 
@Before("execution(* com.example.*.*(..))")
public void logMethodCall(JoinPoint joinPoint) {
    System.out.println("Method called: " + joinPoint.getSignature().getName());
}

//4. Advice is the action taken at a particular JoinPoint, e.g., logging, transaction management. It defines what to do before, after, or around a method execution
@Before("execution(* com.example.*.*(..))")
public void beforeMethod(JoinPoint joinPoint) {
    System.out.println("Before method: " + joinPoint.getSignature().getName());
}

```

\6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some
expressions to do it.  

```java
Yes, A Pointcut can be declared without annotating an empty method by using Pointcut expressions directly in the advice method.

@Aspect
@Component
public class MyAspect {

    @Before("execution(* com.example.service.*.*(..))")  // Pointcut directly in @Before
    public void logBefore() {
        System.out.println("Before method execution");
    }
}

"within(com.example.service.UserService)": Matches all methods within the UserService class.
@annotation(org.springframework.transaction.annotation.Transactional): Matches methods annotated with @Transactional
```

\7. Compare different types of advices in Spring AOP.  

```java
@Before: Executes before the method execution.
@After: Executes after the method execution, regardless of success or failure.
@AfterReturning: Executes after the method execution only if it completes successfully (no exceptions).
@AfterThrowing: Executes after the method execution if an exception is thrown.
@Around: Executes before and after the method execution, allows modification of the method's return value or exception.
@Around("execution(* com.example.service.*.*(..))")
public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
    System.out.println("Before method execution");
    Object result = joinPoint.proceed();  // Proceed with method execution
    System.out.println("After method execution");
    return result;
}

```



