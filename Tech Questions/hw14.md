### 1. List all of the annotations you learned from class and homework to annotaitons.md

### 2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions

### 3. What is the Aspect Oriented Programming, explain it with detailed use cases?

---

### What is AOP?

**Aspect-Oriented Programming (AOP)** is a programming approach that complements Object-Oriented Programming (OOP) by introducing **"aspects"**—modular units that encapsulate **crosscutting concerns**.

While OOP focuses on separating functionality into classes, AOP helps separate concerns that affect multiple classes, such as logging, security, and transaction management. This improves modularity and reduces code duplication.

---

### How It Works:

- **Aspect**: A class containing logic that applies across the app (e.g., audit logging).
- **Advice**: The actual code to run (before, after, or around a method).
- **Pointcut**: Defines which methods or classes the aspect applies to.
- **Weaving**: Linking aspects to code, done at runtime (Spring AOP) or compile time (AspectJ).

---

### Example Use Cases:

1. **Audit Logging (Most Common Use Case)**

   - Annotate business methods like `@Audit`.
   - A logging aspect captures who performed what action and when, without touching business logic.

2. **JMX Auto-Registration**

   - Define a custom annotation like `@AutoRegister`.
   - Aspect watches for new instances and auto-registers them with JMX for remote management.

3. **Security Checks**

   - Annotate methods with `@AdminOnly`.
   - Aspect ensures only admin users can execute those methods.

4. **Transaction Management**
   - Spring's `@Transactional` uses AOP to begin and commit/rollback transactions around DB calls.

---

### 4. What are the advantages and disadvantages of Spring AOP?

### Advantages:

1. **Modularity**

   - Separates cross-cutting concerns (like logging, security, and transactions) from core business logic, keeping code cleaner and easier to maintain.

2. **Reduces Code Duplication**

   - Common behavior can be written once in an aspect and reused across multiple methods.

3. **Tight Spring Integration**

   - Works seamlessly with Spring’s configuration, dependency injection, and annotations.

4. **Easy to Use**
   - Uses simple annotations and conventions; no special compiler or tools needed.

---

### Disadvantages:

1. **Limited Join Point Support**

   - Spring AOP only supports method-level join points (no field or constructor level), unlike AspectJ.

2. **Harder to Debug**

   - Since behavior is injected at runtime via proxies, it can be harder to trace and debug what’s actually happening during execution.

3. **Runtime Overhead**
   - Extra processing (proxy creation and method interception) can slightly impact performance, especially if overused.

---

### 5. Explain following concept in your own words, you may include code snippet as part of your answer.

#### 1. Aspect

An **aspect** is a class that contains logic for a cross-cutting concern, such as logging or security, that you want to apply across multiple places in your application. It is the core concept in AOP that groups reusable behavior.

```java
@Aspect
@Component
public class LoggingAspect {
    // This is an aspect
}
```

---

#### 2. PointCut

A **pointcut** is an expression that defines **where** the aspect’s logic (advice) should run. It matches specific join points, like methods in certain packages or with specific annotations.

```java
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {}
```

---

#### 3. JoinPoint

A **join point** is a specific spot during program execution, such as when a method is called or an exception is thrown. Advice is applied at these points.

```java
@Before("serviceMethods()")
public void logMethodCall(JoinPoint joinPoint) {
    System.out.println("Calling: " + joinPoint.getSignature().getName());
}
```

---

#### 4. Advice

**Advice** is the actual action that runs when a pointcut is matched. It defines **what** to do (e.g., log, check security) and **when** to do it (e.g., before or after a method).

Types of advice:

- `@Before` – runs before the method
- `@After` – runs after the method
- `@Around` – runs before and after the method

```java
@After("serviceMethods()")
public void logAfter() {
    System.out.println("Method finished.");
}
```

---

### 6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.

### Declaring a Pointcut:

You typically declare a pointcut using the `@Pointcut` annotation on an empty method to define a reusable expression.

```java
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {} // no implementation needed
```

You can then refer to this pointcut in your advice:

```java
@Before("serviceMethods()")
public void logBefore() {
    System.out.println("Service method called");
}
```

### Can You Declare a Pointcut Without an Empty Method?

Yes, you can **inline the pointcut expression** directly inside your advice annotation without using a separate method.

```java
@AfterReturning("execution(* com.example.controller.*.*(..))")
public void afterControllerCall() {
    System.out.println("Controller method completed");
}
```

Using named pointcut methods is preferred for **reuse and readability**.

---

### 7. Compare different types of advices in Spring AOP.

### 1. `@Before`

- Runs **before** the target method.
- Used for tasks like logging, security checks, or input validation.

### 2. `@After`

- Runs **after** the target method (whether it completes normally or throws an exception).

### 3. `@AfterReturning`

- Runs **after a method returns successfully** (no exception).
- Can access the return value.

### 4. `@AfterThrowing`

- Runs **if the method throws an exception**.
- Used for error logging or custom exception handling.

### 5. `@Around`

- Wraps the method execution.
- Can run **before and after**, and also **control execution** (e.g., modify input/output or prevent method from running).

### 8. On top of your Spring application which you did in Assignment #11,

#### 1. Implement a customized logger using Spring AOP, your logger should be able to log your code and also external code.

#### 2. Your AOP logger should log method execution time, Rest API request details and response details.

#### 3. Your AOP logger should log with all possible joint points (before method execution, after method execution etc...)

#### 4. Your should bind jointPoints with your AOP code directly, instead of binding it with an empty method.

#### 5. Be ready to demo your implementation and prove it works in class.
