
### hw14 - AOP

#### 1. List all of the annotations you learned from class and homework to annotaitons.md

#### 2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions
```
20 questions

```
#### 3. What is the Aspect Oriented Programming, explain it with detailed use cases?

```

Key Concepts of AOP
	Aspect: A modularization of a concern that cuts across multiple classes.
	Join Point: A point during the execution of a program, such as method execution.
	Advice: Action taken by an aspect at a particular join point.
	Pointcut: A predicate that matches join points.

Use Cases of AOP are:

1, Logging:
	@Aspect
	public class LoggingAspect {
		@Before("execution(* com.example.service.*.*(..))")
		public void logMethodEntry(JoinPoint joinPoint) {
			Logger.info("Entering method: " + joinPoint.getSignature().getName());
		}
	}	
	This aspect logs the entry of all methods in the service package.
	
2, Security and Access Control:

	@Aspect
	public class SecurityAspect {
		@Before("execution(* com.example.sensitive.*.*(..))")
		public void checkAuthorization(JoinPoint joinPoint) {
			// Perform authorization check
			if (!SecurityContext.isAuthorized()) {
				throw new UnauthorizedException();
			}
		}
	}
	This aspect checks authorization before executing any method in the sensitive package.

3, Transaction Management:

	@Aspect
	public class TransactionAspect {
		@Around("@annotation(Transactional)")
		public Object manageTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
			TransactionManager.begin();
			try {
				Object result = joinPoint.proceed();
				TransactionManager.commit();
				return result;
			} catch (Exception e) {
				TransactionManager.rollback();
				throw e;
			}
		}
	}

4, Performance Monitoring and Profiling

@Aspect
public class ProfilingAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object profile(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long elapsedTime = System.currentTimeMillis() - start;
        Logger.info(joinPoint.getSignature() + " executed in " + elapsedTime + " ms");
        return result;
    }
}

5, Exception Handling and Wrapping

@Aspect
public class ExceptionHandlingAspect {
    @AfterThrowing(pointcut = "execution(* com.example.dao.*.*(..))", throwing = "ex")
    public void wrapException(JoinPoint joinPoint, SQLException ex) throws DAOException {
        throw new DAOException("Database error in " + joinPoint.getSignature(), ex);
    }
}
```

#### 4. What are the advantages and disadvantages of Spring AOP?

```
Advantages
	Modularity: 
		Separates cross-cutting concerns like logging, security, and transaction management from core business logic1.
	Cleaner code: 
		Reduces code duplication and improves maintainability.
	Centralized management: 
		Makes it easier to maintain and modify aspects in one place.
	Flexibility: 
		Supports both schema-based (XML) and annotation-based configurations.
	Integration: 
		Works seamlessly with the Spring framework

Disadvantages
	Limited scope: 
		Only applies to Spring-managed beans and public methods.
	Proxy-based limitations: 
		Cannot intercept internal method calls within the same bean.
	Performance overhead: 
		Small runtime overhead, though generally negligible.
	Debugging challenges: 
		Can make debugging more difficult due to the added layer of abstraction.
	Learning curve: 
		Requires understanding of AOP concepts. It can be complex for newcomers.
	Potential for misuse: 
		Improper use can lead to scattered code and reduced transparency.
	Limited to method-level advising: 
		Does not support field-level interception

```

#### 5. Explain following concept in your own words, you may include code snippet as part of your answer.
	1. Aspect
	2. PointCut
	3. JoinPoint
	4. Advice

```
1, Aspect
An aspect is a modular unit that encapsulates cross-cutting concerns in an application.
It's like a special class that contains advice and pointcuts.

@Aspect
public class LoggingAspect {
    // Advice and pointcuts go here
}

2, Pointcut
A pointcut is an expression that defines where in the code an aspect should be applied.
It's like a filter that selects specific join points. 

@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {}

The pointcut selects all methods in the com.example.service package.

3, Join Point
A join point is a specific point in the execution of a program where an aspect can be applied.
In Spring AOP, join points are always method executions.

4, Advice
Advice is the action taken by an aspect at a particular join point. 
It's the actual code that gets executed. There are several types of advice:

@Before("serviceMethods()")
public void logBeforeMethod(JoinPoint joinPoint) {
    // Code to execute before the method
}

@After("serviceMethods()")
public void logAfterMethod(JoinPoint joinPoint) {
    // Code to execute after the method
}

@Around("serviceMethods()")
public Object logAroundMethod(ProceedingJoinPoint joinPoint) throws Throwable {
    // Code to execute before and after the method
    Object result = joinPoint.proceed();
    return result;
}
```

#### 6. How do we declare a pointcut, can we declare it without annotating an empty method? Name some expressions to do it.

```
1, Using @Pointcut annotation on a method:

@Pointcut("execution(* com.example.service.*.*(..))")
private void serviceLayerMethods() {}

2, Directly in advice annotations:

@Before("execution(* com.example.service.*.*(..))")
public void beforeServiceMethods(JoinPoint joinPoint) {

}

Some common pointcut expressions include:
	Execution of any public method:
		"execution(public * *(..))"
	Execution of methods with names starting with "get":
		"execution(* get*(..))"
	Execution of any method in a specific package:
		"execution(* com.example.service..(..))"
	Execution of methods annotated with @Transactional:
		"@annotation(org.springframework.transaction.annotation.Transactional)"
	Execution of methods in beans with names ending in 'Service':
		"bean(*Service)"
These expressions can be combined using logical operators like && (and), || (or), and ! (not) for more complex pointcut definitions.
```

#### 7. Compare different types of advices in Spring AOP.

```

Here's a comparison of the main advice types:
1,Before Advice:
	Executed before the target method
	Useful for preprocessing, validation, or logging
	Cannot prevent the target method from executing (unless it throws an exception)

2, After Returning Advice:
	Executed after the target method successfully returns
	Can access the method's return value
	Useful for post-processing or additional operations based on the result
	After Throwing Advice:
	Executed if the target method throws an exception
	Can access the thrown exception
	Useful for exception handling, logging, or cleanup operations
3, After (Finally) Advice:
	Executed after the target method, regardless of its outcome, normal return or exception
	Cannot access the return value or thrown exception
	Useful for cleanup operations that should always occur

4, Around Advice:
	Most powerful type of advice
	Surrounds the target method execution
	Can perform actions before and after the method invocation
	Has control over whether the target method is executed
	Can modify the return value or handle exceptions

Comparison:
	Flexibility: 
		Around advice offers the most flexibility, while Before and After advices are more specific and limited in scope.
	Performance: 
		Before and After advices generally have less overhead compared to Around advice.
	Simplicity: 
		Before and After advices are simpler to implement and understand, while Around advice requires more careful handling.
	Use cases: 
		Choose the advice type that best fits your specific requirements to maintain code simplicity and performance.

```

#### 8. On top of your Spring application which you did in Assignment #11,
1. Implement a customized logger using Spring AOP, your logger should be able to log your code and
also external code.
2. Your AOP logger should log method execution time, Rest API request details and response details.
3. Your AOP logger should log with all possible joint points (before method execution, after method
execution etc...)
4. Your should bind jointPoints with your AOP code directly, instead of binding it with an empty
method.
5. Be ready to demo your implementation and prove it works in class.
```
See Coding/hw14/helloWorldAOP:

1, com.external.externalMethod() is called

2, execution time, rest api request, and response details are shown

3, 
logBefore()
logAfter()
logAfterReturning()

logs are shown

4,

	
```