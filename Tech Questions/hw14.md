# Homework 14
## Spring AOP 

### 1. List all of the annotations you learned from class and homework to annotaitons.md
- see annotations.md

### 2. Briefly reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions

### 3. What is the Aspect Oriented Programming, explain it with detailed use cases?
- **Aspect-Oriented Programming (AOP):** a programming paradigm that **aims to increase modularity** by allowing the **separation of cross-cutting concerns**. It does this by adding additional behavior to existing code without modifying the code itself. Instead, we can declare the new code and the new behaviors separately.
- Use cases are: Logging, Security, Error handling, Caching, Transaction management, Data validation, and Localization etc.

### 4. What are the advantages and disadvantages of Spring AOP?
- Spring AOP (Aspect-Oriented Programming) is a powerful feature in the Spring Framework that allows developers to modularize cross-cutting concerns, such as logging, security, and transaction management, into aspects. While it provides significant benefits, it also has its limitations.
- Advantages of Spring AOP
1. **Modularity**: Cross-cutting concerns like logging, security, and transaction management can be encapsulated in separate aspects, making the codebase cleaner.
2. **Reusability**: Common functionalities encapsulated in aspects can be reused across multiple modules or components, reducing redundancy.
3. **Ease of Maintenance**: Since aspects centralize cross-cutting concerns, making changes to these concerns is easier and doesn’t require updating multiple classes. 
4. **Declarative Programming Style**: Spring AOP provides a declarative approach to applying aspects using annotations (`@Aspect`) or XML configuration, making it easy to specify which parts of the application should be affected.
5. **Runtime Flexibility**: Spring AOP operates at runtime, allowing developers to apply aspects dynamically. It is implemented in pure Java, so separate compilation unit or separate class loader are not required.

- Disadvantages of Spring AOP
1. **Limited to Proxies**: Spring AOP is proxy-based and operates only on Spring-managed beans. It doesn’t support non-bean objects or static methods.
2. **Complex Debugging**: Since the behavior of an application is altered by aspects, debugging can become challenging. 
3. **Not Full AOP Solutions**: Spring AOP only supports method-level weaving and is not a full AOP solution. For more advanced features like field-level interception or compile-time weaving, we would need a library like AspectJ.
4. **Performance Overhead**: The use of proxies and runtime weaving can introduce a slight performance overhead, especially when there are many aspects or pointcuts.

### 5. Explain following concept in your own words, you may include code snippet as part of your answer.
1. Aspect: a **modularization** of a concern (as a class) that cuts across multiple classes. 
2. PointCut: a **predicate** that helps match an *Advice* to be applied by an *Aspect* at a particular *JoinPoint*. (**A pointcut defines at what joinpoints, the associated Advice should be applied, or simply, a regular expression that matches join points**) *Advice* is often associated with a *Pointcut* expression, and it runs at any *Joinpoint* matched by the *Pointcut*.
3. JoinPoint: a **point during the execution of a program** where an aspect can be plugged in, such as the execution of a method, the handling of an exception, or even a field being modified. (In Spring AOP, a *JoinPoint* always represents a method execution.)
4. Advice: an **action** taken by an aspect at a particular *Joinpoint*. This is an object which includes API invocations to the system wide concerns representing the action to perform at a joinpoint specified by a point. Different types of advice include *“around,” “before,”* and *“after.”* (In Spring, an *Advice* is modelled as an interceptor, maintaining a chain of interceptors around the *Joinpoint*.)

### 6. How do we declare a pointcut, can we? Name some expressions to do it.
- We can declare a pointcut in Spring AOP using the `@Pointcut` annotation, and it is usually associated with a method that contains no implementation (an empty method). It encapsulates the **join point** expressions (e.g., method execution) so they can be reused across multiple advices. A pointcut is typically declared in an aspect class and can be used in combination with advices like `@Before`, `@After`, or `@Around`.

- Although we can use inline pointcuts to declare a pointcut without annotating an empty method , we **cannot declare a reusable pointcut** without associating it with a method. The empty method serves as a logical placeholder to name and reuse the pointcut. While we can inline pointcut expressions directly in advice annotations (e.g., `@Before` or `@Around`), doing so can lead to duplication and reduce maintainability.

```java
// Example of a standard pointcut*:
@Pointcut("execution(* com.example.service.*.*(..))")
public void allServiceMethods() {
    // Pointcut definition, no implementation required
}

@Before("allServiceMethods()")
public void logBeforeMethod(JoinPoint joinPoint) {
    System.out.println("Before executing: " + joinPoint.getSignature().getName());
}

// Example of an inline pointcut:
@Before("execution(* com.example.service.*.*(..))")
public void logBeforeInline(JoinPoint joinPoint) {
    System.out.println("Before executing: " + joinPoint.getSignature().getName());
}
```
- Common Pointcut Expressions
1. **Execution Expression**: Matches method executions.
   - Syntax: `execution(modifiers-pattern? return-type-pattern declaring-type-pattern? method-name-pattern(param-pattern) throws-pattern?)`
   - Examples:
     - `execution(* com.example.service.*.*(..))`: Matches all methods in classes under the `com.example.service` package.
     - `execution(public * *(..))`: Matches all public methods.
2. **Within Expression**: Matches methods within a specified type or package.
   - Syntax: `within(package-name..class-name)`
   - Examples:
     - `within(com.example.service..*)`: Matches all classes under the `com.example.service` package and its sub-packages.
     - `within(com.example.service.SomeClass)`: Matches all methods in the `SomeClass` class.
3. **This Expression**: Matches methods where the proxy object is an instance of the specified type.
   - Syntax: `this(type)`
   - Example: `this(com.example.service.MyService)`.
4. **Target Expression**: Matches methods where the target object (not the proxy) is an instance of the specified type.
   - Syntax: `target(type)`
   - Example: `target(com.example.service.MyService)`.
5. **Args Expression**: Matches methods based on the runtime arguments of the method.
   - Syntax: `args(argument-types)`
   - Example: `args(java.lang.String, int)` matches methods that take a `String` and an `int` as parameters.
6. **Annotation-Based Expressions**: Matches methods or classes annotated with a specific annotation.
   - Examples:
     - `@annotation(com.example.MyAnnotation)`: Matches methods annotated with `@MyAnnotation`.
     - `@within(com.example.MyAnnotation)`: Matches all methods within classes annotated with `@MyAnnotation`.
7. **Combining Expressions**: We can combine multiple pointcut expressions using logical operators like `&&`, `||`, and `!`.
   - Example:  
     ```java
     @Pointcut("execution(* com.example.service.*.*(..)) && @annotation(com.example.MyAnnotation)")
     public void annotatedServiceMethods() {}
     ```

### 7. Compare different types of advices in Spring AOP.
| **Key Annotation** | **Execution Timing**                                         | **Characteristics**                                          |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `@Before`          | Before the target method runs                                | Does not interfere with the method execution or return value. Useful for pre-processing logic, such as logging, authentication, or validation before method execution |
| `@After`           | Always runs after the method completes, regardless of success or failure | Useful for post-processing logic such as cleanup or auditing tasks |
| `@AfterReturning`  | Runs after a method successfully completes and returns a value | Can access and modify the return value for post-processing logic that requires the return value (e.g., modifying or logging the result) |
| `@AfterThrowing`   | Runs only when the method throws an exception                | Useful for error logging or handling, such as logging exceptions, notifying users, or rolling back a transaction |
| `@Around`          | Runs before and after the method, with the ability to control whether the method executes | Provides the most flexibility, as it can decide to proceed with the method execution or modify its arguments/return value, but can be overkill for simple tasks. Often used for performance monitoring, implementing custom behavior, caching, or modifying method execution behavior |

### 8. On top of your Spring application which you did in Assignment #11,
#### 1. Implement a customized logger using Spring AOP, your logger should be able to log your code and also external code.
#### 2. Your AOP logger should log method execution time, Rest API request details and response details.
#### 3. Your AOP logger should log with all possible joint points (before method execution, after method execution etc...)
#### 4. Your should bind jointPoints with your AOP code directly, instead of binding it with an empty method.
#### 5. Be ready to demo your implementation and prove it works in class
- See Projects/hw14
- See Screenshots/hw14