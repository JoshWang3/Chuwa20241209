### HW12 - Spring-MVC

#### 1. List all of the annotations you learned from this class session.

#### 2. Explain circular dependencies scenario in dependency injection with your code, how do we resolve it?

```
When two or more beans depend on each other, Circular dependencies occur.

@Component
public class BeanA {
    private BeanB beanB;

    @Autowired
    public BeanA(BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {
    private BeanA beanA;

    @Autowired
    public BeanB(BeanA beanA) {
        this.beanA = beanA;
    }
}

BeanA depends on BeanB, and BeanB depends on BeanA, creating a circular dependency.
There are several approaches to solve it:

1, Use setter injection instead of constructor injection:

@Component
public class BeanA {
    private BeanB beanB;

    @Autowired
    public void setBeanB(BeanB beanB) {
        this.beanB = beanB;
    }
}
This can resolve the circular reference as Spring can finish initializing both objects after they are created.

2, Use @Lazy annotation to break the cycle:

@Component
public class BeanA {
    private BeanB beanB;

    @Autowired
    public BeanA(@Lazy BeanB beanB) { // @Lazy
        this.beanB = beanB;
    }
}

The @Lazy annotation tells Spring to delay the injection until it's absolutely needed.
This ensures that the circular reference is resolved by creating one bean lazily.
It breaks the immediate cycle during initialization.

3, Using @PostConstruct for Initialization

Use @PostConstruct to initialize the dependent objects after the beans are fully created. 
This way, the beans can be injected first and then initialized with their dependencies.

@Component
public class ClassA {
    private ClassB classB;

    @Autowired
    public ClassA(ClassB classB) {
        this.classB = classB;
    }

    @PostConstruct
    public void init() {
        // Additional initialization after both ClassA and ClassB are injected
        classB.setClassA(this); // Inject ClassA into ClassB if needed
    }
}

@Component
public class ClassB {
    private ClassA classA;

    @Autowired
    public ClassB() {
        // constructor logic
    }

    @PostConstruct
    public void init() {
        // Initialize dependencies after bean is fully constructed
    }

    public void setClassA(ClassA classA) {
        this.classA = classA;
    }
}

@PostConstruct can help resolve circular dependencies by initializing the dependency after the bean is fully constructed.
The @PostConstruct method is invoked after the bean's construction and dependency injection.
This breaks the circular dependency by injecting one of the beans after both have been created.

4, Redesign the components to remove the circular dependency:

@Component
public class BeanA {
    private Sender sender;

    @Autowired
    public BeanA(Sender sender) {
        this.sender = sender;
    }
}

@Component
public class BeanB implements Sender {
    // Implementation
}

public interface Sender {
    // Method declarations
}

BeanA only knows about the Sender interface, not BeanB specifically.
BeanB implements Sender but doesn't need to know about BeanA.

5, Use a third class to break the dependency:

@Component
public class Mediator {
    @Autowired
    private BeanA beanA;
    @Autowired
    private BeanB beanB;

    // Methods to coordinate between BeanA and BeanB
}

```

#### 3. Explain tight coupling  vs loose coupling  and what does Spring IOC do?

```
Tight coupling occurs when components are highly dependent on each other. 
	Changes in one component often require changes in others.
	It is less flexible and harder to maintain.
	It can offer performance advantages

Loose coupling
	Components have minimal dependencies
	Changes to one component have little impact on others
	It is more flexible, scalable, and maintainable
	It promotes modularity and code reuse.

Spring IOC addresses coupling by:
	Managing object creation and lifecycle.
	Injecting dependencies automatically.
	Allowing use of interfaces instead of concrete implementations
	Enabling easier testing by facilitating mock object injection.

By using dependency injection, Spring reduces the need for components to create their own dependencies, leading to looser coupling.
```

#### 4. What is MVC pattern?
```
Spring MVC has three main components:
	Model: 
		Represents the data and business logic of the application. 
		It contains the core functionality and data, independent of the user interface1.
	View: 
		Handles the presentation of data to the user. 
		It is responsible for displaying the information from the model and sending user input to the controller1.
	Controller: 
		Acts as an intermediary between the Model and View. 
		It processes user input, manipulates the model, and determines which view to display.

In Java:
	The Model typically consists of simple Java classes.
	The View is often implemented using GUI frameworks.
	The Controller is usually implemented using servlets or other request-handling mechanisms.

This separation of concerns in MVC allows for:
	Improved code maintainability and reusability
	Parallel development of components
	Easier testing due to isolated dependencies
```

#### 5. What is Front-Controller?

```
Front Controller is a design pattern in Java web applications that centralizes request handling through a single entry point. 
It acts as the initial contact for all incoming web requests, providing a centralized mechanism for request processing.

Its key aspects are:
	Centralized control:
		All requests are handled by a single controller, allowing for consistent application-wide policies like security and logging.

	Request dispatching: 
		The Front Controller delegates requests to appropriate handlers or controllers based on the request type.

	Common preprocessing: 
		It can perform common tasks like authentication, authorization, and logging before dispatching requests.

	Improved maintainability: 
		Centralizing request handling simplifies maintenance and ensures consistent behavior across the application.

	Flexibility: 
		It allows for runtime behavior modifications through decorators.

Spring MVC uses the DispatcherServlet to implement the Front Controller pattern.
The Front Controller pattern is particularly useful for complex web applications that require consistent processing and centralized control over incoming requests
```

4am
#### 6. Explain DispatcherServlet  and how it works, demonstrate the existence of dispatcherServlet in your IDE (Jetbrain IntelliJIdea)

```
The DispatcherServlet is a central component in Spring MVC that acts as the front controller for handling all incoming web requests. 
It serves as a single entry point for the application and manages the flow of requests to appropriate handlers

The DispatcherServlet works like this:
	Receives incoming HTTP requests
	Consults handler mappings to determine which controller should process the request
	Delegates the request to the appropriate controller
	Receives the model and view name from the controller
	Resolves the view using a view resolver
	Returns the rendered view as a response to the client

web.xml can be put in src/main/webapp/WEB-INF,
<servlet-class>
	org.springframework.web.servlet.DispatcherServlet
</servlet-class>
```

#### 7. What is JSP and What is Model And Viewï¼Ÿ

```
JSP (Jakarta Server Pages) is a server-side technology for creating dynamic web content by embedding Java code within HTML pages. 
It allows developers to mix static HTML with dynamic content generated by Java code.

JSP pages are compiled into servlets by the web server before processing client requests.
It enables the creation of dynamic and platform-independent web pages.

Model and View are components of spring MVC design pattern.

Model: 
	Represents the data and business logic of the application. 
	It encapsulates the application data and is used to transfer information between the view and controller

View: 
	Handles the presentation of data to the user. 
	It renders the model data and generates HTML output that the client's browser can interpret.

In Spring MVC, the Model interface is used to add attributes to the model.
It can then be accessed by the view to display dynamic content.

The View component in Spring MVC is responsible for generating the final output.
It is usually in HTML format, based on the data provided by the Mode.
```

####  8. Explain servlet  and servlet container , name some servlet implementations and servlet containers other than tomcat

```
Servlets are Java classes that extend server capabilities to handle client requests and generate dynamic web content. 
They run within a servlet container, which manages their lifecycle and provides essential services.

A servlet container is a component of web servers or application servers that provides the runtime environment for Java servlets. 
It manages servlet lifecycles, handles request routing, and offers services like security and session management.

Servlet implementations:
	HttpServlet: Handles HTTP-specific services
	GenericServlet: Used for implementing generic services

Servlet containers other than Tomcat:
	WebSphere: IBM's Java application server
	JBoss/WildFly: An application server for Java EE applications	
	Jetty: A lightweight, flexible servlet container
	GlassFish: An open-source application server	

```

####  9. clone this repo, and run it on you local,
	1. https://github.com/CTYue/springmvc5-demo
	2. Notice that you need to configure the Tomcat by yourself.
	3. find out the APIs in controlelr and call some APIs, In slides, I also list some API.
	4. remeber to setup mysql database for this project
	5. Test APIs (controllers) in postman

```

See Coding/hw12/

import in postman:
	curl --location 'http://localhost:8080/springmvc_demo_war/customer/list' \
	--header 'Accept: */json' \
	--header 'Cookie: JSESSIONID=DE7980CF6C64A4ADF9AF232D4231C01C'
```	