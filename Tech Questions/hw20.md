# Homework 20
## Javascript
### 1. Read and practice all sample codes from 71-Dom-Bom-JavaScript-Typescript-Node.md on your local browser or an online compiler.

### 2. Resolve 5 leetcode problems using Javascript.

### 3. Compare let vs var, explain variable hosting with your own code examples.
`var` is function-scoped, meaning it is accessible anywhere within the function it is declared in, while `let` is block-scoped, restricting access to within the nearest `{}` block. 

`var` is hoisted and automatically initialized to `undefined`, whereas `let` is hoisted but remains in a **Temporal Dead Zone (TDZ)** until it is assigned a value, leading to a `ReferenceError` if accessed too early. Additionally, `var` allows redeclaration within the same scope, whereas `let` does not, preventing accidental overwrites.

   ```javascript
   console.log(a); // Output: undefined
   var a = 10;
   console.log(a); // Output: 10
   
   console.log(b); // ReferenceError: Cannot access 'b' before initialization
   let b = 20;
   console.log(b);
   ```

### 4. Explain closure with code example
A **closure** is a function that "remembers" the variables from its **outer scope** even after the outer function has finished executing. This happens because JavaScript functions maintain a reference to their **lexical scope**, allowing them to access variables from the outer function even after that function has returned.

   ```javascript
   function counter() {
       let count = 0; // Private variable
   
       return {
           increment: function () {
               count++;
               console.log(count);
           },
           decrement: function () {
               count--;
               console.log(count);
           }
       };
   }
   
   const myCounter = counter();
   myCounter.increment(); // Output: 1
   myCounter.increment(); // Output: 2
   myCounter.decrement(); // Output: 1
   console.log(myCounter.count); // Output: undefined (count is private)
   ```

### 5. Explain callback Hell with code example
Callback Hell happens when multiple nested callback functions make the code difficult to read, debug, and maintain. This usually occurs in **asynchronous** operations like file handling, database queries, and API requests when each function depends on the result of the previous one.

   ```js
   // Example of Callback Hell
   function getUser(userId, callback) {
       setTimeout(() => {
           console.log("Fetched user");
           callback({ id: userId, name: "John" });
       }, 1000);
   }
   
   function getOrders(user, callback) {
       setTimeout(() => {
           console.log(`Fetched orders for ${user.name}`);
           callback([{ orderId: 101 }, { orderId: 102 }]);
       }, 1000);
   }
   
   function getOrderDetails(order, callback) {
       setTimeout(() => {
           console.log(`Fetched details for order ${order.orderId}`);
           callback({ orderId: order.orderId, items: ["Item1", "Item2"] });
       }, 1000);
   }
   
   function processPayment(orderDetails, callback) {
       setTimeout(() => {
           console.log(`Processed payment for order ${orderDetails.orderId}`);
           callback("Payment Successful");
       }, 1000);
   }
   
   // Nested Callbacks (Callback Hell)
   getUser(1, (user) => {
       getOrders(user, (orders) => {
           getOrderDetails(orders[0], (orderDetails) => {
               processPayment(orderDetails, (paymentStatus) => {
                   console.log(paymentStatus); // Final Output
               });
           });
       });
   });
   
   // Solution using async/await
   async function processOrder() {
       try {
           const user = await getUser(1);
           const orders = await getOrders(user);
           const orderDetails = await getOrderDetails(orders[0]);
           const paymentStatus = await processPayment(orderDetails);
           console.log(paymentStatus);
       } catch (error) {
           console.error("Error processing order:", error);
       }
   }
   
   processOrder();
   ```

### 6. Explain Promise, Async, Await with code examples.
A **Promise** is an object representing the eventual completion (or failure) of an asynchronous operation. It can be in one of three states: **Pending** (Initial state, operation not completed), **Resolved** (Operation completed successfully), and **Rejected** ( Operation failed).

   ```js
   const myPromise = new Promise((resolve, reject) => {
       let success = true; // Simulating success or failure
       setTimeout(() => {
           if (success) {
               resolve("Promise Resolved!");
           } else {
               reject("Promise Rejected!");
           }
       }, 2000);
   });
   
   // Handling the Promise
   myPromise
       .then(result => console.log(result))  // If resolved
       .catch(error => console.error(error)) // If rejected
       .finally(() => console.log("Promise Completed"));
   ```

   `async` and `await` provide a cleaner way to handle Promises.

   ```js
   function getUser() {
       return new Promise((resolve) => {
           setTimeout(() => resolve({ id: 1, name: "John" }), 1000);
       });
   }
   
   function getOrders(user) {
       return new Promise((resolve) => {
           setTimeout(() => resolve(["Order1", "Order2"]), 1000);
       });
   }
   
   async function processOrder() {
       try {
           const user = await getUser();
           console.log("User:", user);
   
           const orders = await getOrders(user);
           console.log("Orders:", orders);
       } catch (error) {
           console.error("Error:", error);
       }
   }
   
   processOrder();
   ```

### 7. Write an HTML page that generates a lucky number based on the date, time, and user inputs. Users should be able to get their random lucky numbers by clicking a button or using the enter key after typing the input.
- See Projects/hw20

### 8. Write an HTML page that returns a user's GitHub repos (https://api.github.com/users/{user_id}/repos) in JSON format. The web page should have a text box and a submit button where users can provide the GitHub user ID. The fetch call should be asynchronous. If the call to the above API fails for any reason, you should return a customized, user-friendly error message. If you know more than one approach to implement the asynchronous call, please do it using different approaches.
- See Projects/hw20

### 9. Explain how Javascript implement asynchronous non-blocking feature
#### 1. Particularly: Event Loop, Macrotask, and Microtask with code samples.
JavaScript is **single-threaded** but supports **asynchronous** operations using an **event loop**, allowing it to handle non-blocking tasks like network requests, file I/O, and timers efficiently.  

The **event loop** continuously checks the **Call Stack** and the **Task Queue (Macrotasks and Microtasks)** to execute pending tasks in the correct order.

1. **JavaScript Execution** starts with the **Call Stack**.
2. If an **asynchronous task** (like a `setTimeout`, `fetch`, or Promise) is encountered, it is sent to the **Web API**.
3. Once the task completes:
- **Promises (Microtasks)** are pushed into the **Microtask Queue**. They includes **Promises (`.then`, `.catch`, `.finally`)** and **MutationObserver**.
- **Timers and other callbacks (Macrotasks)** are pushed into the **Macrotask Queue**. They include **`setTimeout`**, **`setInterval`**, **I/O operations**, **MessageChannel**, and **event handlers**.
4. The **Event Loop** ensures:
- The **Call Stack** is empty before processing new tasks.
- **Microtasks** run before **Macrotasks**.

   ```javascript
   console.log("Start");
   
   // Macrotask (setTimeout)
   setTimeout(() => console.log("Macrotask: setTimeout"), 0);
   
   // Microtask (Promise)
   Promise.resolve().then(() => console.log("Microtask: Promise 1"));
   
   // Microtask (Promise)
   Promise.resolve().then(() => {
       console.log("Microtask: Promise 2");
       setTimeout(() => console.log("Macrotask: setTimeout inside Microtask"), 0);
   });
   
   // Macrotask (setTimeout)
   setTimeout(() => console.log("Macrotask: setTimeout 2"), 0);
   
   console.log("End");
   
   // Output
   // Start
   // End
   // Microtask: Promise 1
   // Microtask: Promise 2
   // Macrotask: setTimeout
   // Macrotask: setTimeout 2
   // Macrotask: setTimeout inside Microtask
   ```