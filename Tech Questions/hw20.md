# HW20
____
### 3. Compare let vs var, explain variable hoisting with your own code examples.
- `let` and `var` are both used to declare variables in JavaScript, but they have some key differences:
  - `var` is function-scoped, while `let` is block-scoped.
  - Variables declared with `var` are hoisted to the top of their function or global scope, while variables declared with `let` are not hoisted.
  - Variables declared with `var` can be redeclared within the same scope, while variables declared with `let` cannot be redeclared.
  - Variables declared with `var` are initialized with `undefined`, while variables declared with `let` are not initialized until their declaration is reached in the code.

Variable hoisting: Variables declared with var are hoisted to the top of their function or global scope. They can be accessed before  they are declared, but they will be undefined.
```javascript
console.log(x); // undefined (hoisted but not initialized)
var x = 10;
console.log(x); // 10

console.log(y); // ReferenceError: y is not defined (let variables are not hoisted)
let y = 20;
console.log(y); // 20
```

### 4. Explain closure with code example.
A closure is a function that remembers the variables from its outer scope even after the outer function has finished executing.
```javascript
function outerFunction() {
    let outerVariable = "I am from outer function";
    function innerFunction() {
        console.log(outerVariable); // Accessing outerVariable from the outer scope
    }
    return innerFunction();
}

const closureFunction = outerFunction(); // outerFunction executes, but innterFunction is returned
closureFunction(); // "I am from outer function"
```

### 5. Explain Callback Hell with code example.
Callback Hell (also known as "Pyramid of Doom") happens when multiple nested callback functions make the code hard to read, understand, and maintain. 
```javascript
function getUser(userId, callback) {
    setTimeout(() => {
        console.log("Fetched user data");
        callback({ id: userId, name: "John Doe" });
    }, 1000);
}

function getPosts(userId, callback) {
    setTimeout(() => {
        console.log("Fetched posts for user:", userId);
        callback([{ postId: 1, content: "Post 1" }, { postId: 2, content: "Post 2" }]);
    }, 1000);
}

function getComments(postId, callback) {
    setTimeout(() => {
        console.log("Fetched comments for post:", postId);
        callback([{ commentId: 101, text: "Nice post!" }, { commentId: 102, text: "Great read!" }]);
    }, 1000);
}

// Nested Callbacks (Callback Hell)
getUser(1, (user) => {
    getPosts(user.id, (posts) => {
        getComments(posts[0].postId, (comments) => {
            console.log("Final data:", { user, posts, comments });
        });
    });
});
```

### 6. Explain Promises, Async/Await with code example.
JavaScript uses Promises and Async/Await to handle asynchronous operations efficiently, avoiding issues like callback hell.  

A Promise represents a value that may be available now, later, or never. It has three states:
1. Pending – The initial state (not fulfilled or rejected yet).
2. Fulfilled – The operation was successful.
3. Rejected – The operation failed.

async/await is a modern syntax in JavaScript used for handling asynchronous operations.

To fix the Callback Hell in problem 5:
- Use Promises:
```javascript
// The getUser, getPosts, getComments are still the same

// Chaining Promises
getUser(1)
    .then(user => getPosts(user.id))
    .then(posts => getComments(posts[0].postId))
    .then(comments => console.log("Final data:", { comments }))
    .catch(error => console.error(error));
```

- Use Async/Await:
```javascript
// The getUser, getPosts, getComments are still the same
async function fetchData() {
    try {
        const user = await getUser(1);
        const posts = await getPosts(user.id);
        const comments = await getComments(posts[0].postId);
        console.log("Final data:", { user, posts, comments });
    } catch (error) {
        console.error(error);
    }
}
fetchData();
```

### 7. Write an HTML page that generates a lucky number based on the date, time, and user inputs. Users should be able to get their random lucky numbers by clicking a button or using the enter key after typing the input.
/Projects/hw20-project/luck-number.html

### 8. Write an HTML page that returns a user's GitHub repos (https://api.github.com/users/{user_id}/repos) in JSON format. The web page should have a text box and a submit button where users can provide the
/Projects/hw20-project/github-info.html

### 9. Explain how Javascript implement asynchronous non-blocking feature. Particularly: Event Loop, Macrotask, and Microtask with code samples.
- The Event Loop is responsible for handling asynchronous operations by continuously checking Call Stack (Where functions execute), Microtask Queue (High-priority tasks like Promises) and Macrotask Queue (Lower-priority tasks like setTimeout)
- Microtasks are small tasks that are executed immediately after the current call stack is cleared but before the next Macrotask promises. Including Promises(.then(), .catch(), .finally())
- Macrotasks are large tasks executed after current call stack is cleared, after all microtasks are processed. Including setTimeout(), setInterval(), I/O operations.

```javascript
console.log("Start"); // Synchronous
// Macrotask
setTimeout(() => console.log("Timeout 1"), 0);
// Microtask
Promise.resolve().then(() => {
    console.log("Promise 1");
})
// Macrotask
setTimeout(() => console.log("Timeout 2"), 0);
// Microtask (Promise)
Promise.resolve().then(() => {
    console.log("Promise 2");
});
console.log("End"); // Synchronous

// Output:
// Start
// End
// Promise 1
// Promise 2
// Timeout 1
// Timeout 2
```


















