# HW20

## Questions:

### 2.

See screenshot - hw20_leetcode_js

### 3. Compare let vs var , explain variable hosting with your own code examples.

---

### Scope Difference:

- `var` is **function-scoped**: it is accessible anywhere inside the function where it's declared.
- `let` is **block-scoped**: it is only accessible within the block (`{}`) in which it's defined.

```javascript
function scopeExample() {
  if (true) {
    var a = 1;
    let b = 2;
  }
  console.log(a); // Accessible, outputs 1
  console.log(b); // ReferenceError: b is not defined
}
scopeExample();
```

---

### Hoisting Behavior:

- Both `var` and `let` are hoisted to the top of their scope.
- `var` is initialized as `undefined`, so it can be referenced before the declaration (though it won't have its actual value yet).
- `let` is hoisted but **not initialized**, leading to a **Temporal Dead Zone (TDZ)** where accessing it before declaration throws an error.

```javascript
console.log(x); // undefined
var x = 10;

console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 20;
```

---

### 4. Explain closure with a code example

A **closure** is a function that "remembers" the variables from its **lexical scope**, even when the function is executed **outside of that scope**.

In other words, closures allow inner functions to **access variables** from an outer function **even after the outer function has finished executing**.

---

### Example:

```javascript
function outerFunction(outerValue) {
  return function innerFunction(innerValue) {
    console.log(`Outer: ${outerValue}, Inner: ${innerValue}`);
  };
}

const closureExample = outerFunction("Hello");
closureExample("World"); // Output: Outer: Hello, Inner: World
```

---

### How It Works:

- `innerFunction` forms a **closure** over `outerValue` from `outerFunction`.
- Even after `outerFunction` completes, `outerValue` is still available to `innerFunction`.
- This is possible because the returned function retains access to its lexical environment.

---

### Use Cases of Closures:

- Data encapsulation (simulating private variables)
- Function factories
- Event handlers and callbacks

---

### 5. Explain Callback Hell with a code example

---

**Callback Hell** refers to a situation in JavaScript where **multiple nested callbacks** make the code **difficult to read, understand, and maintain**. It often occurs when asynchronous operations are chained using callbacks, leading to a pyramid-shaped or deeply indented code structure.

---

### Example of Callback Hell:

```javascript
getUser(userId, function (user) {
  getPosts(user.id, function (posts) {
    getComments(posts[0].id, function (comments) {
      console.log("First post comments:", comments);
    });
  });
});
```

- Each function depends on the result of the previous one.
- As nesting increases, it becomes harder to handle **errors**, **maintain code**, or **add features**.

---

### Problems with Callback Hell:

- Hard to read and debug
- Error handling becomes messy
- Difficult to scale or modify

---

### Solution:

Use **Promises** or **async/await** to flatten the structure.

```javascript
async function fetchData() {
  const user = await getUser(userId);
  const posts = await getPosts(user.id);
  const comments = await getComments(posts[0].id);
  console.log("First post comments:", comments);
}
```

---

### 6. Explain Promise, Async, Await with code examples

---

### What is a Promise?

A **Promise** is an object in JavaScript that represents the eventual **completion or failure** of an asynchronous operation.

It has three states:

- **Pending**: Initial state
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed

---

### Promise Example:

```javascript
function getData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Data received");
    }, 1000);
  });
}

getData()
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error(error);
  });
```

---

### What is `async` and `await`?

- `async` is a keyword that turns a function into one that **returns a promise**.
- `await` can only be used inside an `async` function and **pauses** execution until the promise is resolved or rejected.

---

### Async/Await Example:

```javascript
async function fetchData() {
  try {
    const result = await getData();
    console.log(result);
  } catch (error) {
    console.error("Error:", error);
  }
}

fetchData();
```

---

### Benefits of Async/Await:

- Makes asynchronous code look and behave like synchronous code
- Easier to read, write, and debug compared to chaining `.then()` and `.catch()`

---

### 7. Write an HTML page that generates a lucky number based on the date,time, and user inputs. Users should be able to get their random lucky numbers by clicking a button or using the enter key after typing the input.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lucky Number Generator</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 40px;
        text-align: center;
      }
      input {
        padding: 10px;
        font-size: 16px;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        margin-left: 10px;
      }
      #result {
        margin-top: 20px;
        font-size: 20px;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>Find Your Lucky Number</h1>
    <input type="text" id="nameInput" placeholder="Enter your name" />
    <button onclick="generateLuckyNumber()">Get Lucky Number</button>
    <div id="result"></div>

    <script>
      function generateLuckyNumber() {
        const name = document.getElementById("nameInput").value.trim();
        if (!name) {
          document.getElementById("result").textContent =
            "Please enter your name.";
          return;
        }

        const now = new Date();
        const seed = name + now.toISOString();
        let hash = 0;
        for (let i = 0; i < seed.length; i++) {
          hash = seed.charCodeAt(i) + ((hash << 5) - hash);
        }
        const luckyNumber = Math.abs(hash % 100) + 1; // Range: 1-100

        document.getElementById(
          "result"
        ).textContent = `Your lucky number is: ${luckyNumber}`;
      }

      // Trigger on Enter key
      document
        .getElementById("nameInput")
        .addEventListener("keypress", function (event) {
          if (event.key === "Enter") {
            generateLuckyNumber();
          }
        });
    </script>
  </body>
</html>
```

### 8. Write an HTML page that returns a user's GitHub repos (https://api.github.com/users/{user_id}/repos)in JSON format.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>GitHub Repo Fetcher</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 40px;
        text-align: center;
      }
      input {
        padding: 10px;
        font-size: 16px;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        margin-left: 10px;
      }
      pre {
        text-align: left;
        margin-top: 30px;
        padding: 15px;
        background: #f4f4f4;
        border: 1px solid #ccc;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <h1>GitHub Repo Viewer</h1>
    <input type="text" id="username" placeholder="Enter GitHub Username" />
    <button onclick="fetchRepos()">Get Repos</button>
    <pre id="output"></pre>

    <script>
      function fetchRepos() {
        const user = document.getElementById("username").value.trim();
        const output = document.getElementById("output");

        if (!user) {
          output.textContent = "Please enter a GitHub username.";
          return;
        }

        fetch(`https://api.github.com/users/${user}/repos`)
          .then((response) => {
            if (!response.ok) {
              throw new Error(`Error: ${response.status}`);
            }
            return response.json();
          })
          .then((data) => {
            output.textContent = JSON.stringify(data, null, 2);
          })
          .catch((error) => {
            output.textContent = error.toString();
          });
      }

      // Allow Enter key to trigger fetch
      document
        .getElementById("username")
        .addEventListener("keypress", function (event) {
          if (event.key === "Enter") {
            fetchRepos();
          }
        });
    </script>
  </body>
</html>
```

### 9. Explain how Javascript implement a synchronous non-blocking feature

---

JavaScript is **single-threaded**, meaning it executes one command at a time. Despite this, it achieves **non-blocking behavior** using a combination of **asynchronous APIs**, **event loop**, and **callback queue**.

This allows JavaScript to remain **synchronous in structure** but still **non-blocking in behavior** when dealing with I/O, timers, network requests, etc.

---

### Core Mechanism:

1. **Call Stack**

   - Executes code line by line.
   - If a long task (like I/O) is encountered, it hands it off to the browser/Web API.

2. **Web APIs / Background APIs**

   - Handle asynchronous tasks like `setTimeout`, HTTP requests, etc.

3. **Callback Queue / Task Queue**

   - Once async tasks complete, their callbacks are added here, waiting for the stack to be free.

4. **Event Loop**
   - Continuously checks if the call stack is empty.
   - If so, it pushes the next callback from the queue into the stack for execution.

---

### Example:

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Inside timeout");
}, 0);

console.log("End");
```

**Output:**

```
Start
End
Inside timeout
```

Even though `setTimeout` has a 0 delay, its callback is placed in the queue and only runs after the main stack is clear.

---
