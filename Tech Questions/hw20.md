# HW20

---

## 3. Compare `let` vs `var` and Explain Variable Hoisting

**`var` vs `let`:**

- **Scope:**
    - **`var`** is function-scoped. A variable declared with `var` is accessible anywhere within the function in which it is declared—even before its declaration (its value will be `undefined` due to hoisting).
    - **`let`** is block-scoped. A variable declared with `let` is only available within the block (i.e., inside `{}`) in which it is declared.

- **Hoisting:**
    - **`var`** declarations are hoisted to the top of their function scope. However, only the declaration is hoisted—not the initialization. This means you can reference the variable before its declaration, but its value will be `undefined`.
    - **`let`** declarations are also hoisted, but they are not initialized. Accessing them before the declaration results in a `ReferenceError` because they are in a Temporal Dead Zone (TDZ) until the declaration is executed.

**Example Code:**

```javascript
// Using var
console.log(x); // Output: undefined (hoisted, but not yet initialized)
var x = 10;

// Using let
console.log(y); // Throws ReferenceError: Cannot access 'y' before initialization
let y = 20;
```

## 4. Explain Closure with a Code Example

A closure is formed when a function retains access to its lexical scope (the environment in which it was created) even after the outer function has finished executing. This allows the inner function to access variables from the outer function.

**Example Code:**

```javascript
function createCounter() {
    let count = 0; // Local variable in createCounter's scope
    return function() {
        count++; // The inner function has access to 'count'
        console.log(count);
    };
}

const counter = createCounter();
counter(); // Output: 1
counter(); // Output: 2

```

In this example, the inner function retains access to the count variable even after createCounter() has completed execution.

## 5. Explain Callback Hell with a Code Example

Callback Hell refers to the situation where callbacks are nested within callbacks, leading to deeply indented and hard-to-read code. This often makes the code difficult to maintain and debug.

**Example Code:**

```javascript
doTask(function(result) {
  doTask2(result, function(newResult) {
    doTask3(newResult, function(finalResult) {
      console.log('Final result:', finalResult);
    });
  });
});
```
Each callback is nested inside another callback, creating a pyramid-like structure that is known as "callback hell."

## 6. Explain Promise, Async, and Await with Code Examples

**Promise**

A Promise represents the eventual completion or failure of an asynchronous operation. You use .then() and .catch() methods to handle success or error cases.

**Example Code:**

```javascript
function asyncTask() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Task Completed');
        }, 1000);
    });
}

asyncTask()
    .then(result => {
        console.log(result); // Output: Task Completed
    })
    .catch(error => {
        console.error(error);
    });
```

**Async/Await**

Async/Await is syntactic sugar built on top of Promises that allows you to write asynchronous code in a way that looks synchronous. An async function returns a Promise, and await pauses the execution until the Promise resolves.

**Example Code:**

```javascript
async function runTask() {
    try {
        const result = await asyncTask();
        console.log(result); // Output: Task Completed
    } catch (error) {
        console.error(error);
    }
}

runTask();
```

## 7. HTML Page: Lucky Number Generator

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lucky Number Generator</title>
</head>
<body>
  <input type="text" id="username" placeholder="Enter your name">
  <button id="generate">Get Lucky Number</button>
  <p id="result"></p>

  <script>
    const usernameInput = document.getElementById('username');
    const generateBtn = document.getElementById('generate');
    const resultEl = document.getElementById('result');

    function generateLuckyNumber() {
      const name = usernameInput.value.trim();
      if (!name) {
        resultEl.innerText = 'Please enter a valid name!';
        return;
      }
      const now = new Date();
      // Combine the character codes of the name with the current timestamp
      let hash = 0;
      for (let i = 0; i < name.length; i++) {
        hash += name.charCodeAt(i);
      }
      const luckyNumber = (hash + now.getTime()) % 100 + 1; // Generates a number between 1 and 100
      resultEl.innerText = `Your lucky number is: ${luckyNumber}`;
    }

    // Handle button click and Enter key events
    generateBtn.addEventListener('click', generateLuckyNumber);
    usernameInput.addEventListener('keyup', function(event) {
      if (event.key === 'Enter') {
        generateLuckyNumber();
      }
    });
  </script>
</body>
</html>

```

## 8. HTML Page: GitHub Repositories Fetcher
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GitHub Repositories Fetcher</title>
</head>
<body>
  <input type="text" id="githubUser" placeholder="Enter GitHub username">
  <button id="fetchRepos">Fetch Repositories</button>
  <pre id="output"></pre>

  <script>
    const githubUserInput = document.getElementById('githubUser');
    const fetchBtn = document.getElementById('fetchRepos');
    const outputEl = document.getElementById('output');

    // Approach 1: Using fetch with Promises
    function fetchRepos() {
      const user = githubUserInput.value.trim();
      if (!user) {
        outputEl.innerText = 'Please enter a valid GitHub username!';
        return;
      }
      fetch(`https://api.github.com/users/${user}/repos`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response error');
          }
          return response.json();
        })
        .then(data => {
          outputEl.innerText = JSON.stringify(data, null, 2);
        })
        .catch(error => {
          outputEl.innerText = `Error: Unable to fetch repository information. ${error.message}`;
        });
    }

    // Approach 2: Using async/await
    async function fetchReposAsync(user) {
      try {
        const response = await fetch(`https://api.github.com/users/${user}/repos`);
        if (!response.ok) {
          throw new Error('Network response error');
        }
        const data = await response.json();
        outputEl.innerText = JSON.stringify(data, null, 2);
      } catch (error) {
        outputEl.innerText = `Error: Unable to fetch repository information. ${error.message}`;
      }
    }

    // Event listener for button click
    fetchBtn.addEventListener('click', function() {
      const user = githubUserInput.value.trim();
      if (user) {
        // Uncomment one of the approaches below:
        fetchRepos();          // Using Promises
        // fetchReposAsync(user); // Using async/await
      } else {
        outputEl.innerText = 'Please enter a valid GitHub username!';
      }
    });

    // Trigger button click on Enter key press
    githubUserInput.addEventListener('keyup', function(event) {
      if (event.key === 'Enter') {
        fetchBtn.click();
      }
    });
  </script>
</body>
</html>

```

## 9. How JavaScript Implements Asynchronous Non-Blocking Features

JavaScript is single-threaded, yet it manages asynchronous operations using an event loop. The event loop allows JavaScript to perform non-blocking operations by handling asynchronous callbacks.

- Event Loop:
  The event loop continuously checks the call stack and the task queues. When the call stack is empty, it picks tasks from the microtask queue (which includes Promise callbacks) and then the macrotask queue (which includes setTimeout, setInterval, and I/O events).

- Macrotasks vs Microtasks:

    - Macrotasks: These include the main script, setTimeout, setInterval, and I/O operations.
    - Microtasks: These include Promise callbacks (.then(), .catch(), .finally()) and other tasks like process.nextTick in Node.js. Microtasks are processed immediately after the current macrotask completes and before the next macrotask begins.

**Example Code:**

```javascript
console.log('Start');

setTimeout(() => {
    console.log('Macrotask: setTimeout');
}, 0);

Promise.resolve().then(() => {
    console.log('Microtask: Promise.then');
});

console.log('End');
```

Execution Explanation:

1. Synchronous Code:

- The code logs "Start" and then "End" immediately.
2. Microtasks:

- After the synchronous code completes, the microtask queue is processed, logging "Microtask: Promise.then".
3. Macrotasks:

- Finally, the macrotask scheduled by setTimeout executes, logging "Macrotask: setTimeout".

This design allows JavaScript to handle asynchronous operations without blocking the main thread.

