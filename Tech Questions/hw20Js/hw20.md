## HW20: HW_JS

### 1. Read and practice all sample codes from 71-Dom-Bom-JavaScript-Typescript-Node.md on your local browser or an online compiler.

### 2. Resolve 5 leetcode problems using Javascript.

```

```

### 3. Compare let  vs var  , explain variable hosting with your own code examples.

```
(1) scope is different:
Variables declared with var are function-scoped. 
Variables declared with let are block-scoped. 

(2) Hoisting
Variables declared with var are hoisted to the top of their function or global scope. 
They can be accessed before  they are declared, but they will be undefined.

Variables declared with let are also hoisted, but they are not initialized. 
Accessing them before the declaration results in a ReferenceError.

console.log(x); // Output: undefined (hoisted but not initialized)
var x = 10;
console.log(x); // Output: 10

console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 20;
console.log(y); // Output: 20

(3) Re-declaration
We can re-declare a variable with var within the same scope without any error.
Re-declaring a variable with let within the same scope will throw a SyntaxError

var a = 50;
var a = 60; // No error
console.log(a); // Output: 60

let b = 70;
let b = 80; // SyntaxError: Identifier 'b' has already been declared
```

### 4. Explain closure  with code example

```
A closure is a function that retains access to its outer scope, even after the outer function has finished executing.
Closures are created whenever a function is created.
They are useful for data encapsulation, maintaining state, and functional programming patterns.

Examples:

	function outerFunction() {
		let outerVariable = "I'm from outer scope!";

		function innerFunction() {
			console.log(outerVariable); // Accessing outerVariable
		}

		return innerFunction; // Return the inner function
	}
	

	const closureExample = outerFunction(); // outerFunction finishes executing
	closureExample(); // Output: "I'm from outer scope!"

	function createCounter() {
		let count = 0; // Private variable

		return function() {
			count++; // Access and modify the private variable
			return count;
		};
	}

	const counter = createCounter();

	console.log(counter()); // Output: 1
	console.log(counter()); // Output: 2
	console.log(counter()); // Output: 3

	The returned function forms a closure, "remembering" the count variable even after createCounter has finished executing.


	function outer() {
		let x = 10;
		return function inner() {
			console.log(x); // Accessing x from outer scope
		};
	}

	const innerFunc = outer();
	innerFunc(); // Output: 10

```

### 5. Explain Callback Hell  with code example

```
Callback Hell occurs when multiple nested callbacks make the code hard to read and maintain.
It happens due to dependent asynchronous operations.
There are two solutions to avoid callback hell:
	Use Promises to flatten the code.
	Or Use async/await for even cleaner and more readable code.

Problems with Callback Hell:
	Readability: The code becomes difficult to read and understand due to deep nesting.
	Maintainability: Adding or modifying functionality becomes challenging.
	Error Handling: Handling errors in nested callbacks can become messy.
	Debugging: Debugging deeply nested code is harder.

Exmaple:
Let's say we need to perform below tasks:
	Fetch user data from an API.
	Fetch the user's posts based on the user data.
	Fetch the comments for the first post.
	
	function fetchUser(userId, callback) {
		setTimeout(() => {
			console.log("Fetching user...");
			const user = { id: userId, name: "Alice" };
			callback(user);
		}, 1000);
	}

	function fetchPosts(user, callback) {
		setTimeout(() => {
			console.log("Fetching posts...");
			const posts = [{ id: 1, title: "Post 1" }, { id: 2, title: "Post 2" }];
			callback(posts);
		}, 1000);
	}

	function fetchComments(post, callback) {
		setTimeout(() => {
			console.log("Fetching comments...");
			const comments = [{ id: 1, text: "Comment 1" }, { id: 2, text: "Comment 2" }];
			callback(comments);
		}, 1000);
	}

	// Callback Hell
	fetchUser(1, (user) => {
		fetchPosts(user, (posts) => {
			fetchComments(posts[0], (comments) => {
				console.log("Comments:", comments);
			});
		});
	});

Solution:
1, Use Promises:

	function fetchUser(userId) {
		return new Promise((resolve) => {
			setTimeout(() => {
				console.log("Fetching user...");
				const user = { id: userId, name: "Alice" };
				resolve(user);
			}, 1000);
		});
	}

	function fetchPosts(user) {
		return new Promise((resolve) => {
			setTimeout(() => {
				console.log("Fetching posts...");
				const posts = [{ id: 1, title: "Post 1" }, { id: 2, title: "Post 2" }];
				resolve(posts);
			}, 1000);
		});
	}

	function fetchComments(post) {
		return new Promise((resolve) => {
			setTimeout(() => {
				console.log("Fetching comments...");
				const comments = [{ id: 1, text: "Comment 1" }, { id: 2, text: "Comment 2" }];
				resolve(comments);
			}, 1000);
		});
	}

	// Using Promises
	fetchUser(1)
		.then((user) => fetchPosts(user))
		.then((posts) => fetchComments(posts[0]))
		.then((comments) => console.log("Comments:", comments))
		.catch((error) => console.error("Error:", error));


2, Use Async/Await:
   Async/Await is syntactic sugar on top of Promises, making asynchronous code look synchronous and easier to read.

	async function main() {
		try {
			const user = await fetchUser(1);
			const posts = await fetchPosts(user);
			const comments = await fetchComments(posts[0]);
			console.log("Comments:", comments);
		} catch (error) {
			console.error("Error:", error);
		}
	}

	main();
```

### 6. Explain Promise , Async , Await  with code examples.

```
Promises: Represent the eventual result of an asynchronous operation.
async Functions: Simplify working with Promises by allowing the use of await.
await: Pauses execution of an async function until a Promise is resolved.

1. Promise:
It has three states: Pending, Fulfilled, Rejected.

	const fetchData = () => {
		return new Promise((resolve, reject) => {
			setTimeout(() => {
				const success = true; // Simulate success/failure
				if (success) {
					resolve("Data fetched successfully!");
				} else {
					reject("Error fetching data!");
				}
			}, 2000);
		});
	};

	fetchData()
		.then((result) => {
			console.log(result); // Output: "Data fetched successfully!"
		})
		.catch((error) => {
			console.error(error); // Output: "Error fetching data!"
		});


2, async Functions:
	The async keyword is used to declare an asynchronous function. It automatically returns a Promise. 
	Inside an async function, we can use the await keyword to pause execution until a Promise is resolved.
	
	const fetchData = () => {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve("Data fetched successfully!");
			}, 2000);
		});
	};

	async function getData() {
		const result = await fetchData(); // Pause execution until the Promise resolves
		console.log(result); // Output: "Data fetched successfully!"
	}

	getData();

3, await Keyword:
	The await keyword is used inside an async function to pause execution until a Promise is resolved.
	await can only be used inside an async function.
	
	const fetchUser = () => {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve({ id: 1, name: "Alice" });
			}, 1000);
		});
	};

	const fetchPosts = () => {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve(["Post 1", "Post 2"]);
			}, 1000);
		});
	};

	async function getUserAndPosts() {
		const user = await fetchUser(); // Wait for user data
		const posts = await fetchPosts(); // Wait for posts data
		console.log("User:", user);
		console.log("Posts:", posts);
	}

	getUserAndPosts();
	


```

### 7. Write an HTML page that generates a lucky number based on the date, time, and user inputs. Users should be able to get their random lucky numbers by clicking a button or using the enter key after typing the input.

```
See Coding/hw20/Q7
```

### 8. Write an HTML page that returns a user's GitHub repos (https://api.github.com/users/{user_id}/repos) in JSON format. The web page should have a text box and a submit button where users can provide the
GitHub user ID. The fetch call should be asynchronous. If the call to the above API fails for any reason, you
should return a customized, user-friendly error message. If you know more than one approach to implement the asynchronous call, 
please do it using different approaches.

```
See Coding/hw20/Q8
Approach 1: Using fetch with Promises
Approach 2: Using async/await
```

### 9. Explain how Javascript implement asynchronous non-blocking feature. Particularly: Event Loop, Macrotask, and Microtask with code samples.

```
JavaScript is single-threaded. It can only execute one task at a time. 
However, it achieves asynchronous, non-blocking behavior through the Event Loop, Macrotasks, and Microtasks. 

Event Loop: Manages the execution of synchronous and asynchronous code.
Microtasks: Executed immediately after the current Call Stack is cleared (e.g., Promises).
Macrotasks: Executed after all Microtasks are completed (e.g., setTimeout, setInterval).

1. Event Loop:
	The Event Loop is the core mechanism that allows JavaScript to handle asynchronous operations. 
	It continuously checks the Call Stack and the Task Queues to determine what to execute next.

2. Macrotasks:
	Macrotasks are larger tasks that are executed after the current Call Stack is cleared.
	setTimeout and setInterval
	I/O operations
	UI rendering
	Event listeners, such as click, fetch

3,  Microtasks
	Microtasks are smaller tasks that are executed immediately after the current Call Stack is cleared but before the next Macrotask. 
	Promises, such as .then, .catch, .finally
	queueMicrotask
	MutationObserver

Example:
	console.log("Start"); // Synchronous code

	// Macrotask (setTimeout)
	setTimeout(() => {
		console.log("Timeout 1");
	}, 0);

	// Microtask (Promise)
	Promise.resolve().then(() => {
		console.log("Promise 1");
	});

	// Macrotask (setTimeout)
	setTimeout(() => {
		console.log("Timeout 2");
	}, 0);

	// Microtask (Promise)
	Promise.resolve().then(() => {
		console.log("Promise 2");
	});

	console.log("End"); // Synchronous code
```