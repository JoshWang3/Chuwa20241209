# Homework 20
## Cassandra

### 1. create a new keyspace "chuwa"
```
CREATE KEYSPACE chuwa 
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};
```

### 2. create a new table "trainee_information" with necessary columns, setup multiple partition keys, 
### 3. setup a clustering key column using timestamp data type,
```
CREATE TABLE trainee_information (
    trainee_id UUID,               -- Unique ID for each trainee
    tech_stack TEXT,               -- Tech Stack name
    training_batch TEXT,           -- Training batch
    join_date TIMESTAMP,           -- Timestamp when the trainee joined (Clustering Key)
    name TEXT,                     -- Trainee’s name
    age INT,                       -- Age of the trainee
    email TEXT,                    -- Contact email
    PRIMARY KEY ((tech_stack, training_batch), join_date)
) WITH CLUSTERING ORDER BY (join_date DESC);
```


### 4. Insert multiple rows for above table.
```
INSERT INTO trainee_information (trainee_id, tech_stack, training_batch, join_date, name, age, email) 
VALUES (uuid(), 'Java', '2025 Q1', '2025-02-21 10:00:00', 'Alice', 25, 'alice@example.com');

INSERT INTO trainee_information (trainee_id, tech_stack, training_batch, join_date, name, age, email) 
VALUES (uuid(), 'Full Stack', '2025 Q1', '2025-02-21 11:00:00', 'Bob', 26, 'bob@example.com');

INSERT INTO trainee_information (trainee_id, tech_stack, training_batch, join_date, name, age, email) 
VALUES (uuid(), 'Java', '2024 Q4', '2024-12-20 09:30:00', 'Charlie', 30, 'charlie@example.com');
```

### 5. Use proper data types for other columns,
### 6. Come up with queries to prove that Cassandra supports "flexible schema"
```
ALTER TABLE trainee_information ADD phone_number TEXT;

INSERT INTO trainee_information (trainee_id, tech_stack, training_batch, join_date, name, phone_number) 
VALUES (uuid(), 'Java', '2024 Q4', '2024-11-21 12:00:00', 'David', '652874632');
```

### 7. Explain why Cassandra has a "Query-first design" with CQL query examples
In Cassandra, schema and table structures are designed based on how data will be queried rather than traditional relational normalization. This is because Cassandra is optimized for fast reads and writes on large distributed datasets.
1. Denormalization for Performance: Unlike relational databases, where normalization reduces redundancy, Cassandra encourages denormalization to improve read performance. Instead of performing expensive JOIN operations, all required data is stored in a single table or pre-aggregated.
2. Partitioning and Clustering for Efficient Queries: Data is distributed across multiple nodes based on partition keys, ensuring fast lookup. Clustering keys allow efficient sorting and retrieval within partitions.
3. Schema Evolution without Downtime: New columns can be added anytime without breaking existing queries, making the system flexible.

Query: Retrieves all Java trainees from a specific training batch, sorted by their join date in descending order
```
SELECT * FROM trainee_information 
WHERE tech_stack = 'Java' AND training_batch = '2025 Q1';
```
The partition key (tech_stack, training_batch) ensures the query is executed efficiently without scanning the entire database.
The clustering key (join_date) sorts the results for fast retrieval.

Query: Query all trainees who joined after a specific date within a batch:
```
SELECT * FROM trainee_information 
WHERE tech_stack = 'Java' AND training_batch = '2025 Q1' 
AND join_date > '2025-02-20 00:00:00';
```
Cassandra’s clustering key allows efficient retrieval of time-series data.

### 8. Explain Cassandra consistency levels.
In Apache Cassandra, consistency levels define how many replica nodes must acknowledge a read or write operation before it is considered successful in order to balance between availability and consistency in CAP theorem. This allows users to balance between strong consistency, availability, and performance based on their use case.

- `ONE`: At least one replica responds.
- `QUORUM`: Majority of replicas must respond.
- `ALL`: All replicas must acknowledge the write/read.
- `LOCAL_ONE`: One replica from the local datacenter responds.
- `LOCAL_QUORUM`: Majority of replicas in local datacenter respond.
- `EACH_QUORUM`: Majority from each datacenter must respond.

Query with Consistency Level
```
-- Ensures most replicas return consistent data.
CONSISTENCY QUORUM;
SELECT * FROM trainee_information WHERE department = 'Java' AND batch = '2025 Q1';
```

Use Cases:
1. For high availability: Use ONE or ANY (best for logging, caching, or real-time applications).
2. For strong consistency: Use QUORUM or ALL (suitable for financial transactions or critical data).
3. For multi-datacenter: Use LOCAL_QUORUM or EACH_QUORUM to optimize cross-region performance.
4. For lightweight transactions: Use SERIAL to ensure atomicity.

### 9. Attached code and screenshots for above questions.
 