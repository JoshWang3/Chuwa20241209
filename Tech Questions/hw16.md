# Homework 16
## Microservice
### 1. list all of the new annotations you learned to your annotations.md

### 2. Explain monolithic architecture, service oriented architecture and Micro service architecture.
- **Monolithic Architecture** is a traditional software design approach where the entire application is built as a single, unified unit. All components (UI, business logic, and data access) are tightly integrated and run as a single service.  

- **Service-Oriented Architecture SOA** organizes software systems into a collection of loosely coupled services that communicate over a network. These services typically share a common communication protocol like SOAP or REST.  

- **Microservices Architecture** is a modern variant of SOA where an application is divided into smaller, independent services that are loosely coupled and can be developed, deployed, and scaled independently.  

### 3. Document the microservice architeture and core components.
- Microservices architecture is a software development approach where an application is built as a collection of small, autonomous services, each responsible for a specific functionality. These services communicate with each other using lightweight protocols, such as HTTP/REST or messaging queues, and can be developed, deployed, and scaled independently.

- **Core Components**
1. **API Gateway** provides a unified entry point for client applications. It handles routing, filtering, and load balancing. 
2. **Service Registry** contains the details of all the services. The gateway discovers the service using the registry. For example, Consul, Eureka, Zookeeper, etc. 
3. **Service Layer** Each microservice serves a specific business function and can run on multiple instances. These services can be built using frameworks like Spring Boot, NestJS, etc. 
4. **Authorization Server** is used to secure the microservices and manage identity and access control, e.g. Keycloak, Azure AD, and Okta etc.
5. **Data Storage**, databases like PostgreSQL and MySQL can store application data generated by the services. 
6. **Distributed Caching** is a great approach for boosting the application performance. Options include caching solutions like Redis, Couchbase, Memcached, etc. 
7. **Async Microservices Communication** Use platforms such as Kafka and RabbitMQ to support async communication between microservices. 
8. **Metrics Visualization** Microservices can be configured to publish metrics to Prometheus and tools like Grafana can help visualize the metrics. 
9. **Log Aggregation and Visualization** Logs generated by the services are aggregated using Logstash, stored in Elasticsearch, and visualized with Kibana.

- **Benefits**
   - **Scalability:** Scale individual services based on demand.
   - **Flexibility:** Use different technologies for different services.
   - **Resilience:** Isolate failures to prevent system-wide crashes.
   - **Faster Development and Deployment:** Enable parallel development by independent teams.

- **Challenges**
   - **Complexity:** Higher operational complexity compared to monolithic systems.
   - **Data Management:** Handling data consistency across services.
   - **Communication Overhead:** Increased network latency and potential communication failures.
   - **Monitoring and Debugging:** Requires robust tools for tracking service health and performance.

### 4. Explain Resilience patterns? Explain circuit breaker with Spring Cloud Hystrix code example.
- Resilience patterns help maintain the stability and availability of microservices even when failures occur. These patterns enable the system to handle faults gracefully and recover without significant service degradation.
   - **Circuit Breaker:** Prevents a service from making repeated requests to a failing service.
   - **Retry:** Automatically reattempts failed operations.
   - **Bulkhead:** Isolates resources for different parts of the system to prevent cascading failures.
   - **Fallback:** Provides alternative responses when a service call fails.
   - **Timeout:** Limits the time a service waits for a response from another service.
   - **Rate Limiting:** Controls the number of requests a service can handle to avoid overload.

**Circuit Breaker Pattern with Spring Cloud Hystrix**
- The Circuit Breaker pattern **prevents (overload)** a service from continually trying to contact a failing service, allowing it **time to recover**, and improve **overall sysem stability**.
   - **Closed State:** Normal operations, all requests go through.
   - **Open State:** Requests are blocked for a defined period.
   - **Half-Open State:** A few requests are allowed to test if the service has recovered.

   ```java
   import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   import org.springframework.web.client.RestTemplate;
   
   @Service
   public class UserService {
   
       @Autowired
       private RestTemplate restTemplate;
   
       @HystrixCommand(fallbackMethod = "getDefaultUser")
       public String getUserInfo(String userId) {
           String url = "http://user-service/users/" + userId;
           return restTemplate.getForObject(url, String.class);
       }
   
       public String getDefaultUser(String userId) {
           return "Default User Information for " + userId;
       }
   }
   ```

   ```yaml
   // application configuration
   hystrix:
     command:
       default:
         execution:
           timeout:
             enabled: true
             isolation:
               thread:
                 timeoutInMilliseconds: 2000
   ```

### 5. Explain load balancing algorithms.
- Load balancing algorithms determine **how incoming network traffic is distributed across multiple servers** to ensure efficient resource use, minimize response times, and prevent server overload. 

**1. Round Robin**: Requests are distributed sequentially to each server in the pool, looping back to the first server after reaching the last. Best suited for environments where all servers have similar capabilities.  (servers of varying performance capabilities => weighted RR. )
   - O Simple and easy to implement.  
   - X Inefficient for servers with different processing capabilities.

**2. Least Connections**: Routes requests to the server with the fewest active connections. Suitable for environments with long-lived connections (e.g., database servers). 
   - O Efficient for handling uneven traffic loads. 
   - X May lead to delays if connection counts don't quickly reflect actual server load.

**3. Least Response Time**: Sends requests to the server with the lowest response time. Ideal for dynamic environments where server loads fluctuate.  
   - O Faster request handling.  
   - X Needs constant monitoring of server response times.

**4. IP Hash**: Hashes the client's IP address to determine which server handles the request. Suitable for applications requiring session persistence.  (also Random)
   - O Ensures that the same client connects to the same server. 
   - X Poor distribution if the hash function is not well-designed.

**5. Geographic Load Balancing (Geo-Location)**:  Directs requests to servers based on the geographic location of the client. Ideal for globally distributed applications to reduce latency.  
   - O Improved response times by serving clients from the nearest server. 
   - X Requires accurate geographic data.

### 6. Explain API Gateway.
- An **API Gateway** is a server that acts as a single entry point for external and internal clients to access the backend services of an application. It manages and orchestrates API requests by routing them to appropriate microservices, handling security, load balancing, and response aggregation.  

- Without an API Gateway, clients would need to directly communicate with multiple services, which can lead to complex client logic, security vulnerabilities, and inefficient API calls.
   - **Open Source:** Kong, NGINX, Traefik, Apache APISIX  
   - **Cloud-Based:** AWS API Gateway, Azure API Management, Google Cloud API Gateway  
   - **Frameworks:** Netflix Zuul, Spring Cloud Gateway  

**Benefits** 
   - **Simplified Client Communication:** Clients interact with a single endpoint instead of multiple services.  
   - **Enhanced Security:** Centralized authentication and request filtering.  
   - **Improved Performance:** Load balancing and response aggregation reduce latency.  
   - **Scalability:** Handles traffic routing and service scaling.  
   - **Service Versioning:** Manage and expose different API versions seamlessly.  

**Challenges**  
   - **Single Point of Failure:** If not properly designed, the API Gateway can become a bottleneck.  
   - **Increased Complexity:** Requires careful design and maintenance.  
   - **Performance Overhead:** Can introduce additional latency if not optimized.  

### 7. Explain service discovery and service registry
- In a microservices architecture, services need a way to locate and communicate with one another.

- **Service Registry** is a database or directory where services register themselves when they start up and deregister when they shut down. It keeps track of all active service instances, their locations (IP addresses, ports), and metadata. e.g. Netflix Eureka, Consul, Apache Zookeeper, AWS Cloud Map

- **Service Discovery** is the process by which services locate each other at runtime by querying the Service Registry. It eliminates the need to hardcode service locations, making applications more flexible and scalable.
   - **Client-Side Discovery:** The client directly queries the Service Registry to get the location of available services. e.g. Netflix Eureka

   - **Server-Side Discovery:** A load balancer or API Gateway queries the Service Registry and routes the request to an appropriate service instance. e.g. AWS Elastic Load Balancing (ELB)

### 8. List Spring Cloud Modules that serve as Microservice components (e.g. Euerka for Service Discovery)
   | **Core Component**                    | **Description**                                              | **Spring Cloud Module / Tools**                              |
   | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | **API Gateway**                       | Unified entry point for routing, filtering, and load balancing. | Spring Cloud Gateway, Netflix Zuul (deprecated)              |
   | **Service Registry**                  | Maintains service details for dynamic discovery.             | Netflix Eureka, Spring Cloud Consul, Spring Cloud Zookeeper  |
   | **Service Layer**                     | Microservices handling specific business functions.          | Spring Boot                                                  |
   | **Authorization Server**              | Manages identity and access control for secure communication. | Spring Security OAuth2, Spring Cloud Security, Keycloak, Azure AD |
   | **Data Storage**                      | Stores application data generated by services.               | PostgreSQL, MySQL, MongoDB, Cassandra                        |
   | **Distributed Caching**               | Boosts application performance by caching frequently accessed data. | Spring Data Redis, Spring Cache, Couchbase, Memcached        |
   | **Async Microservices Communication** | Enables asynchronous communication between services.         | Spring Cloud Stream, Spring Cloud Bus                        |
   | **Metrics Visualization**             | Collects and visualizes system performance metrics.          | Micrometer, Prometheus, Grafana                              |
   | **Log Aggregation and Visualization** | Aggregates and visualizes logs from services.                | Logstash, Elasticsearch, Kibana                              |

### 9. Walk through https://microservices.io/patterns/index.html