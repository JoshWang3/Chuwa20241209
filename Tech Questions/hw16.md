### HW16 Microservices

#### 1. list all of the new annotations you learned to your annotations.md


#### 2. Explain monolithic architecture, service oriented architecture and Micro service architecture.
```
Monolithic Architecture:
Monolithic architecture is the traditional unified model for software design.
It is simple, all-in-one, but not scalable for large systems.
	Key characteristics are:
	Single codebase executing multiple business functions
	Self-contained and independent from other applications
	Single database, often using a relational database management system
	Tightly coupled components
If one component needs updating, 
it requires rewriting other elements and recompiling the entire application.

Service-Oriented Architecture (SOA):
SOA is a design paradigm focusing on building functional, scalable software systems from individual components called services.
It is modular and reusable, but can be complex due to middleware.

Key features are:
	Loose coupling across the entire project
	Interoperability between diverse systems and technologies
	Services are self-contained and can be accessed over a network
	Often includes an API gateway for communication between services
SOA is particularly useful for system integration and can be composed of other services.

Microservices Architecture:
Microservices architecture is a design pattern where an application is developed as a collection of small, 
independent services11. 
It is highly scalable and flexible, but requires careful management of distributed systems.

Key features are:
	Each microservice performs a specific, limited-scope task
	Services are loosely coupled and can be deployed independently
	Each service often has its own database
	Typically uses lightweight messaging systems for data handoff between services
It is used to speed up application development and is well-suited for cloud-native applications

SOA tends to be more coarse-grained and centralized, while Microservices are typically more fine-grained and decentralized.
```

#### 3. Document the microservice architeture and core components

```
Microservices architecture is an approach to building server applications as a set of small, independent services. Each service runs in its own process, communicates via lightweight protocols, and can be deployed independently. 
The core components are:

API Gateway
	Serves as the entry point for clients, routing requests to appropriate services and handling cross-cutting concerns like authentication and SSL termination.
	
Service Registry/Discovery
	Maintains a list of available service instances, allowing other components to locate and communicate with services dynamically.
	
Service Layer
	Comprises individual microservices, each implementing a specific business capability within a bounded context.
	
Authorization Server
	Manages identity and access control, securing microservices.
	
Data Storage
	Each service typically manages its own data storage, which can use different technologies (SQL, NoSQL) as needed.
	
Management/Orchestration
	Responsible for service placement, failure identification, and load balancing across nodes, often implemented using technologies like Kubernetes.
	
Distributed Caching
	Improves performance by caching frequently accessed data.

Messaging System
	Facilitates communication between services, often using asynchronous messaging protocols.

Monitoring and Logging
	Provides observability into the distributed system, tracking health, performance, and issues across services.

This architecture allows for better scalability, resilience, and faster development cycles, as teams can work on individual services independently.


```

#### 4. Explain Resilience patterns? Explain circuit breaker with Spring Cloud Hystrix code example.

```
Resilience patterns are design strategies used to build systems that can handle failures gracefully, recover quickly, and maintain functionality even under adverse conditions. These patterns are critical in distributed systems where failures are inevitable due to network issues, service unavailability, or high latency.
Some common resilience patterns are:
	Circuit Breaker: 
		Prevents a system from making repeated requests to a failing service.
	Retry: 
		Automatically retries a failed operation with the hope that the issue is transient.
	Fallback: 
		Provides an alternative response or behavior when a service fails.
	Bulkhead: 
		Isolates resources to prevent a failure in one part of the system from affecting others.
	Timeout: 
		Limits the time a system waits for a response before considering the operation failed.

Circuit Breaker Pattern:
	It monitors for failures.
	If the failures exceed a threshold, the circuit breaker "trips" and stops further requests to the failing service for a specified period. 
	This prevents cascading failures and gives the failing service time to recover. 

States of a Circuit Breaker are closed, open, half-open.

Advantages of Circuit Breaker are:
	Prevents cascading failures by stopping requests to a failing service.
	Provides fallback mechanisms to maintain system functionality.
	Improves system resilience and fault tolerance.	

Example of implementing a Circuit Breaker using Spring Cloud Hystrix:

import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ExampleService {

    private final RestTemplate restTemplate;

    public ExampleService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @HystrixCommand(fallbackMethod = "fallbackMethod")
    public String callExternalService() {
        return restTemplate.getForObject("http://example-service/api/data", String.class);
    }

    public String fallbackMethod() {
        return "Fallback response due to service unavailability";
    }
}
@HystrixCommand is used to wrap the callExternalService method with a circuit breaker.

It needs configurations:

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>

@SpringBootApplication
@EnableCircuitBreaker
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

#### 5. Explain load balancing algorithms.

```
Load balancing algorithms are methods used to distribute incoming network traffic across multiple servers to ensure optimal resource utilization, maximize throughput, minimize response time, and avoid overloading any single server. 
The main types of load balancing algorithms are:

Static Algorithms
	Round Robin: 
		Distributes requests sequentially among servers in a rotating order.
	Weighted Round Robin: 
		Assigns weights to servers based on their capacity, distributing more requests to higher-weighted servers.		
	Random: 
		Randomly selects a server for each incoming request.
	Source IP Hash: 
		Uses the client's IP address to determine which server receives the request.

Dynamic Algorithms
	Least Connections: 
		Directs traffic to the server with the fewest active connections.
	Weighted Least Connections: 
		Combines server weights with the least connections approach.
	Least Bandwidth: 
		Routes requests to the server consuming the least amount of bandwidth.
	Resource-Based: 
		Assigns requests based on real-time server resource availability (CPU, memory, network).

Dynamic algorithms generally provide better load distribution but may have higher overhead compared to static algorithms
```

#### 6. Explain API Gateway.

```
An API Gateway is a software layer that acts as a single entry point for client requests to access multiple backend services or microservices. 
It serves as a reverse proxy, routing incoming requests to the appropriate services and aggregating responsesã€‚

Its functions are:
	Request routing: 
		Directs client requests to the appropriate backend services.
	Security: 
		Handles authentication, authorization, and threat protection.
	Traffic management: 
		Implements load balancing, caching, and rate limiting.
	Protocol translation: 
		Converts between different protocols as needed.
	Request/response transformation: 
		Modifies requests and responses to ensure compatibility.
	Monitoring and analytics: 
		Provides insights into API usage and performance.

It is useful in microservices architectures. 
It manages the complexity of multiple services and provide a unified interface for clients.
They simplify API management by centralizing cross-cutting concerns, 
allowing individual microservices to focus on their core business logic.

Advantages of Using an API Gateway
	Centralized management of APIs.
	Improved security and performance.
	Simplified client-side development.
	Scalability and fault tolerance.

Disadvantages of Using an API Gateway
	Can become a single point of failure.
	Adds latency due to additional processing.
	Requires careful configuration and maintenance.

 It simplifies client-server communication, enhances performance, 
 and provides essential features like authentication, rate limiting, and load balancing.
 ```

#### 7. Explain service discovery and service registry

```
Service discovery and service registry are critical components that enable services to dynamically locate and communicate with each other. 

Key aspects of service discovery are:
	Automatic detection of services and their network locations
	Minimizing configuration efforts for administrators
	Enabling efficient communication between services in dynamic environments

A service registry is a centralized database that maintains information about available service instances 
within a microservices architecture. 
It serves as a single source of truth for service locations and metadata.

Functions of a service registry:
	Stores network locations of service instances
	Provides up-to-date information on available services
	Enables service lookup and load balancing

Service discovery relies on the service registry to function effectively.

Service Registration: 
	New service instances register themselves with the registry
Service Lookup: 
	Clients query the registry to find available service instances
Load Balancing: 
	Distributes requests across multiple instances of a service.

Service discovery and service registry can help microservices architectures maintain flexibility, scalability, and resilience in dynamic environments.
```

#### 8. List Spring Cloud Modules that serve as Microservice components (e.g. Euerka for Service Discovery)

```
The key Spring Cloud modules that serve as microservice components are:

	Eureka: 
		Service registration and discovery
	Config Server: 
		Centralized, versioned configuration management
	Spring Cloud Gateway: 
		API Gateway for routing and filtering requests
	Ribbon: 
		Client-side load balancing
	Feign: 
		Declarative REST client for service-to-service calls
	Hystrix: 
		Circuit breaker for fault tolerance
	Spring Cloud Bus: 
		Dynamic configuration updates across multiple instances
	Spring Cloud OpenFeign: 
		Declarative REST client with built-in support for service discovery
```

#### 9. Walk through https://microservices.io/patterns/index.html