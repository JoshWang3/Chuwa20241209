### 1. list all of the new annotations you learned to your annotations.md

### 2. Explain monolithic architecture, service oriented architecture and Micro service architecture.

---

### Monolithic Architecture

- The entire application is built as **one single unit**.
- All components (UI, business logic, data access) are **tightly coupled** and deployed together.
- A change in one part often requires **redeploying the whole app**.

**Pros**:

- Simple to develop initially
- Easy to test in small-scale projects

**Cons**:

- Hard to scale and maintain
- Slow development as the codebase grows

---

### Service-Oriented Architecture (SOA)

- The application is divided into **modular services**, each responsible for a specific business function.
- Services are **moderately coupled** and communicate through a central **Enterprise Service Bus (ESB)**.

**Pros**:

- Better scalability than monoliths
- Reusability of services across apps

**Cons**:

- Complex configuration and dependency on ESB
- Still has some tight coupling and slower evolution

---

### Microservice Architecture

- The application is split into **very small, loosely coupled services**, each with its **own database and deployment**.
- Services communicate via lightweight protocols (like REST or messaging).

**Pros**:

- Highly scalable and fault-tolerant
- Enables **rapid and independent development**
- Easier to adopt CI/CD and deploy updates quickly

**Cons**:

- More operational complexity (e.g., monitoring, networking)
- Requires strong DevOps and service coordination

---

### 3. Document the microservice architeture and core components

#### 1. **Microservices**

- Self-contained units that perform one business function.
- Can be developed, deployed, and scaled independently.

**Example**: A user service, payment service, and order service in an e-commerce app.

---

#### 2. **API Gateway**

- Acts as a **single entry point** for all client requests.
- Handles **routing**, **authentication**, **rate limiting**, and **protocol translation**.

**Example**: Routes `/users/**` requests to the user service.

---

#### 3. **Service Registry and Discovery**

- Maintains a dynamic list of available microservices.
- Helps services discover each other without hardcoding addresses.

**Example Tools**: Netflix Eureka, Consul

---

#### 4. **Load Balancer**

- Distributes client requests evenly across available service instances.
- Prevents any single service from being overwhelmed.

**Example Tools**: Nginx, Spring Cloud LoadBalancer

---

#### 5. **Containerization**

- Packages each microservice along with its dependencies.
- Ensures consistent environments from development to production.

**Example Tools**: Docker, Podman

---

#### 6. **Orchestration**

- Manages deployment, scaling, and health of containers.

**Example Tools**: Kubernetes, Docker Swarm

---

#### 7. **Event Bus / Message Broker**

- Enables **asynchronous communication** between services.
- Supports decoupling through publish/subscribe or message queues.

**Example Tools**: RabbitMQ, Kafka

---

#### 8. **Database per Microservice**

- Each microservice owns and manages its own data.
- Promotes **data isolation** and **independent scalability**.

**Benefit**: Prevents cross-service data dependencies.

---

#### 9. **Caching**

- Temporarily stores frequently accessed data near the service.
- Improves performance by **reducing database load** and **response time**.

**Example Tools**: Redis, Memcached

---

#### 10. **Fault Tolerance and Resilience**

- Ensures the system remains stable even if individual services fail.
- Uses **circuit breakers**, **retries**, and **fallbacks** to handle errors gracefully.

**Example Tools**: Resilience4j, Hystrix

---

### 4. Explain Resilience patterns? Explain circuit breaker with Spring Cloud Hystrix code example.

---

### Common Resilience Patterns:

1. **Circuit Breaker** – Prevents repeated calls to a failing service.
2. **Retry** – Automatically retries failed requests a limited number of times.
3. **Timeout** – Stops waiting for a response after a specified time.
4. **Fallback** – Provides an alternative response when the primary service fails.
5. **Bulkhead** – Isolates resources for different services to prevent cascading failures.
6. **Rate Limiter** – Limits the number of requests to prevent overloading.

---

### Circuit Breaker Explained

A **circuit breaker** monitors external service calls. If failures exceed a certain threshold, the circuit "opens" to **stop further calls** for a time. After a cool-down period, it tries again to see if the service is healthy.

---

### Circuit Breaker with Spring Cloud Hystrix

```java
@SpringBootApplication
@EnableCircuitBreaker
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
```

```java
@Service
public class ProductService {

    @HystrixCommand(fallbackMethod = "defaultProductList")
    public List<String> getProductList() {
        // Simulate a failure or slow response
        throw new RuntimeException("Service Down");
    }

    public List<String> defaultProductList() {
        return Arrays.asList("Fallback Product 1", "Fallback Product 2");
    }
}
```

- If `getProductList()` fails, Hystrix automatically calls `defaultProductList()` as a fallback.
- Hystrix monitors failures and will **open the circuit** if too many occur in a short time.

---

### 5. Explain load balancing algorithms.

---

### What is Load Balancing?

A **load balancer** is a software or hardware component that **distributes incoming traffic** across multiple servers to prevent any single server from being overwhelmed. It ensures **high availability**, **scalability**, and **reliability**.

The **load balancing algorithm** is the rule or logic used by the load balancer to decide **which server should handle each request**.

---

### Types of Load Balancing:

#### 1. **Static Load Balancing**

- Uses predefined rules without checking real-time server conditions.
- Simple, but may lead to unequal distribution if server loads differ.

**Examples**:

- **Round Robin**: Requests are sent to servers one by one in order.
- **IP Hashing**: Uses a hash of the client’s IP to consistently route traffic to the same server.

#### 2. **Dynamic Load Balancing**

- Considers the **current state** of each server (e.g., CPU usage, number of active connections) to make smart decisions.
- More efficient but requires monitoring and can add complexity.

**Examples**:

- **Least Connections**: Sends traffic to the server with the fewest active connections.
- **Least Response Time**: Picks the server that responds the fastest.
- **Resource-Based**: Routes based on CPU, memory, or custom metrics.

---

### 6. Explain API Gateway.

An **API Gateway** is a server that acts as a **single entry point** for all client requests in a microservices architecture. It manages and routes incoming API calls to the appropriate backend services.

### 7. Explain service discovery and service registry

- **Service Discovery** is the process that allows microservices to **automatically find and communicate** with each other without needing to hardcode their IP addresses or ports.

In dynamic environments (like containers or cloud platforms), service instances may frequently change due to scaling or failure. Service discovery ensures that services can still locate one another reliably.

- A **Service Registry** is a centralized system or database that keeps track of **available service instances**, including their IP addresses and ports.

### 8. List Spring Cloud Modules that serve as Microservice components (e.g. Euerka for Service Discovery)

Spring Cloud provides a set of tools and modules to help build robust microservices. Each module supports a specific component in the microservice ecosystem.

---

### Key Spring Cloud Modules:

| Module                          | Purpose                                                          |
| ------------------------------- | ---------------------------------------------------------------- |
| **Spring Cloud Eureka**         | **Service Discovery** and registration (using Netflix Eureka)    |
| **Spring Cloud Gateway**        | **API Gateway** for routing, filtering, and securing APIs        |
| **Spring Cloud Config**         | **Centralized Configuration Management** for all services        |
| **Spring Cloud OpenFeign**      | Declarative **REST Client** for inter-service communication      |
| **Spring Cloud LoadBalancer**   | Client-side **Load Balancing** (alternative to Ribbon)           |
| **Spring Cloud CircuitBreaker** | Implements **resilience patterns** like circuit breakers         |
| **Spring Cloud Sleuth**         | **Distributed Tracing** to track request flow across services    |
| **Spring Cloud Zipkin**         | Works with Sleuth for **visualizing trace data**                 |
| **Spring Cloud Bus**            | **Broadcasts config changes/events** using a message broker      |
| **Spring Cloud Stream**         | Messaging framework for building **event-driven services**       |
| **Spring Cloud Security**       | Integrates with OAuth2 for **secure microservice communication** |

---

### 9. Walk through https://microservices.io/patterns/index.html
