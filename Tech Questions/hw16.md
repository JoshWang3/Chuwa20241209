# Homework 16

## 2. Explain monolithic architecture, service oriented architecture and Micro service architecture.
### Monolithic Architecture
- **Single Codebase**: All components (UI, business logic, data access) are tightly integrated into one application.
- **Pros**: Simple to develop, test, deploy, and scale initially.
- **Cons**: Becomes complex as the app grows; scaling requires replicating the entire app.

### Service-Oriented Architecture (SOA)
- **Reusable Services**: Components are modular, reusable services communicating via network protocols (e.g., SOAP/ESB).
- **Pros**: Promotes interoperability, reuse, and easier maintenance.
- **Cons**: Centralized ESB can become a bottleneck; complex governance.

### Microservice Architecture
- **Decentralized Services**: Small, independent services with own data/stacks, communicating via APIs (e.g., REST).
- **Pros**: High scalability, flexibility in tech stack, fault isolation.
- **Cons**: Operational complexity (monitoring, deployment), network latency.
  
### Key Differences
- **Scope**: Monolithic (single app), SOA (enterprise-wide services), Microservices (fine-grained, app-specific services).
- **Coupling**: Monolithic (tight), SOA/ Microservices (loose).
- **Communication**: SOA (ESB), Microservices (lightweight APIs).



## 3. Document the microservice architeture and core components。
### Microservice Architecture
- **Structure**: Decentralized, small, independent services with bounded contexts, each handling a specific business capability.
- **Characteristics**: 
  - **Autonomy**: Own codebase, data storage, and tech stack.
  - **APIs**: Communicate via lightweight protocols (REST, gRPC, messaging).
  - **Resilience**: Fault isolation; failures in one service don’t cascade.

### Core Components
1. **API Gateway**: Entry point for clients; handles routing, authentication, and load balancing.
2. **Service Registry/Discovery**: Tracks service instances (e.g., Netflix Eureka, Consul).
3. **Configuration Management**: Centralized config storage (e.g., Spring Cloud Config).
4. **Communication**: 
   - **Synchronous**: REST/HTTP, gRPC.
   - **Asynchronous**: Message brokers (Kafka, RabbitMQ).
5. **Centralized Monitoring**: Logging (ELK Stack), metrics (Prometheus/Grafana), tracing (Zipkin).
6. **Circuit Breakers**: Prevent cascading failures (e.g., Resilience4j, Hystrix).
7. **Containerization/Orchestration**: Docker for packaging, Kubernetes for deployment/scaling.
8. **CI/CD Pipeline**: Automated testing, building, and deployment (e.g., Jenkins, GitLab CI).
9. **Security**: OAuth2/JWT for auth, API gateways for rate limiting/encryption.



## 4. Explain Resilience patterns? Explain circuit breaker with Spring Cloud Hystrix code example.
### Resilience Patterns
Strategies to ensure system stability during failures:
- **Retry**: Automatically reattempt failed operations.
- **Circuit Breaker**: Block requests temporarily after failure thresholds.
- **Bulkhead**: Isolate resources to prevent cascading failures.
- **Fallback**: Provide default response when primary logic fails.
- **Rate Limiter**: Control request frequency to avoid overload.

---

### Circuit Breaker Pattern
Monitors failures and "opens" the circuit to block requests temporarily, allowing recovery. States:
1. **Closed**: Requests flow normally.
2. **Open**: Requests fail immediately (after threshold breaches).
3. **Half-Open**: Limited requests allowed to test recovery.

---

### Spring Cloud Hystrix Example
```java
// Enable Circuit Breaker in Spring Boot app
@SpringBootApplication
@EnableCircuitBreaker
public class MyApp { 
  public static void main(String[] args) { 
    SpringApplication.run(MyApp.class, args); 
  }
}

// Service with circuit breaker
@Service
public class UserService {

  @HystrixCommand(
    fallbackMethod = "getFallbackUser", 
    commandProperties = {
      @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "5"),
      @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "5000")
    }
  )
  public String getUser(String userId) {
    // Simulate failure (e.g., external API call)
    throw new RuntimeException("Service down");
  }

  // Fallback method
  public String getFallbackUser(String userId) {
    return "Fallback User Data";
  }
}
```

## 5. Explain load balancing algorithms.
### Load Balancing Algorithms
- **Round Robin**: Distributes requests sequentially across servers in a rotation.
- **Least Connections**: Routes traffic to the server with the fewest active connections.
- **Weighted Round Robin/Least Connections**: Assigns weights to servers (based on capacity) to prioritize traffic distribution.
- **IP Hash**: Uses client IP to map requests to a specific server (ensures session consistency).
- **Least Response Time**: Selects the server with the lowest latency/response time.
- **Resource-Based**: Directs traffic based on server resource utilization (CPU, memory).
  
### Use Cases
- **Static Traffic**: Round Robin, Weighted.
- **Session Persistence**: IP Hash.
- **Dynamic Load**: Least Connections, Resource-Based.

## 6. Explain API Gateway.
### API Gateway
- **Role**: Single entry point for client requests to backend services (microservices, APIs).
- **Key Functions**:
  - **Routing**: Directs requests to appropriate services.
  - **Auth/SSL**: Handles authentication, authorization, and encryption.
  - **Rate Limiting**: Enforces request quotas to prevent overload.
  - **Load Balancing**: Distributes traffic across service instances.
  - **Monitoring**: Tracks metrics, logs, and errors.
  - **Request Transformation**: Modifies requests/responses (e.g., headers, protocols).
- **Benefits**: Simplifies client-side integration, centralizes cross-cutting concerns.

## 7. Explain service discovery and service registry.
### Service Registry
- **Database**: Stores network locations (IP, port) of available service instances.
- **Dynamic Updates**: Services register/deregister on startup/shutdown (self-registration or via agent).

### Service Discovery
- **Mechanism**: Clients or routers query the registry to locate healthy service instances.
- **Types**:
  - **Client-Side**: Client fetches instances directly from the registry (e.g., Netflix Eureka).
  - **Server-Side**: Load balancer (e.g., API Gateway) handles discovery.

### Benefits
- Enables dynamic scaling, fault tolerance, and reduces manual config. 


## 8. List Spring Cloud Modules that serve as Microservice components (e.g. Euerka for Service Discovery)
### Spring Cloud Modules for Microservices
1. **Eureka**: Service discovery (server/client registration).
2. **Spring Cloud Config**: Centralized configuration management.
3. **Spring Cloud Gateway**: API Gateway (routing, filtering, security).
4. **Spring Cloud LoadBalancer**: Client-side load balancing.
5. **Hystrix (legacy)/Resilience4J**: Circuit breaker for fault tolerance.
6. **Spring Cloud Sleuth + Zipkin**: Distributed tracing.
7. **Spring Cloud Security**: OAuth2, JWT integration.
8. **OpenFeign**: Declarative REST client for service communication.
9. **Spring Cloud Stream**: Event-driven messaging (Kafka, RabbitMQ).
10. **Spring Cloud Bus**: Config refresh propagation via messaging.


































