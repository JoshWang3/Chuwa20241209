\2. Explain monolithic architecture, service oriented architecture and Micro service architecture.  

```
Monolithic Architecture: 
A single unified application where all components (UI, business logic, database) are tightly coupled. Simple but hard to scale and maintain.

Service-Oriented Architecture (SOA): 
Applications are split into loosely coupled services that communicate via an Enterprise Service Bus (ESB). Improves modularity but has performance overhead.

Microservices Architecture: 
Breaks applications into small, independently deployable services, each with its own database and API. Improves scalability, resilience, and deployment flexibility.

```

\3. Document the microservice architeture and core components  

```
API Gateway: 
Manages requests, authentication, and load balancing.

Service Discovery: 
Dynamically finds available services (e.g., Eureka).

Service Registry: 
Keeps track of available services (e.g., Consul, Eureka).

Load Balancer: 
Distributes traffic across services (e.g., Ribbon).

Configuration Management: 
Centralized configuration storage (e.g., Spring Cloud Config).

Fault Tolerance: 
Handles failures gracefully (e.g., Hystrix, Resilience4j).

Logging & Monitoring: 
Tracks service performance (e.g., Zipkin, ELK Stack).
```

\4. Explain Resilience patterns? Explain circuit breaker with Spring Cloud Hystrix code example  

```
Resilience patterns: Retry, Circuit Breaker, Bulkhead, Fallback
Re-attempt failed requests.
Prevents repeated failures by blocking calls to a failing service.
Isolates failures in a subset of the system.
Provides an alternative response when failure occurs.
```

```java
@HystrixCommand(fallbackMethod = "fallbackResponse")
public String callExternalService() {
    return restTemplate.getForObject("http://api/", String.class);
}

public String fallbackResponse() {
    return "the service being called failed to respond";
}
```

\5. Explain load balancing algorithms.  

```
Round Robin: 
Requests are evenly distributed across servers.

Least Connections: 
Routes traffic to the server with the fewest active connections.

Random: 
Chooses a server randomly.

IP Hashing: 
Routes requests from the same client IP to the same server.

Weighted Round Robin: 
Distributes requests based on server weight.
```

\6. Explain API Gateway.  

```
acts as an entry point for client requests, include functionality:

Routing & Load Balancing (Zuul, Spring Cloud Gateway)
Authentication & Authorization (JWT, OAuth)
Rate Limiting & Throttling
Request/Response Transformation
```

\7. Explain service discovery and service registry  

```java
Service Discovery: Dynamically locates services within a microservices system.
Service Registry: Stores and maintains service instances for discovery.
    
@EnableEurekaClient
@SpringBootApplication
public class MyServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyServiceApplication.class, args);
    }
}
```

\8. List Spring Cloud Modules that serve as Microservice components (e.g. Euerka for Service Discovery)  

```
Spring Cloud Eureka – Service Discovery
Spring Cloud Config – Centralized Configuration Management
Spring Cloud Gateway – API Gateway
Spring Cloud Ribbon – Client-Side Load Balancing
Spring Cloud Hystrix – Circuit Breaker & Fault Tolerance
Spring Cloud Sleuth – Distributed Tracing
Spring Cloud Zipkin – Request Tracing
Spring Cloud Consul – Alternative Service Registry
Spring Cloud Security – Authentication & Authorization
```





