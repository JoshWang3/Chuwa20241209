# HW16
## Questions:

### 1. List all of the annotations you learned from class and homework to annotations.md (your own cheatsheet).
Check annotations.md

### 2. Explain monolithic architecture, service-oriented architecture (SOA), and microservice architecture.
Monolithic Architecture: A single, unified codebase where all components (UI, business logic, and database) are tightly coupled. Deployment is simple but scaling and maintenance become difficult over time.

Service-Oriented Architecture (SOA): Applications are built as interdependent services that communicate via an enterprise service bus (ESB). It improves modularity but often has performance overhead due to complex service communication.

Microservice Architecture: Breaks an application into independent, loosely coupled services that communicate via lightweight APIs (e.g., REST). It enables scalability, flexibility, and independent deployment.

### 3. Document the microservice architecture and core components.
- Service Components: Each microservice handles a specific business function.
- API Gateway: Routes client requests to appropriate microservices.
- Service Discovery: Keeps track of available services (e.g., Eureka).
- Load Balancer: Distributes traffic evenly among instances.
- Configuration Management: Centralized settings for all services (e.g., Spring Cloud Config).
- Resilience & Fault Tolerance: Circuit breakers (e.g., Hystrix) prevent cascading failures.
- Security: OAuth2, JWT for authentication.
- Monitoring & Logging: Tools like Prometheus and ELK Stack for visibility.

### 4. Explain Resilience patterns? Explain circuit breaker with Spring Cloud Hystrix code example.
Resilience Patterns:

- Retry Pattern: Retries failed requests with a delay.
- Timeout Pattern: Limits response wait time.
- Bulkhead Pattern: Isolates failures to specific service components.
- Circuit Breaker Pattern: Prevents overloading a failing service by rejecting requests after a threshold.
```
@RestController
public class MyController {

    @Autowired
    private MyService myService;

    @GetMapping("/fetch")
    @HystrixCommand(fallbackMethod = "fallbackResponse")
    public String fetchData() {
        return myService.getData();
    }

    public String fallbackResponse() {
        return "Service temporarily unavailable, please try later!";
    }
}
```

If getData() fails, the fallbackResponse() method is invoked to prevent the system from crashing.

### 5. Explain load balancing algorithms.
Load balancing distributes traffic across multiple servers or instances. Common algorithms:

- Round Robin: Requests are sent sequentially to each server in a cycle.
- Least Connections: Sends requests to the server with the fewest active connections.
- Weighted Round Robin: Assigns a weight to each server, favoring higher-capacity servers.
- IP Hashing: Directs requests from the same IP to the same server.
- Random Load Balancing: Randomly selects a server for each request.


### 6.  Explain API Gateway.
An API Gateway is a single entry point for handling API requests, responsible for 1. Request Routing 2. Authentication & Security (OAuth, JWT) 3. Rate Limiting & Throttling 4, Load Balancing & Caching  


### 7. Explain service discovery and service registry.
- Service Discovery: Automatically detects services in a distributed system. Ex: @EnableEurekaClient

- Service Registry: A centralized directory of all running services. Ex: @EnableEurekaServer

### 8. List Spring Cloud Modules that serve as Microservice components (e.g., Eureka for Service Discovery).
Spring Cloud Netflix Eureka → Service Discovery
Spring Cloud Gateway → API Gateway
Spring Cloud Config → Centralized Configuration
Spring Cloud Circuit Breaker (Resilience4J, Hystrix) → Fault Tolerance
Spring Cloud Load Balancer (Ribbon, Spring Cloud LoadBalancer) → Load Balancing
Spring Cloud Sleuth & Zipkin → Distributed Tracing
Spring Cloud Kubernetes → Kubernetes Integration

### 9. Walk through https://microservices.io/patterns/index.html
Architectural style: 1. Monolithic 2. Microservice

Cross-cutting concerns: 
1. Microservice chassis: a framework that handles cross-cutting concerns and simplifies the development of services
2. Externalized configuration: externalize all configuration such as database location and credentials
3. Service Template: a template that implements standard cross cutting concerns and is intended to be copied by a developer in order to quickly start developing a new service