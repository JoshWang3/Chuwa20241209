2. 
   1. Monolithic Architecture: A single unified codebase and database where all functionalities are tightly coupled. Easy to develop but difficult to scale and maintain. 
   2. Service-Oriented Architecture (SOA): A modular approach with loosely coupled services communicating via a standardized protocol (e.g., SOAP). Reduces redundancy but has communication overhead. 
   3. Microservice Architecture: Breaks an application into independent services that communicate via lightweight protocols (e.g., REST, gRPC). Enhances scalability and fault tolerance.
3. 
Service Registry & Discovery (Eureka, Consul)
API Gateway (Zuul, Spring Cloud Gateway)
Load Balancer (Ribbon, Kubernetes Load Balancer)
Resilience & Fault Tolerance (Hystrix, Resilience4j)
Distributed Tracing (Zipkin, Sleuth)
Configuration Management (Spring Cloud Config)
Security (OAuth2, JWT)
4. Resilience patterns ensure system stability during failures.
5.
Round Robin – Requests are distributed sequentially.
Least Connections – Routes to the service with the fewest active connections.
IP Hash – Routes requests based on the client's IP.
Random – Randomly selects an instance.
Weighted Round Robin – Assigns different weights to instances.
6. Manages request routing, authentication, load balancing, and caching.
7. 
Service Registry: Maintains a list of available services (Eureka, Consul, Zookeeper).
Service Discovery: Enables services to find and communicate with each other dynamically.
8. 
Eureka – Service discovery
Ribbon – Client-side load balancing
Zuul / Spring Cloud Gateway – API Gateway
Hystrix / Resilience4j – Circuit breaker
Spring Cloud Config – Centralized configuration
Zipkin/Sleuth – Distributed tracing
OAuth2/JWT – Security









