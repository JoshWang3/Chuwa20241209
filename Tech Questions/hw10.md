# Spring Logging Homework

## 1. Is `System.out.print` Thread Safe?

`System.out.print` is thread-safe because it synchronizes access to the underlying output stream. However, while it is thread-safe, its use in multi-threaded environments may still lead to interleaved output due to the lack of higher-level thread coordination.

Here is an example to demonstrate potential interleaved outputs:

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadSafetyDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        Runnable task = () -> {
            for (int i = 0; i < 5; i++) {
                System.out.print(Thread.currentThread().getName() + " ");
            }
        };

        executorService.execute(task);
        executorService.execute(task);
        executorService.execute(task);

        executorService.shutdown();
    }
}
```

**Output:** (may vary)
```
Thread-0 Thread-1 Thread-2 Thread-0 Thread-1 Thread-2
```

The output is interleaved because thread scheduling is not coordinated, even though `System.out.print` itself is thread-safe.

---

## 2. Why Do We NOT Use `System.out.print` for Logging in Spring? Why Use Loggers Like Log4j?

### Reasons to Avoid `System.out.print`:
- **No Logging Levels:** Lacks granularity to differentiate between log types (e.g., info, debug, error).
- **Not Configurable:** Cannot route output to files or external systems easily.
- **No Context Information:** Does not include timestamps, thread names, or other metadata.

### Advantages of Loggers Like Log4j:
- Supports configurable logging levels (e.g., `INFO`, `DEBUG`, `ERROR`).
- Allows log routing to multiple destinations like files, consoles, and remote servers.
- Provides contextual information (timestamp, thread, etc.).
- Optimized for performance in production environments.

---

## 3. If `System.out.print` is Thread-Safe, Is There Any Other Reason We Dislike It?

Yes, even if thread-safe, `System.out.print` lacks:
1. Granularity of logging levels.
2. Configurability for different environments (e.g., dev, staging, production).
3. Performance optimizations like asynchronous logging.

---

## 4. Explain SLF4J Logging Levels and What Is Included in SLF4J Logs

### SLF4J Logging Levels:
1. **TRACE**: Fine-grained, low-level debugging.
2. **DEBUG**: General debugging information.
3. **INFO**: Informational messages (e.g., application startup).
4. **WARN**: Potentially harmful situations.
5. **ERROR**: Severe issues that need attention.

### SLF4J Logs Include:
- Message
- Logging level
- Timestamp
- Thread name (if configured)

---

## 5. Spring Boot Rest Application Demonstrating Multi-threading

### Code Example:
```java
@RestController
public class MyController {

    @GetMapping("/test")
    public String testEndpoint() {
        return "Hello from thread: " + Thread.currentThread().getName();
    }
}
```

### Logs:
```
Thread-2: Handling GET /test
Thread-3: Handling GET /test
```
This demonstrates that Spring Boot handles requests using a thread pool.

---

## 6. Deploy Application as a WAR to External Tomcat Server

### Steps:
1. Modify `pom.xml`:
```xml
<packaging>war</packaging>
```
2. Build the project:
```bash
mvn package
```
3. Copy the WAR file to Tomcat's `webapps` directory.
4. Start Tomcat:
```bash
./catalina.sh start
```
5. Access the application at `http://localhost:8080/{app-name}`.

---

## 7. Global Exception Handler

### Code Example:
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        return new ResponseEntity<>("Error: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### Explanation:
- **`@RestControllerAdvice`**: Applies to all controllers.
- **`@ExceptionHandler`**: Catches exceptions and maps them to HTTP responses.
- Returns a response with a meaningful message and appropriate HTTP status code.

---
