# hw12

---

### 1. Explain circular dependencies scenario in dependency injection with your code, how do we resolve it?

### Scenario

Circular dependencies occur when two or more beans depend on each other directly or indirectly, causing an infinite loop during instantiation. In a dependency injection framework like Spring, this can lead to runtime exceptions.

### Example Code

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
class A {
    private final B b;

    @Autowired
    public A(B b) {
        this.b = b;
    }
}

@Component
class B {
    private final A a;

    @Autowired
    public B(A a) {
        this.a = a;
    }
}
```
In the above code, A depends on B, and B depends on A, leading to a circular dependency issue.


### Solutions
1. Using @Lazy Annotation

Spring allows resolving circular dependencies by delaying the injection until needed.

```java
@Component
class A {
    private final B b;

    @Autowired
    public A(@Lazy B b) {
        this.b = b;
    }
}

```

2. Refactoring Design

Re-evaluate the design and introduce a third class to break the dependency.

```java
@Component
class Mediator {
    private final A a;
    private final B b;

    @Autowired
    public Mediator(A a, B b) {
        this.a = a;
        this.b = b;
    }
}
```

3. Using ObjectFactory or Provider Interface

Inject dependencies lazily with ObjectFactory or Provider.

```java
import org.springframework.beans.factory.ObjectFactory;

@Component
class A {
    private final ObjectFactory<B> bFactory;

    @Autowired
    public A(ObjectFactory<B> bFactory) {
        this.bFactory = bFactory;
    }

    public B getB() {
        return bFactory.getObject();
    }
}
```

4. Constructor to Setter Injection

Convert constructor-based injection to setter-based to allow proxy object creation.

```java
@Component
class A {
    private B b;

    @Autowired
    public void setB(B b) {
        this.b = b;
    }
}

```

5. Using @PostConstruct for Late Initialization

Defer the initialization of dependencies after the bean creation process.

```java
@Component
class A {
    private B b;

    @Autowired
    public A() {}

    @Autowired
    public void setB(B b) {
        this.b = b;
    }
}
```

### 2. Explain tight coupling vs loose coupling and what does Spring IOC do?

### 1. Tight Coupling

**Definition:**  
Tight coupling occurs when components or classes are highly dependent on each other. A change in one class often requires changes in the dependent class, making the system less flexible and harder to maintain.

**Example:**

```java
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine();

    void drive() {
        engine.start();
        System.out.println("Car is moving");
    }
}
```
**Problems with Tight Coupling**:

- Difficult to modify or extend.
- Harder to unit test.
- Low reusability.

### 2. Loose Coupling

**Definition:**  
Loose coupling means components are minimally dependent on each other, usually interacting via abstractions (interfaces). This improves flexibility, scalability, and testability.

**Example:**

```java
interface Engine {
    void start();
}

class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol Engine started");
    }
}

class Car {
    private Engine engine;

    Car(Engine engine) {
        this.engine = engine;
    }

    void drive() {
        engine.start();
        System.out.println("Car is moving");
    }
}
```
**Problems with Loose Coupling**:

- Easier to modify and extend.
- Improved testability (mocking interfaces).
- Higher reusability and flexibility.

### 3. What Does Spring IoC Do?

**Spring Inversion of Control (IoC)**:
Spring IoC helps achieve loose coupling by managing object creation and dependency injection. Instead of creating dependencies manually, Spring injects them automatically based on configuration (XML, annotations, or Java config).

**Key Features of Spring IoC**:

- Dependency Injection (DI): Injecting dependencies via constructor, setter, or field injection.
- Bean Management: Handles the lifecycle of objects (beans).
- Configuration Flexibility: Supports XML, annotations, and Java-based configurations.

**Example Using Spring IoC:**

```java
@Component
class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol Engine started");
    }
}

@Component
class Car {
    private final Engine engine;

    @Autowired
    public Car(Engine engine) {
        this.engine = engine;
    }

    void drive() {
        engine.start();
        System.out.println("Car is moving");
    }
}
```
**Benefits of Spring IoC**:

- Reduces tight coupling.
- Simplifies object creation and dependency management.
- Enhances maintainability and scalability.


### 4. What is MVC pattern?

### MVC Pattern (Model-View-Controller)

The **Model-View-Controller (MVC)** pattern is a software design pattern that separates an application into three interconnected components:

- **Model:** Manages the data and business logic.
- **View:** Handles the presentation layer (UI).
- **Controller:** Acts as an intermediary between Model and View, processing user inputs.

```java
// Model
public class Product {
    private String name;
    private double price;
    // Getters and setters
}

// Controller
@Controller
public class ProductController {
    @GetMapping("/product")
    public String getProduct(Model model) {
        model.addAttribute("product", new Product("Laptop", 1500.0));
        return "productView";
    }
}

// View (productView.html)
<html>
<body>
    <h1>Product: ${product.name}</h1>
    <p>Price: ${product.price}</p>
</body>
</html>
```


### 5. What is Front-Controller?

### Overview

The **Front Controller** pattern is a design pattern used in web applications to provide a centralized entry point for handling all incoming requests. It improves request processing by directing them through a single controller before dispatching to the appropriate handlers.

---

### Key Responsibilities

1. **Centralized Request Handling**
    - All requests go through a single entry point.
    - Simplifies authentication, logging, and request pre-processing.

2. **Request Delegation**
    - Dispatches requests to the appropriate controller or view.

3. **Security and Logging**
    - Allows consistent enforcement of security policies and logging.

---

### How It Works

1. The user sends a request to the web application.
2. The **Front Controller** intercepts the request.
3. The controller processes the request (authentication, logging, etc.).
4. The request is forwarded to the appropriate handler (view or model).

---

### Benefits

- **Centralized Control:** Easier maintenance and consistency.
- **Security:** Centralized access control and logging.
- **Flexibility:** Easily add pre-processing logic.

---

### Example in Java (Servlet-based)

```java
@WebServlet("/*")
public class FrontController extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String path = request.getPathInfo();
        if ("/home".equals(path)) {
            request.getRequestDispatcher("/home.jsp").forward(request, response);
        } else {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }
}
```

Example in Spring MVC
- In Spring, the DispatcherServlet acts as a Front Controller.

```java
@Configuration
public class AppConfig {
    @Bean
    public DispatcherServlet dispatcherServlet() {
        return new DispatcherServlet();
    }
}

```

### 6. Explain DispatcherServlet and how it works, demonstrate the existence of dispatcherServlet in your IDE (JetBrains IntelliJ IDEA)

### Overview

The **DispatcherServlet** is the front controller in Spring MVC that handles all incoming HTTP requests and dispatches them to appropriate handlers (controllers, views, etc.). It acts as a central hub for request processing.

---

### How DispatcherServlet Works

1. **Request Reception:**
    - It intercepts all incoming requests based on URL patterns (e.g., `/` or `*.do`).

2. **Handler Mapping:**
    - Determines which controller should handle the request using `HandlerMapping`.

3. **Controller Execution:**
    - Calls the appropriate controller method and processes the request.

4. **View Resolution:**
    - Determines the view to render based on the controller's return value via `ViewResolver`.

5. **Response Generation:**
    - Sends the generated response back to the client.

---

### DispatcherServlet Workflow

1. **Client Request → DispatcherServlet → Handler Mapping → Controller**
2. **Controller → Model and View → View Resolver → Response to Client**

---

### Key Components Involved

1. **HandlerMapping:** Finds the controller based on the request URL.
2. **HandlerAdapter:** Invokes the controller logic.
3. **ViewResolver:** Resolves logical view names to actual views (e.g., JSP, Thymeleaf).
4. **ModelAndView:** Holds model data and view information.

---

### Example Configuration

#### XML-based (web.xml)

```xml
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring-config.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```
---

**Finding DispatcherServlet in IntelliJ IDEA**

To verify the existence of DispatcherServlet in IntelliJ IDEA:

1. Navigate to External Libraries:

- Open the Project Structure (Ctrl + Alt + Shift + S).
- Under Dependencies, search for a spring-webmvc library.
- Expand it and locate DispatcherServlet.class in the package:
org.springframework.web.servlet.

2. Search for Class:

- Use the "Search Everywhere" (Shift + Shift) feature.
- Type DispatcherServlet to locate the class in Spring's source code.


### 7. What is JSP and What is Model And View？

### 1. What is JSP?

**JavaServer Pages (JSP)** is a server-side technology used to create dynamic web pages in Java-based web applications. It allows embedding Java code within HTML to generate content dynamically.

### Key Features:
- Allows mixing HTML with Java code via JSP tags.
- Supports implicit objects (e.g., `request`, `response`).
- Provides tag libraries such as JSP Standard Tag Library (JSTL).
- Supports MVC architecture by acting as a View.

### Example JSP Code:

```jsp
<%@ page language="java" contentType="text/html" %>
<html>
<head><title>Welcome</title></head>
<body>
    <h1>Welcome, ${username}!</h1>
</body>
</html>
```

**Advantages of JSP:**
- Easy to use with HTML.
- Reduces the need for servlets for UI generation.
- Supports reusable components via custom tags.

**Disadvantages of JSP:**
- Hard to maintain when logic is mixed with HTML.
- Slower performance compared to compiled technologies.


### 2. What is ModelAndView?

**ModelAndView is a Spring MVC class that holds both the model data and the logical view name to be resolved.**

**Purpose:**

- Separates business logic (Model) from presentation logic (View).
- Carries data from the controller to the view.


### Example Usage in Spring MVC:

```java
@Controller
public class UserController {

    @GetMapping("/welcome")
    public ModelAndView welcomeUser() {
        ModelAndView mav = new ModelAndView("welcome");
        mav.addObject("username", "John");
        return mav;
    }
}
```
**Explanation:**
- "welcome" is the logical view name (resolved to welcome.jsp).
- addObject("username", "John") adds data to be displayed in the view.

**Key Methods of ModelAndView:**
- setViewName(String viewName): Sets the logical view name.
- addObject(String attributeName, Object attributeValue): Adds data to the model.


### Explain servlet and servlet container, name some servlet implementations and servlet containers other than tomcat

### 1. What is a Servlet?

A **Servlet** is a Java program that runs on a web server or application server and handles HTTP requests and responses. It is used to create dynamic web content by processing client requests and generating responses.

### Key Features of Servlets

- Handles HTTP requests and responses.
- Platform-independent and runs on the server side.
- Supports session management and request dispatching.
- Can interact with databases and other backend systems.

### Example of a Simple Servlet

```java
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getWriter().println("Hello, Servlet!");
    }
}
```

### 2. What is a Servlet Container?

A Servlet Container (also known as a web container) is a part of a web server or application server that manages the lifecycle of servlets, processes requests, and provides necessary services such as:

- Lifecycle Management: Initializes, processes, and destroys servlets.
- Request Handling: Maps incoming requests to the correct servlet.
- Multithreading: Handles concurrent requests efficiently.
- Security: Provides authentication and authorization.
- Session Management: Tracks client sessions.

**Servlet Lifecycle Managed by Container**
1. Initialization (init) – Called once when the servlet is loaded.
2. Service (service) – Handles client requests (GET, POST, etc.).
3. Destruction (destroy) – Cleanup before servlet is unloaded.

3. Servlet Implementations

Servlet implementations provide the classes and interfaces required to develop servlets. Some popular implementations are:

- Apache Tomcat (Most popular)
- Eclipse Jetty
- WildFly (JBoss)
- GlassFish (Jakarta EE reference implementation)
- Resin

4. Servlet Containers Other Than Tomcat

While Tomcat is widely used, other servlet containers include:

- Jetty (by Eclipse Foundation)
   - Lightweight and embeddable.
   - Suitable for microservices and embedded applications.

- WildFly (formerly JBoss AS)
   - Full-featured application server with Java EE support.
   - Provides enterprise features like clustering and messaging.

- GlassFish
  - Reference implementation of Jakarta EE (formerly Java EE).
  - Suitable for enterprise applications.

- Resin
  - High-performance web and application server.
  - Focused on scalability and speed.
















