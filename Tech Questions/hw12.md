# Homework 12

## 2. Explain circular dependencies scenario in dependency injection with your code, how do we resolve it?
- **Scenario**:

  ```java
  public class ServiceA {
      private final ServiceB serviceB;

      @Inject
      public ServiceA(ServiceB serviceB) {
          this.serviceB = serviceB;
      }
  }

  public class ServiceB {
      private final ServiceA serviceA;

      @Inject
      public ServiceB(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
  }

- **Problem**: ServiceA ↔ ServiceB create a circular dependency, causing injection failure.
- **Resolutions**:
  - **Setter Injection**:
    ```java
    public class ServiceA {
        private ServiceB serviceB;

        @Inject
        public ServiceA() {}

        public void setServiceB(ServiceB serviceB) {
            this.serviceB = serviceB;
        }
    }

    public class ServiceB {
        private final ServiceA serviceA;

        @Inject
        public ServiceB(ServiceA serviceA) {
            this.serviceA = serviceA;
        }
    }
    ```
  - **Lazy Injection with @Lazy**:
    ```java
    @Service
    public class ServiceA {
        private final ServiceB serviceB;

        @Autowired
        public ServiceA(@Lazy ServiceB serviceB) {
            this.serviceB = serviceB;
        }
    }

    @Service
    public class ServiceB {
        private final ServiceA serviceA;

        @Autowired
        public ServiceB(ServiceA serviceA) {
            this.serviceA = serviceA;
        }
    }
    ```
  - **Using Provider**:
    ```java
    public class ServiceA {
        private final Provider<ServiceB> serviceBProvider;

        @Inject
        public ServiceA(Provider<ServiceB> serviceBProvider) {
            this.serviceBProvider = serviceBProvider;
        }

        public void useServiceB() {
            ServiceB serviceB = serviceBProvider.get();
            // Use serviceB
        }
    }

    public class ServiceB {
        private final ServiceA serviceA;

        @Inject
        public ServiceB(ServiceA serviceA) {
            this.serviceA = serviceA;
        }
    }
    ```

## 3. Explain tight coupling vs loose coupling and what does Spring IOC do?
**Tight Coupling:**
- **Definition:** Classes directly depend on concrete implementations.
- **Drawbacks:** Hard to maintain, test, and extend.
  

```java
public class ServiceA {
    private ServiceB serviceB = new ServiceB();

    public void execute() {
        serviceB.action();
    }
}
```

**Loose Coupling**

- **Definition:** Classes depend on abstractions (interfaces) rather than concrete classes.

- **Benefits**
  - Enhances flexibility
  - Improves testability
  - Increases maintainability



```java
public interface IServiceB {
    void action();
}

public class ServiceB implements IServiceB {
    public void action() { 
        // Implementation here
    }
}

public class ServiceA {
    private final IServiceB serviceB;

    public ServiceA(IServiceB serviceB) {
        this.serviceB = serviceB;
    }

    public void execute() {
        serviceB.action();
    }
}
```

**Spring IoC (Inversion of Control):**
- **Purpose**: Manages object creation and dependencies, promoting loose coupling.
- **How It Works**: Uses Dependency Injection to supply required dependencies to classes.
- **Benefits**: Simplifies configuration, enhances modularity, and improves testability.


## 4. What is MVC pattern?
**Model-View-Controller (MVC)** is a design pattern that separates an application into three interconnected components:

1. **Model**
   - **Represents:** Data and business logic.
   - **Example:**
     ```java
     public class User {
         private String name;
         private String email;
         
         // Getters and setters
     }
     ```

2. **View**
   - **Represents:** UI components.
   - **Example (Spring MVC with Thymeleaf):**
     ```html
     <!-- userView.html -->
     <html>
     <body>
         <h1>User Information</h1>
         <p>Name: [[${user.name}]]</p>
         <p>Email: [[${user.email}]]</p>
     </body>
     </html>
     ```

3. **Controller**
   - **Handles:** User input and interacts with Model and View.
   - **Example:**
     ```java
     @Controller
     public class UserController {
         
         @GetMapping("/user")
         public String getUser(Model model) {
             User user = new User("John Doe", "john@example.com");
             model.addAttribute("user", user);
             return "userView";
         }
     }
     ```

**Benefits:**
- **Separation of Concerns:** Enhances maintainability and scalability.
- **Parallel Development:** Teams can work on Model, View, and Controller independently.
- **Reusability:** Components can be reused across different parts of the application.

**Flow:**
1. **User interacts** with the **View**.
2. **Controller** processes the input, updates the **Model**.
3. **Model** notifies the **View** to update the UI.

**Spring MVC Example:**
```java
// Model
public class Product {
    private String name;
    private double price;
    // Getters and setters
}

// Controller
@Controller
public class ProductController {
    
    @GetMapping("/product")
    public String getProduct(Model model) {
        Product product = new Product("Laptop", 999.99);
        model.addAttribute("product", product);
        return "productView";
    }
}

// View (productView.html)
<html>
<body>
    <h1>Product Details</h1>
    <p>Name: [[${product.name}]]</p>
    <p>Price: $[[${product.price}]]</p>
</body>
</html>
```

## 5. What is Front-Controller? 

**Definition:**
The **Front Controller** is a design pattern that centralizes request handling through a single handler, improving control and consistency.

**Purpose:**
- Manage and coordinate requests.
- Provide common processing like authentication, logging, etc.
- Delegate to appropriate handlers/controllers.

**Components:**
1. **Front Controller:** Central entry point (e.g., `DispatcherServlet` in Spring).
2. **Handlers/Controllers:** Specific controllers that process requests.
3. **View Resolver:** Determines the view for the response.


## 6. Explain DispatcherServlet and how it works, demonstrate the existence of dispatcherServlet in your IDE (Jetbrain IntelliJIdea)
**Definition:**
`DispatcherServlet` is the **Front Controller** in Spring MVC that handles all incoming HTTP requests and delegates them to appropriate controllers.

**How It Works:**
- **Receive Request:** `DispatcherServlet` intercepts the incoming request.
- **Handler Mapping:** Determines the suitable controller based on URL and annotations.
- **Invoke Controller:** Calls the controller method to process the request.
- **View Resolution:** Selects the view (e.g., JSP, Thymeleaf) to render the response.
- **Render Response:** Sends the rendered view back to the client.
- *Using `web.xml`:*
  ```xml
  <servlet>
      <servlet-name>dispatcher</servlet-name>
      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
      <init-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>/WEB-INF/spring/dispatcher-config.xml</param-value>
      </init-param>
      <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
      <servlet-name>dispatcher</servlet-name>
      <url-pattern>/</url-pattern>
  </servlet-mapping>
  ```

## 7. What is JSP and What is Model And View？
**JSP (JavaServer Pages):**
- **Definition:** A server-side technology for creating dynamic web content.
- **Purpose:** Generates HTML, XML, or other types of responses based on Java code and templates.
  ```jsp
  <!-- userView.jsp -->
  <html>
  <body>
      <h1>User Information</h1>
      <p>Name: ${user.name}</p>
      <p>Email: ${user.email}</p>
  </body>
  </html>
  ```
**Model:**
- **Definition:** Represents the application's data and business logic.
  ```java
  public class User {
      private String name;
      private String email;
      
      // Constructors
      public User(String name, String email) {
          this.name = name;
          this.email = email;
      }

      // Getters and Setters
      public String getName() { return name; }
      public void setName(String name) { this.name = name; }

      public String getEmail() { return email; }
      public void setEmail(String email) { this.email = email; }
  }
  ```

**View:**
- **Definition:** The View is the presentation layer that displays data to the user. It renders the Model's data in a user-friendly format.
  ```jsp
  <!-- userView.jsp -->
  <html>
  <body>
      <h1>User Information</h1>
      <p>Name: ${user.name}</p>
      <p>Email: ${user.email}</p>
  </body>
  </html>
  ```

## 8. Explain servlet and servlet container , name some servlet implementations and servlet containers other than tomcat
**Servlet:**
- **Definition:** A Java class that handles HTTP requests and responses, extending the capabilities of servers.
- **Example:**
  ```java
  import javax.servlet.*;
  import javax.servlet.http.*;
  import java.io.IOException;

  public class HelloServlet extends HttpServlet {
      @Override
      protected void doGet(HttpServletRequest request, HttpServletResponse response)
              throws ServletException, IOException {
          response.setContentType("text/plain");
          response.getWriter().write("Hello, World!");
      }
  }
  ```
**Servlet Containe:r**
- **Definition:** A Servlet Container is a runtime environment that manages the lifecycle, execution, and networking of Java servlets. It handles HTTP requests, initializes servlets, manages concurrency, and ensures proper communication between servlets and clients.

- **Responsibilities:**
  - **Lifecycle Management:** Instantiates, initializes, and destroys servlets.
  - **Request Handling:** Manages the routing of HTTP requests to appropriate servlets.
  - **Concurrency Support:** Handles multiple simultaneous requests efficiently.
  - **Resource Management:** Provides necessary resources and environment for servlets to operate.

**Common Servlet Containers (Other than Tomcat):**

- **Jetty**
   - **Description:** Lightweight and highly embeddable.
   - **Use Case:** Ideal for microservices and embedded applications.

- **WildFly (formerly JBoss)**
   - **Description:** Full-featured Java EE application server.
   - **Use Case:** Suitable for enterprise-level applications requiring comprehensive Java EE support.

- **GlassFish**
   - **Description:** Reference implementation for Java EE.
   - **Use Case:** Supports advanced features like clustering and high availability.

- **Apache TomEE**
   - **Description:** Extends Tomcat with additional Java EE features.
   - **Use Case:** Combines the simplicity of Tomcat with the power of Java EE.

- **Resin**
   - **Description:** High-performance servlet container.
   - **Use Case:** Supports JSP, WebSocket, and other modern web technologies.































