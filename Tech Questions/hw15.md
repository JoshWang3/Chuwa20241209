Testing related:  

```
1. Unit Testing
Tests individual components in isolation.
(Testing a method that calculates discounts in a shopping cart.)

2. Functional Testing
Validates if the application meets functional requirements.
(Checking if the login form accepts valid credentials and rejects incorrect ones.)

3. Integration Testing
Ensures that different modules work together.
(Verifying if an API correctly retrieves data from a database and returns the expected response.)

4. Regression Testing
Ensures new changes don’t break existing functionality.
(After updating the checkout process, testing previous payment flows to confirm they still work.)

5. Smoke Testing
A quick check to ensure basic features work before deeper testing.
(After deploying a new build, verifying if the homepage loads and login works.)

6. Performance Testing
Tests system behavior under load.
(Checking response times of an e-commerce site when 10,000 users browse simultaneously.)

7. A/B Testing
Compares two versions to determine which performs better.
(Showing different UI layouts to users and analyzing which leads to more sign-ups.)

8. User Acceptance Testing
End-users validate if the system meets business needs.
(A finance team tests a new payroll system before full deployment.)
```

Environment related:  

```
1. Development
Used by developers for coding and unit testing.
(Local machines running services with mock data.)

2. QA (Quality Assurance)
Used for functional, integration, and regression testing.
(Automated test suites run here before moving to staging.)

3. Pre-prod/Staging
A replica of production for final testing before release.
(Running UAT with real-like data but not affecting actual customers.)

4. Production
The live environment used by end-users.
(The real e-commerce website where customers place orders.)
```

\2. What is the lifecircle of Junit?  

```java
Setup (@BeforeEach/@BeforeAll) – Initialize test resources.
Execution (@Test) – Run the test method.
Assertion (assertEquals, etc.) – Validate the output.
Teardown (@AfterEach/@AfterAll) – Clean up resources.
```

\3. Explain parameterized testing?  

```java
Parameterized tests run the same test multiple times with different inputs
@ParameterizedTest
@ValueSource(ints = {1, 2, 3})
void testParameterized(int num) {
    assertTrue(num > 0);
}
```

\4. Explain Mockito and PowerMock .  

```
Mockito – Mocks dependencies, stubs methods, and verifies behavior.
PowerMock – Extends Mockito to mock static, final, private methods, and constructors.
```

\5. Compare @Mock and @InjectMock

```java
@Mock – Creates a mock object.
@InjectMocks – Injects @Mock dependencies into the tested class.

@Mock 
private Service service;
@InjectMocks 
private Controller controller; // Injects 'service' into 'controller'

```

\6. Explain stubbing .

```java
//stubbing is for defining mock behavior, telling Mockito what to return when a method is called.

when(mockService.getData()).thenReturn("mockData");
```

\7. what is Mockito ArgumentMatchers

```java
//Allows flexible matching of arguments in mocks: any(), eq(), contains()

when(mockService.getData(anyString())).thenReturn("mockData");
```

\8. Compare @spy and @Mock?

```java
//@Mock – Fully mocks the object, all methods return default values.
//@Spy – Partial mocking, calls real methods unless stubbed.

@Mock 
List<String> mockedList; // All methods return mock values
@Spy 
List<String> spyList = new ArrayList<>(); // Calls real methods

```

\9. Explain Assertion .  

```java
assertEquals(expected, actual);
assertTrue(condition);
assertThrows(Exception.class, () -> methodCall());
//to validate test results
```

