
### hw15 spring test

#### Explain and compare following concepts, provide specific examples when doing comparison:

Testing related:
1. Unit Testing
2. Functional Testing
3. Integration Testing
4. Regression Testing
5. Smoke Testing
6. Performance Testing
7. A/B Testing
8. User Acceptance Testing

Environment related:
1. Development
2. QA (Quality Assurance)
3. Pre-prod/Staging
4. Production

```
Testing Related:

Unit Testing:
	Unit testing involves testing individual components or units of code in isolation to ensure they work as expected. 
	In Java Spring, this means testing individual methods or classes.

	Example: Testing a service method that calculates the sum of two numbers.
	Tools: JUnit, Mockito.

Functional Testing:
	Functional testing checks the functionality of the application against the specified requirements. 
	It ensures that the system behaves as expected from the user's perspective.

	Example: Testing a REST API endpoint to ensure it returns the correct JSON response.
	Tools: Selenium, RestAssured.

Integration Testing:
	Integration testing verifies the interactions between different modules or services. 
	In Spring, this means testing the integration between different layers， such as service and repository.

	Example: Testing the interaction between a service layer and a database repository.
	Tools: Spring Boot Test, TestNG.

Regression Testing:
	Regression testing ensures that new code changes do not adversely affect the existing functionality. 
	It involves re-running previously completed tests.

	Example: After adding a new feature, re-running all unit and integration tests to ensure nothing is broken.
	Tools: JUnit, Selenium.

Smoke Testing:
	Smoke testing is a preliminary test to check the basic functionality of the application. 
	It is often done after a new build to ensure that the critical features are working.

	After deploying a new build, checking if the application starts up and the home page loads.
	Tools: Selenium, Postman.

Performance Testing:
	Performance testing evaluates the system's performance under various conditions, such as load, stress, and scalability.

	Example: Testing how the application handles 1000 concurrent users.
	Tools: JMeter, Gatling.

A/B Testing:
	A/B testing compares two versions of a web page or application to determine which one performs better. It is often used for user experience optimization.
	
	Example: Testing two different layouts of a landing page to see which one results in more user sign-ups.
	Tools: Google Optimize, Optimizely.

User Acceptance Testing (UAT):

	Definition: UAT is the final phase of testing where the end-users validate the application to ensure it meets their requirements and is ready for production.
	
	Example: A group of end-users testing the application in a pre-production environment to ensure it meets their needs.
	Tools: Manual testing, Selenium.

Environment Related：

Development:
	The development environment is where developers write and test code. 
	It is typically isolated from other environments to prevent disruptions.

	Example: A local machine or a shared development server where developers work on new features.
	Tools: IntelliJ IDEA, Eclipse.

QA (Quality Assurance):
	The QA environment is used for testing the application to identify bugs and ensure quality. 
	It mimics the production environment as closely as possible.
	Example: A dedicated server where automated and manual tests are run to validate the application.
	Tools: Jenkins, Selenium.

Pre-prod/Staging:
	The pre-production or staging environment is a replica of the production environment used for final testing before deployment. 
	It ensures that the application behaves as expected in a production-like setting.

	Example: A server that mirrors the production setup where the final round of testing is performed.
	Tools: Docker, Kubernetes.

Production:
	The production environment is where the application is deployed and accessed by end-users. It is the live environment.

	Example: The actual server where the application is hosted and used by customers.
	Tools: AWS, Azure, Google Cloud.

Comparison and Examples:

Unit Testing vs. Integration Testing:
	Unit Testing: 
		Focuses on individual components. 
		Example: Testing a single method in a service class.
	Integration Testing: 
		Focuses on interactions between components. 
		Example: Testing the interaction between a service class and a repository class.

Functional Testing vs. User Acceptance Testing:
	Functional Testing: 
		Ensures the application works as per the requirements. 
		Example: Testing a login feature.
	User Acceptance Testing: 
		Ensures the application meets the end-users' needs. 
		Example: End-users testing the login feature to ensure it meets their expectations.

Development Environment vs. Production Environment:
	Development Environment: 
		Used for coding and initial testing. Example: A developer's local machine.
	Production Environment: 
		The live environment where the application is accessed by users. 
		Example: The server hosting the live application.

```

#### Write unit test using Junit and PowerMock for following code (a static http client method which calls an external public API):
public class HttpClientService{
	private static final Logger log = LoggerFactory.getLogger(HttpClientService.class);
	
	public static JasonNode getHttpResponse(String baseUrl, String path, Map<String, String> headers, int connectTimeout, int readTimeout) throws IOException {
		HttpURLConnection connection = null;
		String url = baseUrl + path;
		
		try {
			// More implementation
			
			
		} finally {
			if(connection != null) {
				connection.disconnect();
			}
		}
	}
}
You can call any public API (such as github public api: https://api.github.com/users/{UserId}/repos?page=1)
In your unit test code, make sure you mock and stub everything properly, do NOT make real call to the API!

```
import static org.junit.Assert.assertEquals;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.databind.JsonNode;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.slf4j.LoggerFactory;

@RunWith(PowerMockRunner.class) // Use PowerMockRunner to enable mocking static methods
@PrepareForTest({HttpClientService.class, URL.class, HttpURLConnection.class}) // Prepare classes for mocking
public class HttpClientServiceTest {

    private HttpURLConnection mockConnection;

    @Before
    public void setUp() throws Exception {
        // Mock URL and HttpURLConnection
        mockConnection = PowerMockito.mock(HttpURLConnection.class);

        // Mock static URL class to return the mocked HttpURLConnection
        mockStatic(URL.class);
        URL mockUrl = PowerMockito.mock(URL.class);
        whenNew(URL.class).withAnyArguments().thenReturn(mockUrl);
        when(mockUrl.openConnection()).thenReturn(mockConnection);

        // Mock the behavior of HttpURLConnection
        when(mockConnection.getResponseCode()).thenReturn(200);
        when(mockConnection.getInputStream()).thenReturn(new ByteArrayInputStream("{\"key\": \"value\"}".getBytes()));
    }

    @Test
    public void testGetHttpResponse() throws IOException {
        // Arrange
        String baseUrl = "https://api.github.com";
        String path = "/users/testuser/repos?page=1";
        Map<String, String> headers = new HashMap<>();
        headers.put("Accept", "application/json");
        int connectTimeout = 5000;
        int readTimeout = 5000;

        // Act
        JsonNode result = HttpClientService.getHttpResponse(baseUrl, path, headers, connectTimeout, readTimeout);

        // Assert
        assertEquals("value", result.get("key").asText());

        // Verify the connection was disconnected
        PowerMockito.verifyStatic(HttpClientService.class);
        mockConnection.disconnect();
    }
}

```


#### 1. List and explain all of the new learned annotations to your annotations.md


#### 2. What is the lifecircle of Junit?

The lifecycle of a JUnit test is a sequence of steps that JUnit follows to execute a test case. 
It involves when and where to set up test data, mock dependencies, and clean up resources.

The lifecycle of a JUnit test can be broken down into the following phases:

1. Test Class Instantiation:
   - JUnit creates an instance of the test class for each test method. 
     This ensures that each test method runs in isolation and does not share state with other test methods.

2. BeforeAll (Class-Level Setup):
	The `@BeforeAll` annotated method is executed once before any test methods in the class are run.
    Used for expensive setup operations, such as initializing a database connection or loading test data.
	```
	@BeforeAll
	static void setUpClass() {
	 System.out.println("BeforeAll: Setup for the entire test class");
	}
	```

3. BeforeEach (Method-Level Setup):
	The `@BeforeEach` annotated method is executed before each test method. 
	Used to set up the test environment or initialize objects required for the test.

	```
	@BeforeEach
	void setUp() {
	 System.out.println("BeforeEach: Setup before each test method");
	}
	```

4. Test Method Execution:
	The test method annotated with `@Test` is executed. 
	This is where the actual test logic resides.

	```
	@Test
	void testMethod() {
	 System.out.println("Test method executed");
	 assertEquals(2, 1 + 1);
	}
	```

5. AfterEach (Method-Level Cleanup):
	The `@AfterEach` annotated method is executed after each test method. 
	Used to clean up resources or reset the state after the test.

	```
	@AfterEach
	void tearDown() {
	 System.out.println("AfterEach: Cleanup after each test method");
	}
     ```

6. AfterAll (Class-Level Cleanup):
	The `@AfterAll` annotated method is executed once after all test methods in the class have been run. 
	Used for cleanup operations, such as closing a database connection or deleting temporary files.

	```
	@AfterAll
	static void tearDownClass() {
	 System.out.println("AfterAll: Cleanup for the entire test class");
	}
	```

Example of a Complete JUnit Test Class:
	```
	import org.junit.jupiter.api.*;

	public class JUnitLifecycleTest {

		@BeforeAll
		static void setUpClass() {
			System.out.println("BeforeAll: Setup for the entire test class");
		}

		@BeforeEach
		void setUp() {
			System.out.println("BeforeEach: Setup before each test method");
		}

		@Test
		void testMethod1() {
			System.out.println("Test method 1 executed");
			assertEquals(2, 1 + 1);
		}

		@Test
		void testMethod2() {
			System.out.println("Test method 2 executed");
			assertEquals(4, 2 * 2);
		}

		@AfterEach
		void tearDown() {
			System.out.println("AfterEach: Cleanup after each test method");
		}

		@AfterAll
		static void tearDownClass() {
			System.out.println("AfterAll: Cleanup for the entire test class");
		}
	}
	```

Key Points：
	Isolation: 
		Each test method runs in its own instance of the test class, ensuring no shared state between tests.
	Order of Execution: 
		The lifecycle methods (`@BeforeAll`, `@BeforeEach`, `@AfterEach`, `@AfterAll`) are executed in a specific order to ensure proper setup and cleanup.
	Resource Management: 
		Use `@BeforeEach` and `@AfterEach` for managing resources that are specific to individual tests, and use `@BeforeAll` and `@AfterAll` for managing resources that are shared across all tests in the class.


#### 3. Explain parameterized testing?

```
Parameterized testing is a technique that a single test method is executed multiple times with different sets of input data. 
It has these benefits:
	Code reuse: A single test method can be used to test multiple scenarios, reducing code duplication.
	Improved readability: Test cases become more concise and easier to understand.
	Increased test coverage: It's simpler to add new test cases by providing additional input data.
	Efficient testing of edge cases: Developers can easily test boundary conditions and special cases.
	
In JUnit 5, parameterized tests are implemented using the @ParameterizedTest annotation.
Various sources can provide test data, including:
	@ValueSource: 
		For simple values like primitives and strings.
	@EnumSource: 
		For testing with enum constants.
	@MethodSource: 
		For more complex objects or multiple parameters.
	@CsvSource: 
		For comma-separated values.

Examples：

public class ParameterizedTestExample {

    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5}) // Input data
    void testIsPositive(int number) {
        assertTrue(number > 0, "Number should be positive: " + number);
    }
}

public class ParameterizedTestExample {

    @ParameterizedTest
    @MethodSource("provideStringsForTest") // Method name to provide input data
    void testStringLength(String input, int expectedLength) {
        assertEquals(expectedLength, input.length(), "String length is incorrect");
    }

    // Method to provide input data
    static Stream<Arguments> provideStringsForTest() {
        return Stream.of(
            Arguments.of("hello", 5),
            Arguments.of("world", 5),
            Arguments.of("", 0)
        );
    }
}

public class ParameterizedTestExample {

    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }

    @ParameterizedTest
    @EnumSource(Day.class) // Input data from the Day enum
    void testDayIsNotNull(Day day) {
        assertNotNull(day, "Day should not be null");
    }
}

Benefits of Parameterized Testing are： 
	Efficiency:
		Reduces the need to write repetitive test code.

	Coverage:
		Allows you to test a wide range of inputs, including edge cases, with minimal effort.

	Clarity:
		Makes it clear that the same test logic is being applied to multiple inputs.

	Scalability:
		Easily add new test cases by simply adding new input data.

```

#### 4. Explain Mockito and PowerMock.

```
Mockito is the go-to choice for most unit testing scenarios due to its simplicity and performance.
Mockito is a mocking framework that allows you to create and configure mock objects for unit testing. 
It is widely used for its simplicity and readability. 
Mockito is ideal for mocking non-static methods, non-final classes, and interfaces.

PowerMock is a powerful extension for testing legacy or hard-to-test code, 
but it should be used sparingly due to its complexity and performance overhead.

Feature					Mockito					PowerMock
Mock Static Methods		Not supported			Supported
Mock Final Classes		Not supported			Supported
Mock Constructors		Not supported			Supported
Mock Private Methods	Not supported			Supported
Ease of Use				Simple and intuitive	More complex due to extra setup
Performance				Faster					Slower due to bytecode manipulation
Use Case				Modern, testable code	Legacy code or hard-to-test code

```


#### 5. Compare @Mock and @InjectMock

```
In unit testing with Mockito, 
@Mock and @InjectMocks annotations are commonly used to create mock objects and inject them into the class under test. 

@Mock is used to create mock objects for dependencies.


@InjectMocks is used to create an instance of the class under test and inject its dependencies (mocks).
It automatically injects mocks created with @Mock into the class under test.

Feature						@Mock										@InjectMocks
Purpose			Creates mock objects for dependencies.			Creates an instance of the class under test and injects mocks into it.
Usage			Used to mock external dependencies.				Used to instantiate the class under test and inject its dependencies.
Initialization	Requires MockitoAnnotations.openMocks(this) or a test runner.	Requires MockitoAnnotations.openMocks(this) or a test runner.
Injection		Does not perform injection.						Automatically injects mocks into the class under test.
Scenario		Mocking a repository or service.				Testing a service that depends on a mocked repository.


Example:

@Mock
private Dependency dependency;

@InjectMocks
private MyService myService;

```

#### 6. Explain stubbing.

```
Stubbing is the process of predefining the behavior of a method on a mock object.
It allows us to simulate specific scenarios or responses from dependencies without actually invoking the real implementation.
The purpose of stubbing is to isolate units of code for testing, provide controlled responses, 
and simulate specific scenarios without considering external interactions.

Stubs return predetermined, hardcoded values or objects when called, making them predictable and consistent.

It is commonly used when testing a class that depends on other classes or services.
Use cases:
	Simulating API responses without making actual network requests
	Providing data for testing when actual dependencies are unavailable or slow
	Enabling testing of specific code paths or error handling

Advantages:
	Simplifies test setup by avoiding complex dependencies
	Allows testing of code that interacts with external systems or incomplete modules
	Improves test reliability and speed by eliminating external factors
	Difference from mocks: 
		Unlike mocks, stubs do not verify interactions or method calls. 
		They simply provide predefined data for the test
 
Stubbing is particularly useful in top-down integration testing, where lower-level components may not be fully developed
```

#### 7. what is Mockito ArgumentMatchers

```
Mockito Argument Matchers are used to make stubbing and verification more flexible by allowing us to specify generic or dynamic arguments
instead of exact values. 
They are particularly useful when we don't know the exact input values in advance or when we want to match a wide range of inputs.

Key features are:
	Flexibility: 
		They enable matching of arguments based on type, value, or custom conditions.
	Variety: 
		ArgumentMatchers provide methods for different data types, including primitives, objects, collections, and arrays.
	Custom matching: 
		Developers can create custom matchers using the argThat() method for complex matching scenarios1.
	Improved readability: 
		ArgumentMatchers can make test code more concise and easier to understand

Common ArgumentMatchers methods include:
	any(): 
		Matches any object of a given type
	anyInt(), anyString(), etc.: 
		Match any value of specific primitive types
	eq(): 
		Matches a specific value
	matches(): 
		Allows matching based on regular expressions for strings

```


#### 8. Compare @spy and @Mock?

```
@Spy and @Mock are both Mockito annotations used for creating test doubles, but they are different:

Object Creation:
	@Mock creates a complete mock or fake object.
	@Spy creates a real object and allows spying on specific methods.

Method Behavior:
	@Mock: 
		By default, methods do nothing or return null/empty/default values.
	@Spy: 
		Real methods are called unless explicitly stubbed.

Use Cases:
	@Mock: 
		Used when we want to test logic without calling external services.
	@Spy: 
		Used when we want to call real methods and selectively stub specific ones.

Verification:
	Both allow verification of method invocations and argument matching.

Stubbing:
	@Mock: All methods need to be stubbed for desired behavior.
	@Spy: Only methods you want to change need stubbing; others retain real behavior.

Test Isolation:
	@Mock provides better isolation as it doesn't execute real code.
	@Spy partially executes real code, which can be useful for legacy or complex systems.

In summary, use @Mock for complete isolation and @Spy when you need to retain some real object behavior while selectively mocking certain methods.
```

#### 9. Explain Assertion .

```
Assertion is a key concept in software testing and development that involves verifying specific conditions or expectations within code. 
It acts as a Boolean expression that evaluates to either true or false, serving as a checkpoint to ensure the program behaves as intended.

Key aspects:

Assertions validate that certain conditions are met during program execution, helping detect errors and unexpected behaviors

When an assertion is true, the program continues normally. 
If false, it typically triggers an error or exception, signaling a problem in the code's logic.

When an assertion is true, the program continues normally. 
If false, it typically triggers an error or exception, signaling a problem in the code's logic.

Types of Assertions:
	Hard Assertions: Immediately halt test execution upon failure.
	Soft Assertions: Continue test execution even if an assertion fails.
	Custom Assertions: Tailored to specific testing needs

Types of Assertions:
	Hard Assertions: Immediately halt test execution upon failure.
	Soft Assertions: Continue test execution even if an assertion fails.
	Custom Assertions: Tailored to specific testing needs

Types of Assertions:
	Hard Assertions: Immediately halt test execution upon failure.
	Soft Assertions: Continue test execution even if an assertion fails.
	Custom Assertions: Tailored to specific testing needs.
```

#### 10. Add unit tests for CommentServiceImpl under Redbook->branch 10_testing (fork or copy the project http
s://github.com/CTYue/springboot-redbook),
1. Enrich logics inside CommentServiceImpl methods, add if-else conditions in each methods.
2. In CommentServiceImpl, add following method, remove modelMapper dependency, and replace all
modelMapper.map() with this method, write unit test for commentServiceMapperUtil
3. method coverage and branch coverage for CommentServiceImpl should be 100% (as much as you
can), .

```
See Coding/hw15:
1,
Added Input Validation: Added validation for postId, commentId, and commentDto
Added Field Validation: check comment.getName() to ensure they are not empty.
Edge Case Handling:
 in getCommentsByPostId(), check if (comments.isEmpty()) 
 
2, 

3, 
```