# hw15

---

## Testing & Environment Concepts Comparison

## **Testing Types**

### 1. Unit Testing
- **Definition**: Tests individual components (e.g., functions, classes) in isolation.
- **Example**: Testing a `calculateTax()` function with mock inputs.
- **Tools**: JUnit, pytest.

### 2. Functional Testing
- **Definition**: Validates system behavior against functional requirements.
- **Example**: Testing a login feature end-to-end (UI + backend).
- **Tools**: Selenium, Cypress.

### 3. Integration Testing
- **Definition**: Checks interactions between integrated components/modules.
- **Example**: Testing payment processing with a third-party API.
- **Tools**: Postman, TestNG.

### 4. Regression Testing
- **Definition**: Ensures new changes don’t break existing functionality.
- **Example**: Re-running test suites after a bug fix.
- **Tools**: Jenkins (automated pipelines).

### 5. Smoke Testing
- **Definition**: Quick checks to verify system stability after deployment.
- **Example**: Testing core features (e.g., homepage loading) post-deploy.
- **Tools**: Manual checks or lightweight scripts.

### 6. Performance Testing
- **Definition**: Evaluates system responsiveness, scalability under load.
- **Example**: Simulating 10k users accessing a checkout page.
- **Tools**: JMeter, LoadRunner.

### 7. A/B Testing
- **Definition**: Compares two versions of a feature to measure user preference.
- **Example**: Testing green vs. red "Buy Now" buttons for conversion rates.
- **Tools**: Optimizely, Google Optimize.

### 8. User Acceptance Testing (UAT)
- **Definition**: End-users validate the system in a real-world scenario.
- **Example**: Clients testing an e-commerce cart before launch.
- **Tools**: Manual testing, Jira for feedback.

---

## **Environments**

| Environment          | Purpose                               | Example Use Case                      |
|----------------------|---------------------------------------|---------------------------------------|
| **Development**      | Local coding & debugging              | Writing code on a developer’s laptop. |
| **QA**               | Test execution & bug reporting        | Running automated Selenium tests.     |
| **Pre-prod/Staging** | Mirror of production for final checks | UAT or performance testing.           |
| **Production**       | Live environment for end-users        | Hosting a public-facing SaaS app.     |

---

### **Key Comparisons**
| Testing Type             | Scope                     | Example vs. Another Type                                                 |
|--------------------------|---------------------------|--------------------------------------------------------------------------|
| **Unit vs. Integration** | Isolated vs. Interactions | Testing a function (Unit) vs. testing API calls (Integration).           |
| **Functional vs. UAT**   | Technical vs. User Focus  | Automated login test (Functional) vs. client validating workflows (UAT). |
| **Smoke vs. Regression** | Quick vs. Comprehensive   | Checking homepage (Smoke) vs. re-testing all features (Regression).      |

| Environment                | Access                | Example vs. Another Environment                                      |
|----------------------------|-----------------------|----------------------------------------------------------------------|
| **QA vs. Staging**         | Internal vs. Pre-live | Running automated tests (QA) vs. final client sign-off (Staging).    |
| **Staging vs. Production** | Clone vs. Real        | Testing deployment scripts (Staging) vs. serving users (Production). |



## 3. What is the lifecircle of Junit?

1. **Test Class Instantiation**: A new instance of the test class is created for **each test method** (to ensure isolation).
2. Execution Order:
    - `@BeforeAll` (once before **all** tests).
    - For each test method:
        - `@BeforeEach` → `@Test` → `@AfterEach`.
    - `@AfterAll` (once after **all** tests).  

## 4. Explain parameterized testing?
### Parameterized Testing
- **Definition**: Runs the same test method with multiple input values to validate different scenarios.
- **Purpose**: Reduces code duplication and improves test coverage.
- **Example** (JUnit 5):
  ```java
  @ParameterizedTest
  @ValueSource(strings = {"apple", "banana", "cherry"})
  void testFruitNames(String fruit) {
      assertTrue(fruit.length() > 3);
  }
  ```
- **Key Annotations**:
  1. @ParameterizedTest: Marks the test as parameterized.
  2. @ValueSource, @CsvSource, @MethodSource: Provide input values.

## 5. Explain Mockito and PowerMock.
### Mockito vs. PowerMock
| **Mockito**                                                                                  | **PowerMock**                                                                                         |  
|----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|  
| A mocking framework for creating and managing **mock objects** to isolate dependencies.      | Extends Mockito to mock **static methods**, **constructors**, and **private methods**.                |  
| **Use Case**: Stubbing behavior, verifying interactions (e.g., `when(...).thenReturn(...)`). | **Use Case**: Testing legacy code with static/private methods (e.g., `PowerMockito.mockStatic(...)`). |  
| **Limitation**: Cannot mock static/final/private methods.                                    | **Requires**: Integration with test runners (e.g., `@RunWith(PowerMockRunner.class)`).                |  

**Example (Mockito)**:
```java
@Mock 
UserRepository userRepo;

@Test 
void testFindUser() {
  when(userRepo.findById(1L)).thenReturn(new User("Alice"));
}
```

**Example (PowerMock)**:
```java
@RunWith(PowerMockRunner.class)
@PrepareForTest(StaticClass.class)
public class TestClass {
  @Test
  public void testStaticMethod() {
    PowerMockito.mockStatic(StaticClass.class);
    when(StaticClass.getValue()).thenReturn(42);
  }
}
```

## 6. Compare @Mock and @InjectMock
### `@Mock` vs. `@InjectMocks`

| **`@Mock`**                                                                | **`@InjectMocks`**                                                                       |  
|----------------------------------------------------------------------------|------------------------------------------------------------------------------------------|  
| Creates a **mock object** of a dependency (e.g., a repository or service). | Injects **mocked dependencies** into the class under test (e.g., a service).             |  
| Used to isolate external dependencies.                                     | Used to wire mocks into the target class (e.g., via constructor/setter/field injection). |  
| Requires explicit stubbing (e.g., `when(...).thenReturn(...)`).            | Automatically injects `@Mock`-annotated dependencies into the target class.              |  

**Example**:
```java
public class UserServiceTest {
  @Mock 
  private UserRepository userRepo; // Mock dependency
  
  @InjectMocks 
  private UserService userService; // Injects userRepo into UserService
  
  @Test 
  void testGetUser() {
    when(userRepo.findById(1L)).thenReturn(new User("Alice"));
    User result = userService.getUser(1L);
    assertEquals("Alice", result.getName());
  }
}
```

## 7. Explain stubbing.

## Definition
**Stubbing** is a technique used in software testing to replace a method or function with a dummy implementation that returns predefined results. It allows isolating the code under test by controlling the behavior of dependencies, ensuring the test focuses solely on the logic being tested.

---

## Purpose
1. **Isolate Dependencies**: Stub external systems or components (e.g., databases, APIs) to avoid unpredictable behaviors.
2. **Control Outputs**: Define specific return values or behaviors for methods to simulate various scenarios.
3. **Speed Up Testing**: Eliminate delays caused by real system interactions (e.g., network latency).

---

## Example (Using Mockito in Java)
Suppose you are testing a `UserService` that depends on a `UserRepository`.

### Code Example:
```java
public class UserService {
    private UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public String getUserFullName(int userId) {
        User user = userRepository.findUserById(userId);
        return user.getFirstName() + " " + user.getLastName();
    }
}
```

## 8. what is Mockito ArgumentMatchers

### Mockito ArgumentMatchers
- **Definition**: Used to match arguments flexibly during stubbing or verification (e.g., ignoring specific values or matching patterns).
- **Common Matchers**:
    - `any()`: Matches any object of a given type (e.g., `any(String.class)`).
    - `eq()`: Matches a specific value (e.g., `eq("test")`).
    - `argThat()`: Custom matcher using a lambda/predicate (e.g., `argThat(arg -> arg.length() > 5)`).
- **Usage**:
  ```java
  when(mockService.process(anyString(), eq(100))).thenReturn("success");
  verify(mockService).process(any(), argThat(value -> value > 50));
  ```
- **Usage**: If one argument uses a matcher, all arguments in the method must use matchers.


## 9. Compare @spy and @Mock?

| **`@Spy`**                                                | **`@Mock`**                                                    |  
|-----------------------------------------------------------|----------------------------------------------------------------|  
| Wraps a **real object** (partial mocking).                | Creates a **full mock** (no real logic).                       |  
| Calls **real methods** unless stubbed.                    | All methods return **default values** unless stubbed.          |  
| Useful for testing **real behavior** with some overrides. | Useful for **isolating dependencies** and simulating behavior. |  

**Example (`@Spy`)**:
```java
@Spy 
List<String> spyList = new ArrayList<>();

@Test 
void testSpy() {
  spyList.add("real"); // Real method called
  when(spyList.size()).thenReturn(100); // Stubbed method
  assertEquals(100, spyList.size());
}
```

**Example (`@Mock`)**:
```java
@Mock 
List<String> mockList;

@Test 
void testMock() {
  when(mockList.size()).thenReturn(100); // Stubbed method
  assertEquals(100, mockList.size()); // No real logic
}
```

## 10. Explain Assertion.
- **Definition**: Used to validate expected outcomes in tests by comparing actual results with expected values.
- **Purpose**: Ensures the code behaves as intended.
- **Common Assertions**:
    - `assertEquals(expected, actual)`: Checks if two values are equal.
    - `assertTrue(condition)`: Verifies a condition is `true`.
    - `assertFalse(condition)`: Verifies a condition is `false`.
    - `assertNull(object)`: Checks if an object is `null`.
    - `assertNotNull(object)`: Checks if an object is not `null`.
    - `assertThrows(Exception.class, () -> {...})`: Verifies if a specific exception is thrown.

**Example**:
```java
@Test 
void testAssertions() {
  int result = 2 + 2;
  assertEquals(4, result); // Passes if result == 4
  assertTrue(result > 0);  // Passes if result > 0
  assertThrows(ArithmeticException.class, () -> {
    int x = 1 / 0; // Throws exception
  });
}
```






