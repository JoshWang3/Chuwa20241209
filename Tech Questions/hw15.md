# HW15
____
Explain and compare following concepts, provide specific examples when doing comparison: 

Testing related:  
1. Unit Testing: To ensure that each unit of code functions correctly  
Example: If you are developing an e-commerce application, a unit test might check whether the function `calculateTotalPrice(cartItems)` correctly sums up the item prices.
2. Functional Testing: To validate that the software meets specified functional requirements  
Example: In a banking application, functional tests ensure that a user can transfer money from one account to another and that the transaction is reflected correctly.  
3. Integration Testing: To detect issues in the interaction between different components.  
Example: In a microservices-based e-commerce application, integration tests would check if the payment service correctly communicates with the order management system.  
4. Regression Testing: To confirm that existing functionality remains intact after updates.  
Example: If a social media application updates its messaging feature, regression testing ensures that existing features like user profile updates, post creation, and friend requests still work.  
5. Smoke Testing: To determine whether the software build is stable enough for further testing.  
Example: In a mobile banking app, a smoke test might verify that login, account balance retrieval, and fund transfers work before deeper testing.  
6. Performance Testing: To measure system behavior under normal and peak conditions.  
Example: A video streaming platform might undergo performance testing to check if it can handle 1 million concurrent users streaming content.  
7. A/B Testing: To optimize user experience by testing different design or feature variations.  
Example: A news website might show two versions of a homepage—one with a search bar at the top and another with it at the bottom—to determine which drives more engagement.  
8. User Acceptance Testing: To confirm that the software is ready for production deployment.  
Example: Before launching a CRM system, sales representatives test if lead tracking, reporting, and email automation features work as expected.

Environment related:
1. Development: The development environment is where developers write, test, and debug code. It is typically an isolated local setup or a shared environment within a development team.  
Example: A developer working on a social media app might add a new "dark mode" feature in their local development setup and test it using a local database before pushing it to a shared environment.  
2. QA (Quality Assurance): The QA environment is a controlled testing environment where testers validate new features and ensure that the application functions as expected before moving to staging or production.  
Example: QA testers might verify that a new chat feature in a messaging app works across different devices and browsers in the QA environment.  
3. Pre-prod/Staging: The staging (or pre-production) environment is a replica of the production environment used for final testing before deployment.  
Example: In a cloud-based e-commerce platform, the staging environment would mimic the production setup, allowing testing of new payment gateways, shipping integrations, and performance optimizations.  
4. Production: The production environment is the live system where real users interact with the application.  
Example: A banking app in production allows users to transfer funds, check balances, and receive real-time notifications.

### 2. What is the lifecycle of Junit?
JUnit lifecycle consists of the following stages: Setup, Execution, and TearDown.  
1. Setup: @BeforeAll: Executed once before all test methods in the test class. @BeforeEach: Executed before each test method.
2. Execution: @Test: The actual test method that verifies the functionality of the code under test.
3. TearDown: @AfterEach: Executed after each test method. @AfterAll: Executed once after all test methods in the test class.

### 3. Explain parameterized testing
Parameterized testing in JUnit allows running the same test method with different input values. It helps in testing multiple scenarios with varying inputs without writing separate test methods for each case.
Example:
```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.junit.jupiter.api.Assertions.assertTrue;

class ParameterizedExampleTest {

    @ParameterizedTest
    @ValueSource(ints = {2, 4, 6, 8})  // Runs test for each value
    void testEvenNumbers(int number) {
        assertTrue(number % 2 == 0, "Number should be even");
    }
}
// This test method will run 4 times with input values 2, 4, 6, and 8.
```

### 4. Explain Mockito and PowerMock.
- Mockito: A popular Java mocking framework used for creating mock objects in unit tests. Mockito allows mocking dependencies and verifying interactions between objects.
- PowerMock: An extension of Mockito and EasyMock that enables mocking of static methods, final classes, and private methods. PowerMock extends the capabilities of Mockito and EasyMock by providing additional features for testing complex scenarios.

### 5. Compare @Mock and @InjectMock
- @Mock is used to create a mock object. @InjectMock is used to automatically inject mocks into the class under test.
- @Mock doesn't create a real object but only mocks dependencies. @InjectMock creates a real object by initializing the actual class under test.
```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

class OrderServiceTest {

    @Mock
    private PaymentService paymentService;  // Mocked dependency

    @InjectMocks
    private OrderService orderService;  // Class under test

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this); // Initializes mocks and injects them
    }

    @Test
    void testOrderPayment() {
        when(paymentService.processPayment(anyDouble())).thenReturn(true);  // Mock behavior

        boolean result = orderService.placeOrder(100.0); // Uses injected mock

        assert(result);  // Ensures order was placed successfully
    }
}
```

### 6. Explain stubbing.
Stubbing is the process of defining the behavior of a mock object. It involves specifying the return values or exceptions that the mock object should provide when certain methods are called. Stubbing allows controlling the behavior of dependencies in unit tests and setting up the test environment.

### 7. what is Mockito ArgumentMatchers.
Mockito ArgumentMatchers are used to match method arguments in mock object interactions. They provide flexible ways to define argument matching conditions for verifying method calls or stubbing behavior. ArgumentMatchers can match specific values, any values, or complex conditions using custom matchers.

### 8. Compare @Spy and @Mock
- @Mock creates a fully mocked object, meaning all methods return default values unless explicitly stubbed, it doesn't call real method implementations unless stubbed.
- @Spy creates a partial mocked object, meaning it calls real method unless explicitly stubbed. You can override specific methods while still using the real ones.

### 9. Explain Assertion.
Assertion is a statement that verifies the expected behavior of the code under test. It checks whether the actual output or state of the system matches the expected output or state. Assertions are used in unit tests to validate the correctness of the code and ensure that it behaves as intended.

### 10. Add unit tests for CommentServicelmpl under Redbook->branch 10_testing (fork or copy the project http s://github.com/CTYue/springboot-redbook),












