# HW15
## Questions 1 Testing:

### 1. Testing related
(1) Unit Testing
Tests individual components (functions, methods, or classes) in isolation.


(2) Functional Testing
Ensures that a feature or functionality works as expected according to requirements.

(3) Integration Testing
Verifies that different modules or components work together correctly.

(4) Regression Testing
Ensures that recent changes (e.g., bug fixes or new features) do not break existing functionality.

(5) Smoke Testing
A preliminary test to check if the basic functions of an application are working before more detailed testing.

(6) Performance Testing
Evaluates how a system behaves under different conditions, such as load, stress, or concurrency.

(7) A/B Testing
Compares two versions of a feature to determine which performs better.

(8) User Acceptance Testing (UAT)
The final testing phase where actual users verify that the system meets their needs before deployment.

### 2. Environment Related

(1) Development
The environment where developers write, test, and debug code.
Example: A developer testing a new API locally before pushing it to a shared repository.

(2) QA (Quality Assurance)
A dedicated environment where testers perform various types of testing (e.g., functional, integration, regression).
Example: Testers verifying a new feature on a separate QA server before approval for staging.

(3) Pre-prod/Staging
A near-production environment used for final testing before deployment.

(4) Production
The live environment where actual users interact with the application.


### 3.
Check HW15/Testing

## Questions 2 Unit testing:

### 1. List and explain all of the new learned annotations to your annotations.md
Check annotations.md


### 2. What is the lifecycle of JUnit?
1. Initialization Phase: Class loads into memory.
@BeforeAll (JUnit 5) executes (runs once before all tests).
2. Test Execution Phase: The test method (@Test) runs.

@BeforeEach (JUnit 5) executes before each test.
@AfterEach (JUnit 5) executes after each test.

Cleanup Phase:

@AfterAll (JUnit 5) executes (runs once after all tests).


### 3. Explain parameterized testing?
Parameterized testing allows running the same test multiple times with different input values.
```
@ParameterizedTest
    @ValueSource(strings = {"racecar", "radar", "level"})
    void testPalindrome(String word) {
        assertTrue(isPalindrome(word));
    }

    boolean isPalindrome(String str) {
        return str.equals(new StringBuilder(str).reverse().toString());
    }
```

### 4. Explain Mockito and PowerMock
Mockito: A framework for mocking dependencies in unit tests. Supports mocking interfaces, classes, and method behaviors.

PowerMock: An extension of Mockito that allows mocking static methods, final classes, and private methods (not supported in standard Mockito).

### 5. Compare @Mock and @InjectMocks

`@Mock`: Creates a mock instance of a class.

`@InjectMocks`: Automatically injects mocked dependencies into the class being tested.


### 6. Explain `stubbing`
Stubbing is the process of defining mock behaviors before executing a test.

### 7. What is Mockito ArgumentMatchers?
Mockito provides ArgumentMatchers to match method parameters dynamically.


### 8. Compare @Spy and @Mock
@Spy: Wraps a real instance of the class. Calls real methods unless overridden.

@Mock: Creates a completely mocked instance. All method calls return default values unless stubbed.


### 9. Explain Assertion
Assertions are used to validate test outcomes.
```
assertEquals(10, result);  // Checks if values are equal (10)
assertTrue(condition);  // is true?
assertFalse(condition); // is false?
assertNotNull(object);  // Ensures object is not null
assertThrows(Exception.class, () -> someMethod()); // Validates exceptions
```

### 10.