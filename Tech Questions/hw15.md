# Homework 15
## Spring Testing 

### 1. Explain and compare following concepts, provide specific examples when doing comparison:
- **Testing Concepts**

| **Type**                          | **Definition**                                               | **Example**                                                  | **Comparison**                                               |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Unit Testing**                  | Tests individual components or functions in isolation.       | Testing a `calculateTotal()` function for correct output.    | Most granular testing level, focusing on isolated parts.     |
| **Functional Testing**            | Validates the software's functionality against requirements. | Ensuring that submitting a contact form triggers an email.   | Broader than unit testing, focusing on user flows.           |
| **Integration Testing**           | Verifies that different modules work together.               | Testing communication between a user service and a payment service. | Tests interactions between components rather than isolated functions. |
| **Regression Testing**            | Ensures new changes do not affect existing functionality.    | Re-testing login, payment, and checkout after adding a new feature. | Prevents unexpected issues over time.                        |
| **Smoke Testing**                 | A quick check of major application functions.                | Verifying if the application starts and main features are accessible. | Lightweight and faster than functional or regression testing. |
| **Performance Testing**           | Measures speed, stability, and scalability under load.       | Testing website response time with 1,000 users simultaneously. | Focuses on non-functional requirements.                      |
| **A/B Testing**                   | Compares two or more versions to determine which performs better. | Comparing two landing page designs to measure user engagement. | Optimizes user experience rather than detecting bugs.        |
| **User Acceptance Testing (UAT)** | Ensures the system meets user requirements.                  | End-users testing a CRM system before launch.                | Final testing phase, done by actual users.                   |
| **End-to-End Testing**            | Validates the entire workflow of an application from start to finish, simulating real-world user scenarios. | Mainly performed by QA Engineers                             | Ensure end-to-end functionalities work as expected.          |

- **Environment Concepts**

| **Environment**            | **Definition**                                         | **Example**                                                  | **Comparison**                                         |
| -------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| **Development**            | Where developers build and test new code.              | Local instance of a web application on a developer's machine. | Highly unstable and frequently changing.               |
| **QA (Quality Assurance)** | Used by testers to validate functionality and quality. | Testers running automated and manual tests.                  | More stable than development, but not for live use.    |
| **Pre-Prod/Staging**       | Mimics production for final testing.                   | Testing an e-commerce site before going live.                | Identical to production but without live users.        |
| **Production**             | The live environment accessed by end-users.            | A live online banking platform used by customers.            | Most stable and secure, with strict change management. |

### Write unit test using Junit and PowerMock for following code (a static http client method which calls an external public API).
- see Projects/hw15

### 1. List and explain all of the new learned annotations to your annotations.md
- see annotations.md

### 2. What is the lifecircle of Junit?
- The lifecycle of **JUnit** involves specific methods that control the **Setup**, **Execution**, and **Cleanup / Teardown** of test cases.

| **Annotation** | **Description**                                              | **Execution Order**      |
| -------------- | ------------------------------------------------------------ | ------------------------ |
| `@BeforeAll`   | Initializes resources required for all tests (e.g., database connection pool). Must be `static`, class level. | First, one-time setup    |
| `@BeforeEach`  | Sets up test data or configuration for each test (e.g., resetting mock objects). | Setup before every test  |
| `@Test`        | Executes the actual test logic. Use in combination with `@Disabled`, `Assertions` (determine pass or fail) and `Assumptions`  (conditional test execution). | Main execution           |
| `@AfterEach`   | Cleans up resources after each test (e.g., clearing test data). | Cleanup after every test |
| `@AfterAll`    | Releases resources used during the tests (e.g., closing database connections). Must be `static`. | Last, one-time teardown  |

### 3. Explain parameterized testing?
- **Parameterized Testing** allows running the same test multiple times with data-driven input values. Instead of writing separate test cases for each input, we can provide a collection of data and run the test for each set, improving code reusability and reducing redundancy.

### 4. Explain Mockito and PowerMock.
- **Mockito** is used for creating **mock objects** in unit tests with simple dependencies. It allows developers to **simulate dependencies** in a controlled manner, making it easier to test the behavior of individual components without relying on actual implementations.

- **PowerMock** is a PowerMock's extension API to support Mockito. It provides capabilities to work with the Java Reflection API in a simple way to overcome the problems of Mockito, such as the **lack of ability to mock final, static or private methods**.

### 5. Compare @Mock and @InjectMock
| Feature                     | `@Mock`                                                | `@InjectMocks`                                             |
| --------------------------- | ------------------------------------------------------ | ---------------------------------------------------------- |
| **Purpose**                 | Creates a mock instance of a class                     | Injects mocked dependencies into the tested class          |
| **Behavior**                | Returns default values (null, 0, false) unless stubbed | Automatically injects `@Mock` dependencies                 |
| **Dependency Injection**    | No                                                     | Yes (injects all `@Mock` instances)                        |
| **Use Case**                | Mocking standalone dependencies                        | Testing a class that depends on multiple mock dependencies |
| **Initialization Required** | Yes (`MockitoAnnotations.openMocks(this)`)             | Yes (`MockitoAnnotations.openMocks(this)`)                 |

### 6. Explain stubbing.
- **Stubbing** in Mockito is the process of **predefining the behavior** of a mock objectâ€™s method. When a stubbed method is called during a test, it returns the specified value instead of executing real logic.
- **Avoid real method execution** (e.g., database calls, network requests).
- **Control return values** to simulate different scenarios.
- **Improve test reliability** by isolating the unit under test.
- **Simulate exceptions** to test error handling.

### 7. what is Mockito ArgumentMatchers.
- **Mockito `ArgumentMatchers`** allow flexible verification and stubbing by matching method arguments dynamically rather than using specific values. This is useful when exact arguments are unknown or not relevant to the test.

### 8. Compare @spy and @Mock?
| Feature               | `@Mock`                                       | `@Spy`                                                       |
| --------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| **Object Type**       | Fully mocked                                  | Partial mock (real object with spies)                        |
| **Default Behavior**  | Returns default values (`null`, `0`, `false`) | Executes real methods unless stubbed                         |
| **Use Case**          | When we want to replace a dependency entirely | When we want to spy on a real object while stubbing some methods |
| **Real Method Calls** | No (unless stubbed explicitly)                | Yes (unless overridden)                                      |
| **Stubbing Required** | Yes, otherwise returns defaults               | No, real methods work unless stubbed                         |
| **Example Usage**     | External services, databases, APIs            | Partially testing real implementations                       |

### 9. Explain Assertion.
- **Assertion** is a way to **verify expected outcomes** in unit testing. Assertions check whether the actual result of a test matches the expected result. If an assertion fails, the test fails, indicating a problem in the code.

### 10. Add unit tests for CommentServicelmpl under Redbook->branch 10_testing (fork or copy the project http s://github.com/CTYue/springboot-redbook),
#### 1. Enrich logics inside CommentServicelmpl methods, add if-else conditions in each methods.
#### 2. In CommentServicelmpl, add following method, remove modelMapper dependency, and replace all modelMapper.map() with this method, write unit test for commentServiceMapperutil.
#### 3. Method coverage and branch coverage for CommentServicelmpl should be 100% (as much as you can).
- see Projects/hw15
