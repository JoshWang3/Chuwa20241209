# Homework 13
## Spring Security 

### 1. List all of the annotations you learned from class and homework to annotaitons.md
- see annotations.md

### 2.Explain TLS, PKI, certificate, public key, private key, and signature.
- **Transport Layer Security, TLS** is a cryptographic protocol that ensures secure communication over a network. TLS operates by establishing a secure connection between two parties (e.g., a browser and a server) using a process called the **TLS handshake**.

- **Public Key Infrastructure, PKI** is a framework that supports the creation, management, distribution, and verification of **digital certificates** and **keys**. It is the backbone of secure communication in systems like TLS.

- **Certificate** is like an online passport issued by a CA. Browsers use certificates to ensure they are communicating with the legitimate owner of a website. 

- **Public Key** and **Private Key** are the foundation of **asymmetric encryption**. 
**Public Key**: Shared with others and used **to encrypt data or verify signatures**.
**Private Key**: Kept secret and used **to decrypt data or generate signatures**.

- **Digital Signature** validates data **integrity** and sender **authenticity**. Digital signatures alone **cannot prevent eavesdropping**, as they are designed for authenticity and integrity, **not confidentiality**. In secure systems like TLS, **encryption** is used alongside **digital signatures** to ensure that the original data is protected from eavesdropping.

### 4. List all http status codes that related to authentication and authorization failures.
| **Status Code** | **Meaning**                           | **Description**                                              |
| :-------------: | ------------------------------------- | ------------------------------------------------------------ |
|     **401**     | Unauthorized                          | Authentication is required, but **no credentials** were provided, or they are invalid. |
|     **403**     | Forbidden                             | The server refuses to authorize the request, even though it understands it. **Insufficient permissions**. |
|     **407**     | Proxy Authentication Required         | The client must authenticate itself with a **proxy before** the request can be processed. |
|     **419**     | Authentication Timeout (Non-standard) | Indicates that the authentication **token has expired** (used in specific frameworks like Laravel). |
|     **422**     | Unprocessable Entity                  | Used when a login or token submission is rejected due to **invalid or malformed data**. |
|     **429**     | Too Many Requests                     | Occurs when the service rate-limits due to repeated login attempts or **excessive token requests**. |

### 5. Compare authentication and authorization? Name and explain important components in Spring security that undertake authentication and authorization
| **Aspect**        | **Authentication**                                           | **Authorization**                                            |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Definition**    | Verifying the **identity** of the user (e.g., username/password). | Determining what **actions or resources** the user is allowed to access. |
| **Focus**         | "Who are you?"                                               | "What are you allowed to do?"                                |
| **Process**       | Involves validating credentials like tokens, passwords, or certificates. | Involves enforcing permissions, roles, or access policies.   |
| **Occurs When**   | At the beginning of the interaction (e.g., login process).   | After authentication, throughout the session.                |
| **Response Code** | 401 Unauthorized                                             | 403 Forbidden                                                |
| **Examples**      | Employees in a company are required to authenticate through the network before accessing their company email. | After an employee successfully authenticated, the system determines what information that employee is allowed to access. |
|                   | Transmit information through an ID Token.                    | Transmit information through an Access Token.                |

1. **AuthenticationManager**: The core component for handling authentication. It delegates the process to one or more `AuthenticationProvider` instances.
2. **AuthenticationProvider**: Performs the actual authentication logic.            
3. **UserDetailsService**: Provides user data from a database or another source.
4. **SecurityContext**: Holds the current authentication details.
5. **GrantedAuthority**: Represents a permission or role granted to the user. (e.g., `ROLE_ADMIN`, `ROLE_USER`).
6. **AccessDecisionManager**: Makes authorization decisions based on rules.
7. **FilterChainProxy**: Handles security filters in Spring Security.
8. **HttpSecurity**: Configures security for HTTP requests.

### 6. Explain HTTP Session?
- An **HTTP Session** is a mechanism used to maintain state and persist information about a user's interaction with a web application across multiple HTTP requests in **web servers**. Since HTTP is a **stateless protocol**, the server does not inherently remember any information about a client between requests. The session solves this problem by associating a series of requests with the same user.
      
### 7. Explain Cookie?
- A **cookie** is a small piece of data that a server sends to a web browser, which is then **stored on the client’s computer**. Cookies enable websites to store information about the user and **maintain state across multiple HTTP requests in the inherently stateless HTTP protocol**.

### 8. Compare Session and Cookie?

| **Aspect**            | **Session**                                                  | **Cookie**                                                   |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Definition**        | Server-side mechanism to maintain state across multiple HTTP requests. | Client-side mechanism to store data on the user's browser for subsequent requests. |
| **Storage Location**  | Stored on the server (in memory, database, or file system).  | Stored on the client’s browser.                              |
| **Data Size**         | Can store large amounts of data (limited by server capacity). | Limited to 4 KB per cookie.                                  |
| **Security**          | More secure as data is not directly exposed to the client.   | Less secure; data is visible to the client unless encrypted. |
| **Scope**             | Tied to a user session; requires server resources for storage. | Tied to a domain and optionally to a path; sent with every request to the domain. |
| **Expiry**            | Expires when the session ends (e.g., user logs out or session times out). | Expires based on `Expires` or `Max-Age` attribute; can persist beyond browser closure. |
| **Use Case**          | Better for secure and sensitive data, larger storage capacity. Managing server-side state, e.g., login sessions, shopping carts. | Better for lightweight, non-sensitive data that needs to persist across requests. Storing small client-side data, e.g., user preferences, authentication tokens. |
| **Performance**       | Slightly slower as server resources are consumed to manage session data. | Faster as the browser manages cookie storage and retrieval.  |
| **Access**            | Accessed server-side (via `HttpSession` in Java or equivalent). | Accessible client-side (via JavaScript) and server-side (via request headers). |
| **Data Transport**    | Data is not sent with every request; only a session ID is typically sent. | Entire cookie data is sent with every request to the server. |
| **Configuration**     | Requires server-side setup (e.g., session store, timeout configuration). | Requires cookie settings (e.g., Secure, HttpOnly, SameSite attributes). |
| **Security Features** | Can implement advanced security like server-side session invalidation. | Secure cookies (HTTPS), HttpOnly, and SameSite mitigate risks but are optional. |
| **Examples**          | Shopping cart, user authentication, multi-step forms.        | Language preferences, Remember Me tokens, analytics tracking. |

### 9. Find at least TWO websites who can be logged in using your Google Account, explain in detail on how Google SSO works with screenshots like below, find SSO-related Rest calls in Chrome developer tool:
- see screenshots
- ChatGPT and Overleaf
- Google SSO is built on OAuth 2.0 and OpenID Connect protocols. The process is:
1. When a user clicks "Sign in with Google," the website **redirects** the user to Google's login page.
2. Google **authenticate** and asks for the user's consent to share their profile information with the website. If the user is already logged into Google, this step is skipped.
3. Once authenticated, Google issues: an **ID Token** (JWT) which contains user identity information, and an **Access Token** which grants access to Google APIs if needed.
4. The tokens are **sent back** to the website, which uses them to fetch user details and log the user in.

### 10. How do we use session and cookie to keep user information across the the application?
- Using Sessions: server-side and a more secure way to manage user state across requests
1. **User Logs In**: The user submits login credentials. If authentication succeeds, the server creates a session for the user.
2. **Session ID Generation**: The server generates a unique **Session ID** and stores user-related information (e.g., username, roles) in the session storage (memory, database, etc.). The Session ID is sent to the client in a cookie or appended to the URL.
3. **Session ID in Requests**: For every subsequent request, the client includes the Session ID (typically in the `Cookie` header). The server uses this ID to retrieve the user's session data.
4. **Session Expiry**: When the session expires (due to inactivity or logout), the user needs to log in again.

- Using Cookies: client-side and can persist user information across requests and even browser sessions
1. **Set a Cookie**: After the user logs in, the server generates a cookie containing the user's data (e.g., a token or identifier). The cookie is sent to the client via the `Set-Cookie` header.
2. **Include Cookie in Requests**: The browser automatically sends the cookie with every subsequent request to the server.
3. **Read Cookie**: The server reads the cookie to retrieve user information or an identifier (e.g., Session ID or JWT).

- Using Both Sessions and Cookies Together to manage user information efficiently:
- **Cookies** store the **Session ID** on the client,**Sessions** store the actual user data on the server.
1. User logs in → Server creates a session and stores user info (e.g., roles, permissions).
2. Server generates a Session ID and sends it to the client as a cookie.
3. Browser sends the Session ID with every request.
4. Server retrieves session data using the Session ID.

### 11. What is the spring security filter?
- **Spring Security Filter** is a part of the security infrastructure responsible for processing incoming HTTP requests to provide authentication, authorization, and other security-related tasks. Filters in Spring Security work in a **filter chain** to apply security measures in a **specific order** and perform a **specific function** (e.g., checking for authentication, handling CSRF, validating tokens).

### 12. Explain bearer token and how JWT works.
- **Bearer Token** is a type of **access token** used to **authorize** access to resources in a system. The term "bearer" implies that possession of the token itself is enough to grant access; whoever "bears" the token can use it to access protected resources. This is a widely used mechanism in modern authentication protocols like OAuth 2.0.

- **JSON Web Token (JWT)** is a specific type of bearer token that is compact, self-contained, and secure. It is a JSON-based standard (RFC 7519) for transmitting information between parties as a digitally signed token.

- How JWT Works
1. After a user authenticates, the server generates a JWT containing claims about the user (e.g., user ID, roles). The token is signed using a secret key or private key.
2. The server sends the JWT to the client, often in the response body, a cookie, or the `Authorization` header.
3. The client includes the JWT in the **`Authorization`** header of subsequent requests`Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`.
4. The server verifies the JWT by: decoding the token, validating the signature using the secret key or public key, and checking claims like expiration (`exp`).
5. If valid, the server grants access; otherwise, it rejects the request.

### 13. Explain how do we store sensitive user information such as password and credit card number in DB?
- Storing sensitive user information like passwords and credit card numbers in a database requires robust security practices to protect against breaches and unauthorized access.

- **Passwords**: Use salted hashing algorithms like BCrypt or Argon2.
- **Credit Card Data**: Avoid storing it if possible. Use encryption, tokenization, and comply with PCI DSS (Payment Card Industry Data Security Standard) if we must.
- **General Practices**: Encrypt sensitive data, secure access, and implement auditing for a comprehensive security strategy.
1. **Use Secure Connections**: Always use HTTPS for data transmission to prevent man-in-the-middle attacks.
2. **Database Security**: Encrypt sensitive columns in the database. Restrict database access to authorized users and services only.
3. **Access Control**: Implement **Role-Based Access Control (RBAC)** to limit access to sensitive data. Ensure sensitive information is accessible only to users with legitimate need.
4. **Audit and Monitor**: Log access and modifications to sensitive data. Monitor logs for suspicious activity.
5. **Data Retention Policy**: Only store sensitive data for as long as necessary. Regularly purge old or unused data.
6. **Backup Security**: Encrypt backups containing sensitive data. Protect access to backup files.

### 14. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?
| Component**                  | **Responsibility**                                           | **Role in Authentication Workflow**                          | **Customizable**                                             |
| :--------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`UserDetailsService`**     | A service interface used to retrieve user details (like username, password, roles, etc.) from a data source. | Provides user-specific information (e.g., password and roles) to validate the user during authentication. | Yes (You can implement it for custom user data retrieval, such as from a database). |
| **`AuthenticationProvider`** | A strategy interface for performing authentication based on the user's credentials. | Verifies user credentials (e.g., username and password) and produces an `Authentication` object if successful. | Yes (You can provide custom logic for authentication, such as integrating with external identity providers). |
| **`AuthenticationManager`**  | Orchestrates the entire authentication process, delegating it to one or more `AuthenticationProvider` implementations. | The central component in Spring Security that attempts to authenticate a request by iterating through configured `AuthenticationProvider`s. | Yes (You can provide a custom implementation or configure multiple providers). |
| **`AuthenticationFilter`**   | A servlet filter that intercepts HTTP requests to extract authentication information (e.g., tokens or credentials). | Intercepts HTTP requests, extracts credentials (e.g., username/password, tokens), and passes them to the `AuthenticationManager` for processing. | Yes (You can extend `AbstractAuthenticationProcessingFilter` to implement custom authentication mechanisms). |


### 15.    What is the disadvantage of Session? how to overcome the disadvantage?
1. Server-Side Resource Consumption
- **Issue**: Sessions are stored on the server, which means as the number of users increases, the server must allocate more memory or storage to maintain session data.
- **Solution**: Use **distributed session storage**. Store session data in external systems like Redis, Memcached, or a database. (use Spring Session to store sessions in Redis)

2. Session Timeout
- **Issue**: Sessions have a timeout period for security reasons. If the user remains idle beyond this period, the session expires, and the user is logged out.
- **Solution**: Use **token-based authentication (e.g., JWT)** for long-term session persistence.
. Not Suitable for Stateless Applications**

3. Session Data Not Shared Across Servers**
- **Issue**: In a load-balanced, multi-server environment, a session created on one server may not be accessible from another server.
- **Solution**: Use **sticky sessions**. Configure the load balancer to route the same user's requests to the same server. Implement **distributed session management** by using a centralized session store (e.g., Redis, Memcached) that all servers can access.
- see Projects/hw13

### 16. how to get value from application.properties in Spring security?
| **Approach**               | **Use Case**                                                 |
| -------------------------- | ------------------------------------------------------------ |
| `@Value`                   | For injecting a small number of individual properties.       |
| `@ConfigurationProperties` | When dealing with a group of related properties. Makes the configuration reusable and clean. |
| `Environment`              | For dynamic retrieval of properties or if properties need conditional handling. |

### 17.    What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
- `configure(HttpSecurity http)` customizes the **web security** layer of Spring Security and determines what requests require authentication and what the application does after successful authentication. It also defines: how **HTTP requests** are secured, controlling aspects like which URLs require authentication or are publicly accessible, configuring login/logout functionality, enabling/disabling CSRF protection, setting up session management, and  adding custom security filters etc.

- `configure(AuthenticationManagerBuilder auth)` customizes the **authentication logic** of Spring Security to showcase how the application validates user credentials (authentication mechanism). It is used to configure **authentication mechanisms**, such as defining how user credentials (e.g., username and password) are validated, setting up custom `UserDetailsService` or `AuthenticationProvider`, and configuring in-memory, JDBC, or LDAP-based authentication.