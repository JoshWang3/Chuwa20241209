### hw13 - Security

#### 1. List all of the annotations you learned from class and homework to annotaitons.md

#### 2. Explain TLS, PKI, certificate, public key, private key, and signature.

```
TLS (Transport Layer Security) is a cryptographic protocol that provides secure communication over networks. 
It uses public key cryptography and digital certificates to authenticate parties and establish encrypted connections.

PKI (Public Key Infrastructure) is a system for managing digital certificates and public-private key pairs. 
It includes:
	Certificates: Digital documents containing:
		A public key
		Metadata about the key owner, such as domain name
		A digital signature from a Certificate Authority (CA)

	Public keys: Freely shared encryption keys used to:
		Encrypt messages only the private key holder can decrypt
		Verify digital signatures
	
	Private keys: Secret keys kept by the owner to:
		Decrypt messages encrypted with the corresponding public key
		Create digital signatures
	
	Digital signatures: Cryptographic proofs created with a private key to:
		Verify the authenticity of a message or certificate
		Ensure data integrity

TLS with certificates can be implemented using the built-in security APIs:

	// Create a TLS context
	SSLContext context = SSLContext.getInstance("TLS");
	context.init(keyManagers, trustManagers, null);

	// Create a secure socket
	SSLSocketFactory factory = context.getSocketFactory();
	SSLSocket socket = (SSLSocket) factory.createSocket(host, port);

	// Work with certificates
	KeyStore keyStore = KeyStore.getInstance("JKS");
	keyStore.load(new FileInputStream("keystore.jks"), password);

```

#### 3. Write a Spring security based application, which provides https APIs (one simple get controller with empty
response is good enough )instead of http, please generate a self-signed certificate to make your https
TLS verfication work.
	1. Pack your self-signed certificate in the form of jks file, as part of your application, name it properly
	2. Test if you can verify your HTTPs api without importing the self-signed certificate to your local
	certificate chain, if not, explain why.
	3. Explain what did you do to make https call work, do NOT bypass TLS/SSL verfication in Postman (this is cheating)! 
	Tutorial: https://www.baeldung.com/spring-channel-security-https

```
1, Generate a self-signed certificate using Java's keytool:
keytool -genkeypair -alias myapp -keyalg RSA -keysize 2048 -storetype JKS -keystore myapp.jks -validity 3650

It generated a file called myapp.jsk, place it in the src/main/resources directory.

// The JKS keystore uses a proprietary format. 
// It is recommended to migrate to PKCS12 which is an industry standard format using 
// "keytool -importkeystore -srckeystore myapp.jks -destkeystore myapp.jks -deststoretype pkcs12".

2, Configure HTTPS in application.properties:

server.port=8443
server.ssl.key-store-type=JKS
server.ssl.key-store=classpath:myapp.jks
server.ssl.key-store-password=your_password
server.ssl.key-alias=myapp

3, Create a controller:
@RestController
public class HelloController {
    @GetMapping("/hello")
    public ResponseEntity<Void> hello() {
        return ResponseEntity.ok().build();
    }
}

4, Configure Spring Security:

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .anyRequest().permitAll()
            .and()
            .requiresChannel()
            .anyRequest().requiresSecure();
        return http.build();
    }
}

2, Place the myapp.jks file in the src/main/resources directory.

(1) curl https://localhost:8443/hello
It fails with an SSL certificate error.

The server is using a self-signed certificate.
Curl is attempting to verify the certificate against trusted root certificates.
The self-signed certificate is not in the list of trusted root certificates.

The server is using a self-signed certificate.
Curl is attempting to verify the certificate against trusted root certificates.
The self-signed certificate is not in the list of trusted root certificates.

Without -k, It will get an SSL certificate error because the self-signed certificate is not trusted by the system.
	Self-signed certificates are not issued by a trusted Certificate Authority (CA).
	The system's trust store doesn't recognize the certificate issuer.
	This is a security feature to prevent man-in-the-middle attacks.

(2)curl -k -v https://localhost:8443/hello
-k means skipping certificate verification. 
This connects successfully.

3, To properly verify the certificate, need to:
	Export the public certificate from the JKS file.
	Import it into the system's trust store or browser's certificate manager.
	Then it can access the API without the -k flag in curl or warnings in browsers.

```

#### 4. list all http status codes that related to authentication and authorization failures.

```
	401 Unauthorized:
		Authentication required, but the client did not provide valid credentials.
		Indicates that the request lacks valid authentication credentials or the provided credentials are invalid.

	403 Forbidden: 
		The server understands the request but refuses to authorize it
		It Signifies that the client has valid credentials but lacks the necessary permissions to access the requested resource.

	407 Proxy Authentication Required: 
		Authentication is required by the proxy server.
		The client must first authenticate itself with the proxy server.
		
	419 Authentication Timeout / 440 Login Timeout: 
		Session expired or user needs to log in again (non-standard).
	
	451 Unavailable For Legal Reasons: 
		Access is denied due to legal restrictions (related to authorization).

	511 Network Authentication Required: 
		The client needs to authenticate to gain network access.
```

#### 5. Compare authentication and authorization? Name and explain important components in Spring security that undertake authentication and authorization

```
Authentication verifies the identity of a user or system.
It typically involves credentials like usernames and passwords, biometrics, or tokens.

Authorization determines what resources an authenticated user has permission to access or actions they can perform. 
It's based on the user's role or privileges within a system.

Their differences are:
	Authentication occurs before authorization
	Authentication is visible to and partially changeable by users, while authorization is not
	Authentication verifies identity, authorization grants access rights

Important Spring Security components for authentication and authorization:
	SecurityFilterChain: 
		Intercepts HTTP requests to determine if a user is authorized to access protected resources
	
	AuthenticationManager: 
		Main interface for authentication, typically implemented by ProviderManager
	
	AuthenticationProvider: 
		Performs the actual authentication. DaoAuthenticationProvider is a common implementation that uses UserDetailsService and PasswordEncoder
	
	UserDetailsService: 
		Retrieves user details, often from a database, for authentication purposes
	
	PasswordEncoder: 
		Used to validate passwords during authentication
	
	SecurityContextHolder: 
		Contains the SecurityContext, which stores the authenticated user's details
	
	GrantedAuthority: 
		Represents permissions granted to a user, used in authorization decisions.
```

#### 6. Explain HTTP Session?

```
An HTTP session is a temporary information exchange between a server and a client,
It allows web applications to maintain state and user-specific information across multiple HTTP requests, despite HTTP being a stateless protocol.
 
Key aspects of HTTP sessions include Creation, 	Maintenance, Stateful interactions, Termination.

HTTP sessions are crucial for:
	Authentication and authorization: Maintaining user login status across requests.
	Personalization: Tailoring content based on user preferences and history.
	Tracking multi-step processes: Managing complex operations that span multiple requests.

HTTP sessions are crucial for:
	Authentication and authorization: 
		Maintaining user login status across requests5.
	Personalization: 
		Tailoring content based on user preferences and history1.
	Tracking multi-step processes: 
		Managing complex operations that span multiple requests
```

#### 7. Explain Cookie?

```
An HTTP cookie is a small piece of data sent by a web server to a user's browser and stored on the user's device.
The purposes of cookie are:
	Session management: 
		Cookies help maintain user sessions, allowing websites to remember user login status, shopping cart contents, and other session-related information
	Personalization: 
		They store user preferences such as display language, UI theme, and other customization options
	Tracking: 
		Cookies enable websites to record and analyze user behavior.

Key characteristics of cookies include:
	Creation: 
		Cookies are typically created by web servers using the Set-Cookie HTTP header24.
	Storage: 
		Browsers store cookies and send them back to the server with subsequent requests12.
	Size and quantity: 
		Browsers can support cookies up to 4,096 bytes in size and at least 50 cookies per domain2.
	Persistence: 
		Cookies can be session-based (temporary) or persistent (with an expiration date)3.
	Security: 
		Various attributes like HttpOnly, Secure, and SameSite can be used to enhance cookie security		

Cookies is crucial in maintaining state in the otherwise stateless HTTP protocol.
It enables personalized and efficient web experiences
```

#### 8. Compare Session and Cookie?

```
Sessions and cookies are both mechanisms used in web applications to maintain state and user information, but they are difference:

Sessions:
	Server-side storage
	More secure
	Larger data capacity
	Typically last for browser session
	Can store complex data
	Accessible only on server
	Used for sensitive data and login states

Cookies:
	Client-side storage
	Less secure
	Limited data capacity, usually 4KB
	Can have set expiration or be persistent
	Store string data
	Accessible on client-side
	Used for preferences and tracking

They both are used in these cases:
	Maintain state in web applications
	Enable personalized user experiences 

Their key differences is: 
	Sessions use server storage with a client-side identifier, while cookies store data directly on the client.
```

#### 9. Find at least TWO websites who can be logged in using your Google Account, explain in detail on how Google SSO works with screenshots like below, find SSO-related Rest calls in Chrome developer tool:
picture

```
Website:
1, Medium
2, Slack

Google's Single Sign-On (SSO) mechanism works as follows:
	1, Click on the "Sign in with Google" button.
	2, Been redirected to Google's authentication page, select a Google Account.
	3, Google authenticates the identity and generates a SAML (Security Assertion Markup Language) response containing the authenticated username.
	4, This SAML response is digitally signed with Google's private key for security.
	5, The SAML response is sent back to the website, which verifies it using Google's public key.
	6, If verified successfully, the access is granted to the website.

To find SSO-related REST calls in Chrome developer tools:
	Open Chrome and navigate to a website that supports Google SSO.
	Open Chrome Developer Tools.
	Go to the Network tab.
	Initiate the Google SSO login process.
	Look for network requests with domains like "accounts.google.com" or containing "oauth" in the URL.
	These requests will typically use HTTP methods like GET or POST and may include parameters related to authentication and authorization.
```

#### 10. How do we use session and cookie to keep user information across the the application?

```
1,Use sessions for storing sensitive, server-side data that should not be exposed to the client.

2,Use cookies for storing non-sensitive client-side data, such as user preferences or tracking information.

3,Implement proper security measures, such as encrypting session data and using secure flags for cookies.

4,Set appropriate expiration times for persistent cookies to balance user convenience and security.

5,Minimize the amount of data stored in both sessions and cookies to improve performance and reduce security risks.

More details are:
Session:
	When a user starts interacting with a website, a unique session ID is generated on the server.
	This session ID is typically stored in a cookie on the client-side.
	The actual user information is stored on the server, associated with the session ID.
	The server can store an unlimited amount of data (typically up to 128 MB) in the session.
	Session data is automatically deleted when the user closes their browser or logs out.

Cookie:
	Cookies are small text files stored directly on the user's device.
	They can store limited amounts of data, usually up to 4 KB1.
	Cookies can be set to expire after a specific time or persist across multiple browsing sessions.
	They are sent with every HTTP request to the server.
```

#### 11. What is the spring security filter?

```
Spring Security filters form a chain of components that manage security for incoming HTTP requests.
Its key points are:
	Multiple filters in the chain, each handling a specific security task
	Filters intercept requests before they reach target resources
	Tasks include authentication, authorization, logging, and session management
	Requests pass through filters in a specific order
	Each filter processes the request and passes control to the next

Its purpose is to handle various security concerns such as authentication, authorization, CSRF protection, and exception handling.
The filters are executed in a specific order to ensure proper security processing.

It can be configured using the HttpSecurity DSL in Java configuration.

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Customizing filter chain by adding/removing filters
        http
            .authorizeRequests()
                .antMatchers("/login", "/register").permitAll()  // Allow public access to login/register
                .anyRequest().authenticated()  // Require authentication for other pages
            .and()
            .formLogin()
                .loginPage("/login")  // Specify custom login page
                .permitAll()  // Allow public access to login page
            .and()
            .logout()
                .permitAll()  // Allow public access to logout
            .and()
            .csrf().disable();  // Optionally disable CSRF protection for certain scenarios
    }
}

Its FilterChainProxy is that this class manages the entire set of security filters.

Its DelegatingFilterProxy is that it acts as a bridge between the servlet container and Spring's ApplicationContext.
It allows dynamic filter chain management.

The flow of the filter chain is:
	SecurityContextPersistenceFilter: 
		Manages the SecurityContext between requests.
	
	LogoutFilter: 
		Handles user logout requests.

	UsernamePasswordAuthenticationFilter: 
		Handles form-based authentication.

	BasicAuthenticationFilter: 
		Processes HTTP Basic authentication.

	ExceptionTranslationFilter: 
		Catches security exceptions and manages the response.

	FilterSecurityInterceptor: 
		Makes final authorization decisions.

	CsrfFilter: Handles CSRF token validation.
```

#### 12. Explain bearer token and how JWT works.

```
Bearer tokens and JSON Web Tokens (JWTs) are both used for authentication and authorization in web applications and APIs. 

A bearer token is a type of access token used in HTTP authentication schemes. 
	Access token used in HTTP authentication
	Grants access to protected resources
	Included in Authorization header
	Format: "Authorization: Bearer <token>"
	Should only be used over HTTPS

JWT (JSON Web Token):
	Secure method for transmitting information between parties
	Consists of three parts: header, Payload, Signature
	Self-contained token
	Allows stateless authentication
	Server can verify token without database query
	
The workflow is:
	Server generates token upon authentication
	Client receives and stores token
	Client sends token with each request
	Server validates token
	Grants/denies access based on token validity

Security Considerations:
	Use HTTPS
	Implement token expiration
	Protect secret keys
	Validate token on server-side
```

#### 13. Explain how do we store sensitive user information such as password and credit card number in DB?


```
Passwords:
    Use strong hashing algorithms: 
		Use algorithms like bcrypt, scrypt, or Argon2. Avoid using fast hashing algorithms like SHA family.
    Use a unique, random salt for each password.
    Never store passwords in plain text.

Credit Card Information:
	Consider tokenization:
		Store credit card data tokenized and encrypted to ensure it cannot be retrieved easily.
		Replace sensitive data with non-sensitive tokens for internal use.
		Store actual data securely in a separate, highly protected system.
	Use strong encryption algorithms to protect the information.
	Access controls:
		Restrict database access to only the necessary application processes.
		Use database permissions to limit who can view or modify the encrypted data.
    Never store CVV.
	Replace sensitive data with non-sensitive tokens for internal use.
    Comply with PCI-DSS regulations: 
		Follow industry standards for storing payment card information.

Encryption:
    Encrypt sensitive data both at rest (in the database) and in transit (during communication).
    Use AES-256 or other strong encryption algorithms for sensitive data.

Access Control:
    Implement fine-grained access control to ensure only authorized personnel can access sensitive data.
    Regularly audit access to sensitive information.

Key Management:
    Use secure key management practices, such as rotating keys periodically and storing them separately from encrypted data (e.g., using hardware security modules or cloud key management services).

Some other general solutions:
	Use encrypted connections (TLS) for all database communications.
	Regularly update and patch database systems.
	Implement strong authentication for database access.
	Monitor and audit database access and changes.

```

#### 14. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这⼏个名字看熟悉也⾏)

```
They are key components in Spring Security's authentication process.

UserDetailsService:
	Retrieves user details from a data source, such as database
	Implements the loadUserByUsername method to fetch user information
	Provides user data to AuthenticationProvider for verification
	Does not perform authentication itself

@Service
public class CustomUserDetailsService implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return new org.springframework.security.core.userdetails.User(
            user.getUsername(), 
            user.getPassword(), 
            user.getRoles().stream().map(role -> new SimpleGrantedAuthority(role.getName())).collect(Collectors.toList())
        );
    }
}

AuthenticationProvider:
	Performs the actual authentication logic
	Verifies credentials against stored user information
	Can use UserDetailsService to retrieve user data
	Supports different authentication mechanisms (e.g., username/password, token-based)
	Returns a fully populated Authentication object if authentication is successful

@Component
public class CustomAuthenticationProvider implements AuthenticationProvider {
    @Autowired
    private UserDetailsService userDetailsService;
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        String username = authentication.getName();
        String password = authentication.getCredentials().toString();
        
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        
        if (passwordEncoder.matches(password, userDetails.getPassword())) {
            return new UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities());
        } else {
            throw new BadCredentialsException("Invalid password");
        }
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return authentication.equals(UsernamePasswordAuthenticationToken.class);
    }
}

AuthenticationManager:
	Manages one or more AuthenticationProviders
	Delegates authentication requests to appropriate providers
	Often implemented by ProviderManager class
	Can be customized for complex authentication scenarios

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private CustomAuthenticationProvider authProvider;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authProvider);
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}

AuthenticationFilter:
	Intercepts incoming requests before they reach protected resources
	Extracts authentication credentials from the request
	Creates an Authentication object and passes it to AuthenticationManager
	Examples include BasicAuthenticationFilter for HTTP Basic auth and UsernamePasswordAuthenticationFilter for form-based login

public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) 
            throws AuthenticationException {
        String username = obtainUsername(request);
        String password = obtainPassword(request);
        
        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
        setDetails(request, authRequest);
        
        return this.getAuthenticationManager().authenticate(authRequest);
    }
}

```

#### 15. What is the disadvantage of Session? how to overcome the disadvantage?

```
The main disadvantages of using sessions are:
	Server resource consumption: Sessions require server-side storage, which can consume memory and processing power, especially with many concurrent users15.
	Scalability issues: Sessions can lead to uneven load distribution across servers and hinder horizontal scaling37.
	Reliability concerns: If a server goes down, all active sessions on that server are lost, impacting user experience7.
	Performance overhead: Serializing and deserializing session data can create additional processing overhead5.
	Limited persistence: Sessions typically end when the user closes their browser, which may not be ideal for all use cases1.

To overcome these disadvantages:
	Use database storage: 
		Store session data in a database instead of server memory to reduce resource consumption and improve scalability.
	Implement session cleanup: 
		Regularly clean up expired sessions to free up resources.
	Use distributed caching: 
		Employ distributed caching solutions to share session data across multiple servers, improving scalability and reliability.
	Consider alternatives: 
		Use cookies or client-side storage for non-sensitive data to reduce server load.
	Implement proper load balancing: 
		Use advanced load balancing techniques to distribute sessions evenly across servers.
	Use asynchronous approaches: 
		Use asynchronous communication methods to reduce the need for long-lived sessions.

These strategies, can help us to maintain user state and data security.
```

#### 16. how to get value from application.properties in Spring security?

```
Use the @Value annotation or the Environment interface

1, @Value:

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Value("${spring.security.user.name}")
    private String username;

    @Value("${spring.security.user.password}")
    private String password;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser(username)
            .password(passwordEncoder().encode(password))
            .roles("USER");
    }

}

2, Use Environment interface:

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private Environment env;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        String username = env.getProperty("spring.security.user.name");
        String password = env.getProperty("spring.security.user.password");

        auth.inMemoryAuthentication()
            .withUser(username)
            .password(passwordEncoder().encode(password))
            .roles("USER");
    }

    // Other configuration methods...
}

```

#### 17. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

```
1, configure(HttpSecurity http):
	Configures web-based security at a resource level
	Allows customization of incoming HTTP web-based requests
	Used to set up authorization rules for different URL patterns
	Enables features like form-based login, HTTP Basic authentication, and logout support
	Can be used to configure CSRF protection and other security headers

@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/public/**").permitAll()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .anyRequest().authenticated()
        .and()
        .formLogin()
        .and()
        .httpBasic();
}

2, configure(AuthenticationManagerBuilder auth):
	Used to configure the AuthenticationManager
	Sets up user authentication mechanisms
	Specifies how to retrieve user details and verify passwords
	Can configure in-memory, JDBC, or custom authentication providers

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .userDetailsService(customUserDetailsService)
        .passwordEncoder(passwordEncoder());
}

In Spring Security 5.4 and later, it's recommended to use SecurityFilterChain beans instead of extending WebSecurityConfigurerAdapter

```

#### 18. Reading, 泛读⼀下即可，⾃⼰觉得是重点的，可以多看两眼。https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern
	1. 1-12
	2. 17 - 30