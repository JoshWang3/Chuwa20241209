# hw13

---

## 1. Explain TLS, PKI, certificate, public key, private key, and signature.

### TLS (Transport Layer Security)
TLS is a cryptographic protocol that ensures secure communication over a network. It provides confidentiality, integrity, and authentication between communicating parties using encryption and digital certificates.

### PKI (Public Key Infrastructure)
PKI is a system that manages digital certificates and public-private key pairs. It provides a framework for secure communication by ensuring the authenticity and integrity of data through trusted certificate authorities (CAs).

### Certificate
A certificate is a digital document issued by a Certificate Authority (CA) that binds a public key to an entity (such as a website or organization). It contains information like the entity’s name, the public key, the issuing CA, and an expiration date.

### Public Key
The public key is part of a cryptographic key pair used in asymmetric encryption. It is shared publicly and used to encrypt data or verify digital signatures.

### Private Key
The private key is the secret counterpart to the public key. It is used to decrypt data encrypted with the public key and to create digital signatures.

### Signature
A digital signature is a cryptographic mechanism used to verify the authenticity and integrity of a message or document. It is created using the sender's private key and can be verified using the sender's public key.


## 2. List all http status codes that related to authentication and authorization failures.

### 401 Unauthorized
- Indicates that the request requires user authentication.
- The client must provide valid credentials to access the resource.
- Common causes: Missing, expired, or invalid authentication token.

### 403 Forbidden
- Indicates that the server understood the request but refuses to authorize it.
- Authentication may have been successful, but the user does not have permission to access the requested resource.
- Common causes: Insufficient privileges, access restrictions.

### 407 Proxy Authentication Required
- Similar to `401 Unauthorized`, but authentication must be provided to a proxy server.
- The client must authenticate with the proxy before making the request.

### 419 Authentication Timeout (Non-standard)
- Some web applications use this status to indicate session expiration.
- Not an official HTTP status code, but commonly used in frameworks like Laravel.

### 423 Locked
- Indicates that the resource is locked due to security restrictions or repeated failed authentication attempts.

### 429 Too Many Requests
- Occurs when the client exceeds the allowed number of authentication attempts in a given period.
- Common cause: Rate limiting of login requests to prevent brute force attacks.

### 451 Unavailable For Legal Reasons
- Access to the resource is denied due to legal restrictions or regulatory compliance.

### 499 Client Closed Request (Non-standard)
- Some servers use this status when the client closes the connection before completing authentication.


## 3. Compare authentication and authorization? Name and explain important components in Spring security that undertake authentication and authorization

### Authentication
- **Definition:** The process of verifying the identity of a user or system.
- **Purpose:** Ensures that the entity is who they claim to be.
- **Example:** Logging in with a username and password.
- **Common Methods:** Password-based, OAuth, SSO, biometrics.
- **HTTP Status Code:** `401 Unauthorized` (if authentication fails).

### Authorization
- **Definition:** The process of determining what actions or resources an authenticated user can access.
- **Purpose:** Grants or restricts permissions based on roles or policies.
- **Example:** Allowing an authenticated user to access admin resources.
- **Common Models:** Role-Based Access Control (RBAC), Attribute-Based Access Control (ABAC).
- **HTTP Status Code:** `403 Forbidden` (if authorization fails).

---

### Important Components in Spring Security for Authentication and Authorization

### 1. **AuthenticationManager**
- Central interface for handling authentication requests.
- Delegates authentication to different authentication providers.
- Example: `Authentication authentication = authenticationManager.authenticate(token);`

### 2. **UserDetailsService**
- Interface used to retrieve user details from a data source (e.g., database).
- Typically implemented to load users by username.
- Example:
  ```java
  public class CustomUserDetailsService implements UserDetailsService {
      @Override
      public UserDetails loadUserByUsername(String username) {
          // Load user from database
      }
  }
  ```

### 3. **UserDetails**
- Represents an authenticated user with details such as username, password, roles, and permissions.
- Example:
  ```java
  public class CustomUserDetails implements UserDetails {
      private String username;
      private String password;
      private Collection<? extends GrantedAuthority> authorities;
      // Implement required methods
  }
  ```

### 4. **GrantedAuthority**
- Represents an authority or role assigned to the user.
- Example: `ROLE_USER`, `ROLE_ADMIN`.

### 5. **SecurityContextHolder**
- Stores security-related information for the current request (authentication details).
- Example: `SecurityContextHolder.getContext().getAuthentication();`

### 6. **AuthenticationProvider**
- Processes authentication requests and validates credentials.
- Example: Custom implementations for integrating with LDAP, OAuth, etc.

### 7. **FilterSecurityInterceptor**
- Intercepts requests and checks for authorization before allowing access.
- Applies security rules based on URL patterns and roles.

### 8. **AccessDecisionManager**
- Determines whether a user has access to a particular resource.
- Works with `AccessDecisionVoter` to evaluate permissions.

### 9. **HttpSecurity**
- Configures security settings for web applications, such as login, logout, CSRF, and session management.
- Example:
  ```java
  @Configuration
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http
              .authorizeRequests()
                  .antMatchers("/admin/**").hasRole("ADMIN")
                  .anyRequest().authenticated()
              .and()
              .formLogin();
      }
  }
  ```

### 10. **SecurityContext**
- Holds authentication information across multiple requests within a session.


## 3. Explain HTTP Session?

### What is an HTTP Session?
An HTTP session is a mechanism to maintain state and store user-specific data across multiple requests in a web application. Since HTTP is stateless by design, sessions help in associating multiple requests from the same client with a stored context.

### How HTTP Sessions Work
1. **Client Makes a Request:**
    - The user sends an HTTP request to the server (e.g., login request).

2. **Session Creation:**
    - If the user is authenticated, the server creates a session and assigns a unique `Session ID`.

3. **Session ID Storage:**
    - The `Session ID` is usually stored on the client-side as a cookie (`JSESSIONID` in Java applications).
    - Alternatively, it can be passed via URL query parameters (less secure).

4. **Subsequent Requests:**
    - The client includes the session ID in every request.
    - The server retrieves the session associated with the ID and provides the stored data.

5. **Session Expiry/Termination:**
    - Sessions have a defined timeout period.
    - The session can be invalidated manually by logging out or automatically after a period of inactivity.

---

### Session Storage Mechanisms
1. **In-Memory Sessions:** Stored in the server's memory (default for most web frameworks).
2. **Database-backed Sessions:** Persisted in a database for scalability and fault tolerance.
3. **Distributed Cache Sessions:** Stored in distributed caches like Redis or Memcached for scalability.

---

### Session Management in Java (Servlets)
Example of session handling in a Java Servlet:

```java
protected void doGet(HttpServletRequest request, HttpServletResponse response) {
    HttpSession session = request.getSession();
    session.setAttribute("username", "JohnDoe");

    String user = (String) session.getAttribute("username");
    response.getWriter().println("Hello, " + user);
}
```


## 4. Explain Cookie?

### What is a Cookie?
A cookie is a small piece of data stored by a web browser that allows websites to remember information about a user across multiple requests and visits. Cookies help maintain stateful information in an otherwise stateless HTTP protocol.

### How Cookies Work
1. **Server Sends a Cookie:**
    - When a client makes an HTTP request, the server responds with a `Set-Cookie` header.
    - Example:
      ```
      Set-Cookie: session_id=abc123; Path=/; HttpOnly; Secure; Max-Age=3600
      ```

2. **Browser Stores the Cookie:**
    - The browser saves the cookie and includes it in subsequent requests to the same domain.

3. **Client Sends a Cookie:**
    - On the next request, the browser automatically sends the stored cookie using the `Cookie` header.
    - Example:
      ```
      Cookie: session_id=abc123
      ```

---

### Types of Cookies
1. **Session Cookies:**
    - Stored in memory and deleted when the browser is closed.
    - Used for temporary information (e.g., login sessions).

2. **Persistent Cookies:**
    - Stored on the user's device for a specified duration.
    - Used for remembering preferences and login states.
    - Example: `Max-Age=3600` (expires after 1 hour).

3. **Secure Cookies:**
    - Transmitted only over HTTPS to prevent interception.
    - Set using the `Secure` attribute.

4. **HttpOnly Cookies:**
    - Cannot be accessed via JavaScript, reducing the risk of XSS attacks.
    - Set using the `HttpOnly` attribute.

5. **SameSite Cookies:**
    - Helps prevent Cross-Site Request Forgery (CSRF) attacks.
    - Options:
        - `Strict`: Cookies sent only from the same origin.
        - `Lax`: Cookies sent with top-level navigation requests.
        - `None`: Cookies sent across all contexts (requires `Secure` attribute).

6. **Third-Party Cookies:**
    - Set by domains other than the one the user is visiting (e.g., ads, trackers).
    - Used for cross-site tracking and targeted advertising.

---

### Cookie Attributes
| Attribute    | Description                                          |
|--------------|------------------------------------------------------|
| `Name=Value` | Stores the cookie data.                              |
| `Path`       | Specifies the URL path where the cookie is valid.    |
| `Domain`     | Specifies the domain the cookie applies to.          |
| `Max-Age`    | Defines the lifespan of the cookie in seconds.       |
| `Expires`    | Sets the expiration date of the cookie.              |
| `Secure`     | Ensures the cookie is sent only over HTTPS.          |
| `HttpOnly`   | Prevents JavaScript access to the cookie.            |
| `SameSite`   | Controls cross-site cookie behavior to prevent CSRF. |

---

### Example Set-Cookie Header
```http
Set-Cookie: user_id=12345; Path=/; Domain=example.com; Secure; HttpOnly; SameSite=Strict; Max-Age=3600
```


## 5. Comparison of Session and Cookie

### 1. Definition
- **Session:** A server-side mechanism that stores user-specific data to persist state across multiple requests.
- **Cookie:** A client-side storage mechanism that stores small pieces of data in the user's browser.

---

### 2. Storage Location
| Feature | Session     | Cookie                |
|---------|-------------|-----------------------|
| Storage | Server-side | Client-side (browser) |

---

### 3. Data Size
| Feature | Session                             | Cookie                    |
|---------|-------------------------------------|---------------------------|
| Limit   | Large (depends on server resources) | Small (usually up to 4KB) |

---

### 4. Security
| Feature        | Session                                   | Cookie                                             |
|----------------|-------------------------------------------|----------------------------------------------------|
| Security Level | More secure (data stored on server)       | Less secure (can be modified by client)            |
| Protection     | Cannot be accessed by the client directly | Vulnerable to XSS attacks if not secured           |
| Secure Options | Managed by server policies                | Can use `HttpOnly`, `Secure`, and `SameSite` flags |

---

### 5. Lifespan
| Feature     | Session                                   | Cookie                                      |
|-------------|-------------------------------------------|---------------------------------------------|
| Lifetime    | Until user logs out or session expires    | Defined by `Expires` or `Max-Age` attribute |
| Persistence | Ends when the browser is closed (default) | Can persist even after browser closure      |

---

## 6. Accessibility
| Feature | Session     | Cookie                             |
|---------|-------------|------------------------------------|
| Access  | Server only | Accessible by browser (JavaScript) |

---

## 7. Performance
| Feature     | Session                            | Cookie                               |
|-------------|------------------------------------|--------------------------------------|
| Server Load | Higher (stores data on the server) | Lower (stored on the client)         |
| Client Load | Lower                              | Higher (data sent with each request) |

---

## 8. Use Cases
| Use Case                  | Session                             | Cookie                             |
|---------------------------|-------------------------------------|------------------------------------|
| User Authentication       | Stores logged-in user info securely | Can store authentication token     |
| Shopping Cart             | Stores items temporarily            | Stores cart ID                     |
| Tracking User Preferences | Not ideal (needs persistence)       | Stores language preferences, theme |
| Analytics and Tracking    | Not suitable                        | Used for tracking across sites     |

---

## 9. Expiration and Deletion
| Feature    | Session                               | Cookie                                 |
|------------|---------------------------------------|----------------------------------------|
| Expiration | Set by server configuration           | Controlled by `Expires` or `Max-Age`   |
| Deletion   | Session invalidation (logout/timeout) | Deleted via browser settings or expiry |

---

## 10. Example Usage

### Session Example in Java (Servlet)
```java
HttpSession session = request.getSession();
session.setAttribute("username", "JohnDoe");
String username = (String) session.getAttribute("username");
```

## 6. How do we use session and cookie to keep user information across the the application?

### 1. Using Sessions
Sessions store user information on the **server**, and a unique session ID is sent to the client via a cookie to track user activity.

### Steps to Use:
1. **User Logs In:**
    - The server creates a session and stores user data (e.g., username, roles).

2. **Session ID Sent:**
    - The server sends a `session_id` to the client as a cookie.

3. **Subsequent Requests:**
    - The client includes the session ID in each request.
    - The server retrieves session data using the session ID.

4. **Session Expiration:**
    - Sessions expire after a defined timeout or when the user logs out.

### Example (Java Servlet):
```java
HttpSession session = request.getSession();
session.setAttribute("username", "JohnDoe");

String username = (String) session.getAttribute("username");
```

### 2. Using Cookies
Cookies store user information on the client-side, allowing state persistence across requests.

### Steps to Use:
1. **User Logs In:**
    - The server sets a cookie with user-related data or a session ID.

2. **Cookie Storage:**
    - The browser stores the cookie and includes it in future requests.

3. **Cookie Expiration:**
    - Cookies persist based on the expiration time set by the server.

### 3. Combining Session and Cookie
   A common practice is to use cookies to store session IDs, which link to session data stored on the server.

- Flow:
1. User logs in → The server creates a session.
2. Server sends session_id in a cookie.
3. Client includes the cookie in subsequent requests.
4. Server retrieves user info using the session ID.

**Conclusion**
- Use sessions for storing sensitive data securely on the server.
- Use cookies for lightweight data storage and tracking user preferences.
- Combine both for enhanced security and persistence.

## 7. What is the spring security filter?

### What is the Spring Security Filter?
The Spring Security filter is a core component of Spring Security that intercepts incoming HTTP requests and applies security measures such as authentication and authorization before passing requests to the application.

---

### Key Responsibilities:
1. **Authentication:**
    - Verifies user credentials (e.g., username/password, tokens).
    - Delegates to authentication providers.

2. **Authorization:**
    - Checks if the authenticated user has the required permissions to access resources.

3. **Session Management:**
    - Tracks user sessions and prevents session fixation attacks.

4. **CSRF Protection:**
    - Defends against Cross-Site Request Forgery attacks.

5. **Security Headers:**
    - Adds security headers (e.g., `X-Frame-Options`, `Content-Security-Policy`).

6. **Exception Handling:**
    - Handles security-related errors and access denial responses.

---

### Spring Security Filter Chain
Spring Security uses a **filter chain**, where multiple filters are applied sequentially. Some key filters include:

| Filter                                 | Description                                      |
|----------------------------------------|--------------------------------------------------|
| `SecurityContextPersistenceFilter`     | Loads security context from session storage.     |
| `UsernamePasswordAuthenticationFilter` | Processes username/password login requests.      |
| `BasicAuthenticationFilter`            | Handles HTTP Basic authentication.               |
| `BearerTokenAuthenticationFilter`      | Validates JWT or OAuth2 tokens.                  |
| `ExceptionTranslationFilter`           | Handles authentication and authorization errors. |
| `FilterSecurityInterceptor`            | Enforces access control policies.                |

---

### Customizing the Security Filter Chain
Spring Security allows customizing the filter chain via `SecurityFilterChain`:

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .anyRequest().authenticated()
        .and()
        .formLogin();
    return http.build();
}
```

**Conclusion**
Spring Security filters provide a powerful mechanism to secure web applications by intercepting and processing requests to enforce authentication, authorization, and other security measures.


## 8. Explain bearer token and how JWT works.

### What is a Bearer Token?
A **Bearer Token** is an access token used to authenticate requests to a server. The term "bearer" means that whoever possesses the token can access the associated resources without additional credentials. Typically, the token is included in the HTTP `Authorization` header as follows:

```http
Authorization: Bearer <token>
```

### How JWT Works
- JSON Web Token (JWT) is a compact and self-contained way to represent claims securely between two parties. It consists of three parts:

1. Header – Specifies the token type (JWT) and the signing algorithm (e.g., HS256).
```json
{
  "alg": "HS256",
  "typ": "JWT"
}

```

2. Payload – Contains claims (user data, roles, expiration, etc.).
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "exp": 1712345678
}
```

3. Signature – Ensures token integrity using a secret key or a public/private key pair.
```plaintext
HMACSHA256(
base64UrlEncode(header) + "." + base64UrlEncode(payload),
secret
)
```

## 9. Explain how do we store sensitive user information such as password and credit card number in DB?

To securely store sensitive user information such as passwords and credit card numbers in a database, best practices must be followed to protect against data breaches and unauthorized access.

---

### 1. Storing Passwords

### Best Practices:
1. **Hashing:**
    - Use a strong, one-way cryptographic hash function to store passwords securely.
    - Recommended algorithms: `bcrypt`, `argon2`, `PBKDF2`.
    - Example using bcrypt in Java:
      ```java
      String hashedPassword = BCrypt.hashpw("user_password", BCrypt.gensalt());
      ```

2. **Salting:**
    - A unique, random salt should be added to each password before hashing to prevent rainbow table attacks.
    - Most modern hashing algorithms like bcrypt include salt by default.

3. **Peppering:**
    - An additional secret value (pepper) can be added to passwords before hashing, stored securely in environment variables.

4. **Password Policies:**
    - Enforce strong password requirements (length, complexity).
    - Implement password expiration and rotation policies.

---

### 2. Storing Credit Card Numbers

### Best Practices:
1. **Encryption:**
    - Store credit card numbers using strong encryption algorithms such as `AES-256`.
    - Example using Java AES encryption:
      ```java
      Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
      SecretKey secretKey = new SecretKeySpec(keyBytes, "AES");
      ```

2. **Tokenization:**
    - Replace sensitive credit card numbers with unique tokens to reduce risk exposure.
    - The original data is stored securely in a separate, encrypted vault.

3. **Truncation:**
    - Store only the last four digits of the credit card number to minimize risk.

4. **Access Control:**
    - Limit access to encrypted credit card data using strict access controls and role-based permissions.

5. **Compliance:**
    - Follow **PCI DSS** (Payment Card Industry Data Security Standard) guidelines to ensure compliance and data security.

---

### 3. General Security Measures

1. **Use Secure Database Storage:**
    - Enable database encryption features (e.g., TDE - Transparent Data Encryption).
    - Regularly update and patch the database software.

2. **Data Masking:**
    - Display only masked versions of sensitive data in UI or logs (e.g., `****1234` for credit card numbers).

3. **Access Control:**
    - Implement strict role-based access control (RBAC).
    - Use multi-factor authentication (MFA) for accessing sensitive data.

4. **Logging and Monitoring:**
    - Audit database access and monitor for suspicious activity.

5. **Regular Backups and Secure Storage:**
    - Encrypt backups and store them securely offsite.

---

### Conclusion
To securely store sensitive user data such as passwords and credit card numbers, it is essential to use strong encryption, hashing with salting, access control, and compliance with industry security standards like PCI DSS.


## 10. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?

### Summary Comparison

| **Component**            | **Purpose**                       | **Key Responsibility**                     | **Common Usage**                     |
|--------------------------|-----------------------------------|--------------------------------------------|--------------------------------------|
| `UserDetailsService`     | Load user information             | Fetch user credentials and roles           | Database lookups for authentication  |
| `AuthenticationProvider` | Authenticate user credentials     | Validate user and create authentication    | Custom authentication logic          |
| `AuthenticationManager`  | Manage authentication providers   | Delegate to appropriate providers          | Handle multiple authentication types |
| `AuthenticationFilter`   | Intercept authentication requests | Extract and process authentication details | Secure incoming HTTP requests        |

---

## 11. What is the disadvantage of Session? how to overcome the disadvantage?
### Disadvantages of Session and Solutions

### 1. Increased Server Load
**Disadvantage:**
- Sessions are stored on the server, leading to higher memory usage and performance issues as the number of users increases.

**Solution:**
- Use **distributed session storage** (e.g., Redis, Memcached) to offload session data from application servers.

---

### 2. Scalability Issues
**Disadvantage:**
- Sessions tied to a single server make scaling difficult in distributed environments (e.g., load balancing).

**Solution:**
- Implement **sticky sessions** in load balancers or store sessions in a **centralized session store** (e.g., database, cache).

---

### 3. Security Risks
**Disadvantage:**
- Sessions are vulnerable to **session hijacking** and **session fixation** attacks if not properly secured.

**Solution:**
- Use secure session management practices, such as:
    - Regenerating session IDs after login.
    - Enforcing **HTTP-only** and **Secure** flags in cookies.
    - Implementing session expiration and logout mechanisms.

---

### 4. Dependency on Cookies
**Disadvantage:**
- Session tracking often relies on cookies, which may be blocked by browsers or cleared by users.

**Solution:**
- Use **URL rewriting** or hidden form fields as fallback mechanisms for session tracking.

---

### 5. Session Expiry and Data Loss
**Disadvantage:**
- Sessions expire after a defined period, leading to user data loss and a poor user experience.

**Solution:**
- Extend session duration dynamically based on user activity.
- Store critical session data in persistent storage.

---

### 6. Storage Limitations
**Disadvantage:**
- Some session storage mechanisms (e.g., in-memory) have limited capacity, leading to potential data loss or performance degradation.

**Solution:**
- Store only essential data in sessions and offload large data to a database or caching system.

---

### Conclusion
While sessions provide an effective way to maintain user state, their disadvantages can be mitigated through techniques such as distributed storage, secure session management, and scalable architectures.

## 12. how to get value from application.properties in Spring security?

Spring Security allows retrieving values from the `application.properties` file using different methods, such as `@Value` annotation, `@ConfigurationProperties`, and the `Environment` object.

---

### 1. Using `@Value` Annotation
Spring's `@Value` annotation can be used to inject property values directly into Spring Security configurations.

**Example:**
```properties
# application.properties
security.jwt.secret=mySecretKey
```
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SecurityConfig {

    @Value("${security.jwt.secret}")
    private String jwtSecret;

    public String getJwtSecret() {
        return jwtSecret;
    }
}
```

2. Using @ConfigurationProperties
The @ConfigurationProperties annotation binds a set of properties to a configuration class.
   **Example:**
```properties
# application.properties
security.jwt.secret=mySecretKey
security.jwt.expiration=3600

```
```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "security.jwt")
public class JwtProperties {
    private String secret;
    private int expiration;

    // Getters and Setters
    public String getSecret() { return secret; }
    public void setSecret(String secret) { this.secret = secret; }

    public int getExpiration() { return expiration; }
    public void setExpiration(int expiration) { this.expiration = expiration; }
}
```
3. Using Environment Object
The Environment interface can be used to programmatically access property values.
```java
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class SecurityConfig {

    private final Environment environment;

    public SecurityConfig(Environment environment) {
        this.environment = environment;
    }

    public String getJwtSecret() {
        return environment.getProperty("security.jwt.secret");
    }
}
```

## 13. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

### Role of `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)`

### 1. `configure(HttpSecurity http)`

**Purpose:**  
Configures security settings for HTTP requests, specifying authentication, authorization, and security features.

**Key Responsibilities:**
- Define access control rules for URL patterns.
- Configure authentication methods (e.g., form login, basic auth, OAuth).
- Enable or disable security features such as CSRF, CORS, and session management.

**Example:**
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/user/**").authenticated()
            .antMatchers("/public/**").permitAll()
        .and()
        .formLogin()
        .and()
        .logout();
}
```

### 2. configure(AuthenticationManagerBuilder auth)
**Purpose:**  
Configures authentication mechanisms, such as user credentials, authentication providers, and password encoding.

**Key Responsibilities:**
- Set up in-memory, database, or LDAP-based authentication.
- Define user credentials and roles.
- Configure password encoders.
```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
            .withUser("admin").password("{noop}admin123").roles("ADMIN")
        .and()
            .withUser("user").password("{noop}user123").roles("USER");
}
```





















