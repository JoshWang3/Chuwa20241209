# HW13
____
### 2. Explain TLS, PKI, certificate, public key,private key,and signature.
- TLS (Transport Layer Security): a protocol that provides secure communication over a network, ensuring confidentiality, data integrity and authentication.
- PKI (Public Key Infrastructure): a framework to create and validate certificates and public/private key pairs. It creates, manages, distributes, uses, stores and revokes certificates and manages public-key encryption.
- Certificate: a digital document that binds a public key to an identity, issued by a trusted third party called a Certificate Authority (CA). It contains public keys, subject, issuer, serial number and validity period.
- Public Key: a key used for encrypting data, it is shared with others.
- Private Key: a key used for decrypting data, it is kept secret, only known to the owner.
- Signature: a cryptographic value that is generated using a private key to verify the authenticity and integrity of a message or document.

### 4. list all http status codes that related to authentication and authorization failures.
- 401 Unauthorized: The request requires user authentication.
- 403 Forbidden: The server understood the request, but refuses to authorize it.
- 407 Proxy Authentication Required: The client must first authenticate itself with the proxy.
- 419 Authentication Timeout: The session has expired and the user needs to log in again.
- 423 Locked: The resource that is being accessed is locked and may require additional permissions to unlock.
- 429 Too Many Requests: The user has sent too many requests in a given amount of time, and may need to wait before making additional requests.

### 5. Compare authentication and authorization. Name and explain important components in Spring security that undertake authentication and authorization.
- Authentication: the process of verifying the identity of a user or system.
- Authorization: the process of determining whether a user or system has permission to access a resource or perform an action.
In Spring, the important components that undertake authentication and authorization are:
- AuthenticationManager: an interface that is responsible for authenticating users.
- AuthenticationProvider: an interface that is responsible for providing authentication information.
- SecurityContext: a container for security-related information, including authentication and authorization information.
- UserDetailsService: an interface that is responsible for loading user-specific data.
- GrantedAuthority: an interface that represents an authority granted to an Authentication object.

### 6. Explain HTTP Session

A session is a server-side storage mechanism used to maintain state across multiple requests from the same server. When a user logs into a web application or performs an action that requires state 
management, a session is created on the server. A unique session id is generated and sent to the client as a cookie or sometimes as part of the url.

### 7. Explain Cookie

A cookie is a small piece of data sent from a web server to a user's browser. The browser stores the cookie and sends it back with each subsequent request to the 
same server. This allows the server to identify and track users and remember their preferences or other data.

### 8. Compare session and cookie

- Session:
    - Server-side storage mechanism.
    - Stores data on the server.
    - More secure, as data is not exposed to the client.
    - Can store large amounts of data.
    - Requires more server resources.
- Cookie:
    - Client-side storage mechanism.
    - Stores data on the client.
    - Less secure, as data is exposed to the client.
    - Limited storage capacity.
    - Requires less server resources.

### 9. Find at least TWO websites which can be logged in using your Google Account, explain in detail on how Google SSO works with screenshots like below, find SSO-related Rest calls in Chrome developer tool:

- Websites for Google login: YouTube, Google Drive
- SSO: Single Sign-On (SSO) is a user authentication process that allows a user to access multiple applications with one set of login credentials.
- How it works: 
1. User clicks on the "Sign in with Google" button on the website.
2. The website redirects the user to the Google login page.
3. User enters their Google credentials and clicks "Sign in".
4. Google authenticates the user and generates an access token.
5. Google redirects the user back to the website with the access token.
6. The website uses the access token to authenticate the user and grant access to the application.
7. The user is now logged in to the website using their Google account.

### 10. How do we use session and cookie to keep user info across the application
- Session: We can use session to store user information on the server side after they log in. For example, we can store the user's id, name, and email in the session. This allows us to access the user's information across different pages of the application.
- Cookie: We can use cookies to store user information on the client side. For example, we can store the user's id, name, and email in a cookie. This allows us to access the user's information across different pages of the application without having to store it on the server.

### 11. What is the spring security filter
The Spring Security filter is a component that intercepts incoming requests and applies security checks before allowing the request to proceed to the application. It is responsible for authentication, authorization, and other security-related tasks. The filter chain is configured in the web.xml file or through Java configuration. 
For example:
```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/user/**").hasRole("USER")
                .anyRequest().authenticated()
            .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
            .and()
            .logout()
                .permitAll();
    }
}
```

### 12. Explain bearer token and how JWT works
- Bearer Token: a token included in the authorization header of an HTTP request to authenticate the user.
- JWT (JSON Web Token): a compact, URL-safe means of representing claims to be transferred between two parties. It consists of three parts: header, payload, and signature.

1. The client sends a POST request to the server with the user's credentials.
2. The server verifies the credentials and generates a JWT and sends it back to the client.
3. The client GETs the resource by including the JWT in the authorization header.
4. The server verifies the JWT and grants access to the resource and returns the response.

### 13. Explain how do we store sensitive user information such as password and credit card number in DB?

- Hashing: use hashing algorithms like bcrypt or Argon2 to hash passwords before storing them in the database. This ensures that even if the database is compromised, the passwords are not exposed.
- Encryption: use encryption algorithms like AES to encrypt sensitive information like credit card numbers before storing them in the database. This requires a key to decrypt.
- Secure Connections: use secure connections like HTTPS to transmit sensitive information between the client and server.
- Access Control: Limit access to sensitive data to authorized users only.

### 14. Compare UserDetailsService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter.

- UserDetailsService: an interface that is responsible for loading user-specific data. It is used to retrieve user information from the database.
- AuthenticationProvider: an interface that is responsible for providing authentication information. It is used to authenticate users based on their credentials.
- AuthenticationManager: an interface that is responsible for authenticating users. It is used to authenticate users based on their credentials and returns an Authentication object.
- AuthenticationFilter: a filter that intercepts incoming requests and applies authentication checks before allowing the request to proceed to the application. It is responsible for extracting authentication information from the request and passing it to the AuthenticationManager for authentication.

### 15. What is the disadvantage of Session? How to overcome the disadvantage?
Sessions can consume a lot of server resources, especially if there are many concurrent users. This can lead to performance issues and scalability problems.  
To overcome, we can use distributed session stores like redis to share session data across servers. We can also use stateless authentication methods like JWT to reduce server-side storage.

### 16. How to get a value from application.properties in Spring Security?
Use @Value annotation:
```java
@Value("${property.name}")
private String propertyName;
```

### 17. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?
- configure(HttpSecurity http): used to configure the security settings for HTTP requests, such as authorization rules, login and logout settings, and CSRF protection.
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/user/**").hasRole("USER")
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .loginPage("/login")
            .permitAll()
        .and()
        .logout()
            .permitAll();
}
```
- configure(AuthenticationManagerBuilder auth): used to configure the authentication settings, such as user details service, password encoder, and authentication providers.
```java
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth
        .inMemoryAuthentication()
            .withUser("user").password(passwordEncoder().encode("password")).roles("USER")
        .and()
            .withUser("admin").password(passwordEncoder().encode("password")).roles("ADMIN");
}
```







































