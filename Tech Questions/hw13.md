### 1. List all of the annotations you learned from class and homework to annotaitons.md

### 2. Explain TLS, PKI, certificate, public key, private key, and signature.

---

**TLS (Transport Layer Security):**  
A secure communication protocol that encrypts data exchanged over a network (e.g., between browser and server). It ensures that data remains private, untampered, and authenticated during transmission.

---

**PKI (Public Key Infrastructure):**  
A system used to issue, manage, and validate digital certificates. PKI supports secure communication by binding public keys with verified identities, often through trusted Certificate Authorities (CAs).

---

**Certificate:**  
A digital file that confirms the identity of an individual, organization, or website. It includes a public key, identity information, and a digital signature from a CA to prove it's trustworthy.

---

**Public Key:**  
A cryptographic key that is shared openly and used to encrypt data or verify digital signatures. Only the matching private key can decrypt the data encrypted with this public key.

---

**Private Key:**  
A secret cryptographic key kept by the owner. It is used to decrypt data encrypted with the corresponding public key or to create digital signatures that prove ownership.

---

**Signature (Digital Signature):**  
A secure value generated using a private key. It confirms that the message or document hasn’t been altered and that it came from the holder of the private key. The signature can be verified using the sender’s public key.

---

### Summary:

TLS secures data transmission, while PKI supports it by managing certificates. Certificates link public keys with identities, and public/private key pairs enable secure encryption and authentication through digital signatures.

### 3. Write a Spring security based application, which provides https APIs (one simple get controller with empty response is good enough )instead of http, please generate a self-signed certificate to make your https TLS verfication work.

### 1. Pack your self-signed certificate in the form of jks file, as part of your application, name it properly

### 2. Test if you can verify your HTTPs api without importing the self-signed certificate to your local certificate chain, if not, explain why.

No, you **cannot verify** an HTTPS API that uses a self-signed certificate unless you **manually import** that certificate into your local trust store (e.g., browser or JVM).

---

### Why?

- In HTTPS, the client (e.g., browser, Postman, Java) checks if the server’s certificate is **trusted**.
- A self-signed certificate is **not signed by a trusted Certificate Authority (CA)**.
- Since it doesn’t chain back to a trusted root, your system will **reject the connection** or show a warning (like "untrusted certificate").

---

### Solution:

To trust the self-signed certificate:

1. Export the certificate from the server.
2. Import it into your local machine’s trust store or tool (e.g., Java `cacerts`, Postman, or browser).

---

### Summary:

- HTTPS requires trusted certificates.
- Self-signed certificates are not trusted by default.
- You must manually add them to your local trust store to avoid connection errors.

### 3. Explain what did you do to make https call work, do NOT bypass TLS/SSL verfication in Postman (this is cheating)!

#### Tutorial: https://www.baeldung.com/spring-channel-security-https

- Exported the Self-Signed Certificate
- Saved the Certificate Locally
- Imported the Certificate to Trust Store
- Restarted Tools

### 4. list all http status codes that related to authentication and authorization failures.

| Status Code | Meaning                               | When It Occurs                      |
| ----------- | ------------------------------------- | ----------------------------------- |
| 401         | Unauthorized                          | Not logged in / invalid credentials |
| 403         | Forbidden                             | Logged in, but lacks permission     |
| 407         | Proxy Authentication Required         | Proxy server demands authentication |
| 419         | Authentication Timeout (non-standard) | Session/token expired (custom use)  |

### 5. Compare authentication and authorization? Name and explain important components in Spring security that undertake authentication and authorization

### Authentication vs Authorization:

| Concept      | Authentication                | Authorization                        |
| ------------ | ----------------------------- | ------------------------------------ |
| What         | Verifying **who** the user is | Verifying **what** the user can do   |
| Happens When | First                         | After authentication                 |
| Example      | Login with username/password  | Access control to admin endpoints    |
| Result       | Creates a security context    | Grants or denies access to resources |

---

### Key Components in Spring Security:

1. **AuthenticationManager**

   - Responsible for handling authentication logic.
   - Verifies credentials and returns an `Authentication` object.

2. **UserDetailsService**

   - Loads user-specific data by username.
   - Used during authentication to fetch user info (e.g., roles, password).

3. **SecurityContext**

   - Holds authentication details (e.g., user identity, roles).
   - Thread-local, accessible throughout the app during a request.

4. **SecurityContextHolder**

   - Gives access to the `SecurityContext`.
   - Used to fetch the currently authenticated user.

5. **GrantedAuthority**

   - Represents a user’s permission or role (e.g., `"ROLE_ADMIN"`).
   - Used for authorization checks.

6. **Authentication**

   - Interface representing the current authentication state.
   - Contains principal (user), credentials, and authorities.

7. **FilterChain (e.g., UsernamePasswordAuthenticationFilter)**
   - Processes security filters like login, JWT, CSRF, etc.

### 6. Explain HTTP Session?

- An **HTTP session** is a server-side storage mechanism used to maintain **user state** across multiple HTTP requests.
- Since HTTP is **stateless**, sessions help track information like logged-in users, shopping carts, etc.

---

### How It Works:

1. Client sends a request (e.g., login).
2. Server creates a session and assigns a **unique session ID**.
3. Session ID is sent to the client via a **cookie** (usually `JSESSIONID`).
4. On subsequent requests, the client sends back the session ID.
5. Server uses that ID to retrieve the session data.

---

### Example Use Cases:

- Remember logged-in user
- Store shopping cart items
- Track user preferences during a visit

---

### 7. Explain Cookie?

- A **cookie** is a small piece of data stored on the **client side** (browser).
- It is used to **remember information** across multiple HTTP requests, such as login status, preferences, or tracking IDs.

### 8. Compare Session and Cookie?

---

| Feature           | Session                               | Cookie                                   |
| ----------------- | ------------------------------------- | ---------------------------------------- |
| Storage Location  | Server-side                           | Client-side (browser)                    |
| Data Size Limit   | Large (limited by server memory)      | Small (typically ≤ 4KB)                  |
| Security          | More secure (data not exposed)        | Less secure (data visible to client)     |
| Used For          | Storing user state like login info    | Storing small data like tokens, prefs    |
| Lifetime Control  | Managed by server                     | Controlled via `Expires` or `Max-Age`    |
| Performance       | Slightly heavier (server memory used) | Lightweight (stored in browser)          |
| Automatic Sending | No (uses session ID in cookie)        | Yes (browser sends it with each request) |

---

### 9. Find at least TWO websites who can be logged in using your Google Account, explain in detail on how Google SSO works with screenshots like below, find SSO-related Rest calls in Chrome developer tool:

### Example Websites Using Google SSO:

1. **Medium** (https://medium.com)
2. **Stack Overflow** (https://stackoverflow.com)

---

### How Google SSO Works (Simplified Flow):

1. **User Clicks "Sign in with Google"**

   - Redirects to Google’s OAuth 2.0 authorization endpoint.

2. **Google Auth Page**

   - User logs into Google and grants permission to share profile info.

3. **Authorization Code Returned**

   - Google redirects back to the application with an **auth code** in the URL.

4. **Backend Exchanges Code for Access Token**

   - The app’s backend sends a secure request to Google’s token endpoint to get an **access token** and optionally a **refresh token**.

5. **Access Token Used to Get User Info**

   - Backend makes an API call to Google (e.g., `https://www.googleapis.com/oauth2/v2/userinfo`) to get user profile data.

6. **Session or JWT Created**
   - App logs the user in using the returned info (email, name, etc.) and creates a local session or JWT.

---

### How to Inspect in Chrome DevTools:

1. Open Chrome → Right-click → Inspect → Network tab.
2. Click "Sign in with Google" on a website.
3. Look for requests to:
   - `https://accounts.google.com/o/oauth2/v2/auth` (auth request)
   - `https://oauth2.googleapis.com/token` (token exchange)
   - `https://www.googleapis.com/oauth2/v2/userinfo` (user profile)

---

### Key REST Calls You May See:

- **GET** request to:

  ```
  https://accounts.google.com/o/oauth2/v2/auth
  ```

- **POST** request to:

  ```
  https://oauth2.googleapis.com/token
  ```

- **GET** request to:
  ```
  https://www.googleapis.com/oauth2/v2/userinfo
  ```

These calls confirm that the website is using Google SSO for login.

---

### 10. How do we use session and cookie to keep user information across the the application?

- They allow an application to “remember” and authenticate users across multiple---

- **Session** stores user information (like login status) on the **server**.
- A **cookie** (usually `JSESSIONID`) is sent to the client to identify the session.

---

### How It Works:

1. User logs in → Server creates a session.
2. Server stores user data in the session.
3. Server sends a cookie with session ID to the client.
4. On each request, the browser sends the cookie.
5. Server uses session ID from cookie to retrieve user data.

### 11. What is the spring security filter?

- A **Spring Security filter** is part of the filter chain that processes HTTP requests before they reach your controller.
- It handles security tasks like **authentication**, **authorization**, **session management**, and **CSRF protection**.

### 12. Explain bearer token and how JWT works.

- A **bearer token** is a type of access token included in the HTTP `Authorization` header.
- It tells the server: "The holder of this token is authorized."

---

### What is JWT (JSON Web Token)?

- JWT is a **self-contained token** used for authentication and authorization.
- It contains **user information** and is digitally **signed** to ensure it hasn’t been tampered with.

---

### JWT Structure (Three Parts):

1. **Header** – type of token (JWT) and algorithm (e.g., HS256)
2. **Payload** – user data (e.g., id, roles, expiration)
3. **Signature** – created using the header, payload, and a secret key

---

### How JWT Works:

1. User logs in → server generates JWT and sends it to the client.
2. Client stores the JWT (e.g., in localStorage).
3. On each request, client sends JWT in the `Authorization` header.
4. Server validates the signature and reads user info from the token.
5. If valid, the request is processed.

---

### 13. Explain how do we store sensitive user information such as password and credit card number in DB?

### For Passwords:

- **Never store raw/plaintext passwords**.
- Use **hashing** with a secure algorithm like:
  - `BCrypt` (recommended)
  - `PBKDF2`
  - `Argon2`

```java
String hashedPassword = new BCryptPasswordEncoder().encode(rawPassword);
```

- Store only the **hashed value** in the database.
- During login, hash the input and compare with stored hash.

---

### For Credit Card Numbers:

- **Avoid storing if not required**.
- If needed:
  - **Encrypt** the data using strong encryption (e.g., AES).
  - Store only the **last 4 digits** if possible.
  - Follow compliance standards like **PCI-DSS**.

```java
String encryptedCard = encrypt(cardNumber); // custom AES encryption
```

- Also store encryption keys securely (e.g., in a vault).

---

### Summary:

| Data Type   | Protection Method                   |
| ----------- | ----------------------------------- |
| Password    | Hashing (e.g., BCrypt)              |
| Credit Card | Encryption (e.g., AES) + Compliance |

Sensitive data must be protected using **encryption or hashing**, never stored as-is.

### 14. Compare UserDetailService, AuthenticationProvider, AuthenticationManager, AuthenticationFilter?(把这⼏个名字看熟悉也⾏)

These are key components in Spring Security's authentication flow.

---

### 1. `UserDetailsService`

- Loads user information by username.
- Returns a `UserDetails` object.
- Typically used to look up users from a database.

```java
UserDetails loadUserByUsername(String username)
```

---

### 2. `AuthenticationProvider`

- Performs the actual authentication.
- Uses `UserDetailsService` to validate credentials.
- Returns a fully authenticated `Authentication` object.

```java
Authentication authenticate(Authentication authentication)
```

---

### 3. `AuthenticationManager`

- Coordinates authentication.
- Delegates to one or more `AuthenticationProvider`s.

```java
Authentication authenticate(Authentication authentication)
```

---

### 4. `AuthenticationFilter`

- Intercepts login or token-based authentication requests.
- Extracts credentials (e.g., username/password or token) from HTTP request.
- Passes them to `AuthenticationManager`.

### 15. What is the disadvantage of Session? how to overcome the disadvantage?

### Disadvantages of Session:

1. **Server Memory Usage**

   - Sessions are stored on the server, which consumes memory as users increase.

2. **Scalability Issues**

   - In distributed systems, sessions don’t automatically sync across servers (problem in load-balanced setups).

3. **Session Timeout**

   - Users may get logged out unexpectedly if inactive for too long.

4. **Security Risks**
   - Session ID theft (via XSS or interception) can lead to hijacked sessions.

---

### How to Overcome:

1. **Use Token-Based Authentication (e.g., JWT)**

   - Store tokens on the client, making the system stateless and easier to scale.

2. **Session Replication or Central Storage**

   - Use shared session stores (e.g., Redis, database) to sync sessions across servers.

3. **Configure Session Timeout Properly**

   - Set appropriate expiration and use heartbeat mechanisms if needed.

4. **Secure Cookies**
   - Use `HttpOnly`, `Secure`, and `SameSite` flags to protect session cookies.

---

### 16. how to get value from application.properties in Spring security?

- Use `@Value` Annotation
- Use `@ConfigurationProperties`
- Use `Environment`

### 17. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

1. `configure(HttpSecurity http)`

- Defines **authorization rules** and **security filters** for HTTP requests.
- Controls what URLs require login, what roles can access what endpoints, and configures things like CSRF, CORS, form login, JWT, etc.

2. `configure(AuthenticationManagerBuilder auth)`

- Configures **authentication logic**, like how users are verified.
- Defines where to load users from (e.g., in-memory, database, LDAP) and what password encoder to use.

### 18. Reading, 泛读⼀下即可，⾃⼰觉得是重点的，可以多看两眼。https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern

#### 1. 1-12

#### 2. 17 - 30
