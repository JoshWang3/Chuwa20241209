# Homework 21: Exception, Enum, and Collection

## 1. Practice Collection
- Link to practice: [Practice Collection](../Coding/HW3/Collection)

## 2. Checked and Unchecked Exceptions in Java
### What is Checked Exception?
- Checked exceptions are exceptions that are checked at compile-time.
- Example: `IOException`

### What is Unchecked Exception?
- Unchecked exceptions are exceptions that occur during runtime.
- Example: `NullPointerException`

## 3. Can there be multiple finally blocks?
- No, there can only be one `finally` block associated with a single `try-catch` structure.

## 4. Return Values from Catch and Finally Blocks
- If both `catch` and `finally` return values, the value returned by the `finally` block will override the value returned by the `catch` block.

## 5. Runtime/Unchecked Exception vs Compile/Checked Exception
- **Runtime/Unchecked Exception**: Exceptions that occur during runtime, e.g., `ArithmeticException`, `NullPointerException`.
- **Compile/Checked Exception**: Exceptions that are checked at compile-time, e.g., `IOException`, `SQLException`.

## 6. Difference Between `throw` and `throws`
- **`throw`**: Used to explicitly throw an exception.
- **`throws`**: Declares exceptions that a method can throw.

## 7. Exception Handling Order in Java
- Runtime exceptions (e.g., `NullPointerException`, `RuntimeException`) should be caught before the general `Exception` class because Java matches exceptions from specific to general.

## 8. Optional in Java
- **Why use Optional?**
    - To avoid `NullPointerException` by wrapping nullable objects.
- **Example:**
  ```java
  import java.util.Optional;

  public class Main {
      public static void main(String[] args) {
          Optional<String> optional = Optional.ofNullable(null);
          System.out.println(optional.orElse("Default Value"));
      }
  }
    ```
## 9. Why is `finally` always executed?
- The `finally` block is designed to execute cleanup code, ensuring that it runs regardless of whether an exception is thrown or handled. This makes it ideal for resource management tasks like closing files or releasing locks.

## 10. Design Patterns in Java
### Types of Design Patterns:
- **Creational Patterns:**
    - Examples: Singleton, Factory, Builder
- **Structural Patterns:**
    - Examples: Adapter, Decorator, Proxy
- **Behavioral Patterns:**
    - Examples: Observer, Strategy, Command

## 11. SOLID Principles
- **S**: Single Responsibility Principle  
  A class should have only one reason to change.
- **O**: Open-Closed Principle  
  Software entities should be open for extension but closed for modification.
- **L**: Liskov Substitution Principle  
  Objects of a superclass should be replaceable with objects of a subclass without affecting the behavior of the program.
- **I**: Interface Segregation Principle  
  Clients should not be forced to implement interfaces they do not use.
- **D**: Dependency Inversion Principle  
  High-level modules should not depend on low-level modules; both should depend on abstractions.

## 12. Thread-Safe Singleton Pattern
- To implement a thread-safe Singleton pattern, use `synchronized` or `Double-Check Locking`.

### Example:
```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 13. Open-Closed Principle (OCP)
- **Definition:**  
  Software entities (such as classes, modules, or functions) should be open for extension but closed for modification.  
  This means you can add new functionality to an existing codebase without altering its existing code.
- **Example:**  
  Using interfaces or abstract classes allows new behaviors to be introduced without modifying existing classes.

## 14. Liskov Substitution Principle (LSP)
- **Definition:**  
  Objects of a superclass should be replaceable with objects of its subclass without altering the desirable properties of the program (e.g., correctness, task completion).
- **Explanation:**  
  This principle ensures that a subclass can stand in for its superclass without introducing errors or unexpected behaviors.

### Answer to Question:
1. It means that if an object of type A can perform a task, an object of type B (a subtype of A) should also be able to perform the same task.

## 15. Design Pattern Implementation
- Link to singleton: [Singleton Pattern](../Projects/MavenProjects/Singleton)
- Link to factory: [Factory Pattern](../Projects/MavenProjects/Factory)
- Link to builder: [Builder Pattern](../Projects/MavenProjects/Builder)
- Link to pub-sub: [Pub-Sub Pattern](../Projects/MavenProjects/PubSub)