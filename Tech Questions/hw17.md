# HW17 
____
Explain following concepts, and how they coordinate with each other:  
Apache Kafka is a distributed event streaming platform used for high-throughput messaging. It follows a publish-subscribe model and is commonly used for real-time data processing.
- Topic: a logical channel where messages are sent by producers and consumed by consumers. Acts like a message queue and stores data persistently.
- Partition: each topic is split into multiple partitions to support parallel processing. Each partition stores messages in an ordered sequence.
- Broker: a Kafka server that stores topic partitions and handles client requests. Kafka clusters usually consist of multiple brokers for fault tolerance and scalability.
- Consumer Group: a collection of consumers that consume messages from a topic in parallel. Each partition is assigned to only one consumer within a group to ensure load balancing.
- Producer: a producer sends messages to Kafka topics. It can specify the partition key to control which partition the message is sent to.
- Offset: a unique identifier for each message within a partition. Consumers use offsets to track their position in a partition.
- Zookeeper: a service to manage Kafka metadata like Leader election (which broker is in charge of a partition), Broker Registration, Consumer Group Coordination.

### 1. Given N (partitions) and M (consumers), what happens when N >= M and N < M?
- N (partitions) >= M (consumers): Each consumer gets at least one partition. All partitions will be consumed, better load balancing
- N (partitions) < M (consumers): Some consumers will be idle as there are not enough partitions to consume. If a consumer fails, an idle consumer can take over, less processing load per consumer.

### 2. Explain how brokers work with topics.
Brokers store topic partitions and manage read/write requests from producers and consumers. Each broker is responsible for some partitions and replicates data for fault tolerance.

### 3. Are messages pushed to consumers, or do consumers pull messages from topics?
Consumers pull messages from topics, this design avoids overload during high message rates.

### 4. How to avoid duplicate consumption of messages?
To ensure exactly-once processing and avoid duplicate consumption, follow these strategies:
- Use Consumer Offset Commit Properly: Use manual offset commit after processing.
- Use Idempotency in Producers: Enable idempotent producer (acks=all, enable.idempotence=true).

### 5. What happens if some consumers are down in a consumer group? Will data loss occur?
If some consumers fail or go offline in a Kafka consumer group, Kafka automatically redistributes the partitions of the failed consumers to the remaining active consumers. This ensures no data loss occurs, but there might be a short delay due to the rebalancing process.

### 6. What happens if an entire consumer group is down? Will data loss occur?
If all consumers in a consumer group go down, Kafka does not lose data immediately. Instead, messages remain in Kafka until they expire based on the topic's retention policy.

### 7. Explain consumer lag and how to resolve it.
Consumer lag refers to the difference between the latest message in a Kafka partition and the last message successfully processed by a consumer in a consumer group. It measures how far behind a consumer is from real-time message production.  
How to solve:
- Increase consumer throughput: Add more consumers to the consumer group.
- Optimize message handling: batch processing
- Deploy consumers closer to brokers or optimize network

### 8. How does Kafka track message delivery?
- Offsets: Kafka tracks the offset of the last message consumed by each consumer in a partition. Consumers commit offsets to Kafka after processing messages.
- Log compaction ensures messages are retained if needed

### 9. Compare Kafka vs. RabbitMQ, messaging frameworks vs. MySQL (Why Kafka?)
- Kafka vs RabbitMQ: Both are message brokers, but Kafka is designed for high-throughput, highly scalable and fault-tolerant event streaming, while RabbitMQ is more focused on short-lived messages and low-latency transaction.
- Messaging frameworks vs MySQL: Using messaging frameworks (e.g., Kafka, RabbitMQ, ActiveMQ, Redis Pub/Sub) for event-driven architectures is far superior to using MySQL as a queue. While MySQL can be used to store and retrieve messages, it is not optimized for high-performance messaging.






















